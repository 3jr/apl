
(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn.apply(module.exports, [module.exports, function(name) {
            return require(name, dirname(path));
          }, module]);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle)
        modules[key] = bundle[key];
    };
  }
  return this.require.define;
}).call(this)({"apl": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var compile, exports;

exports = module.exports = function(aplSource) {
  return require('./compiler').exec(aplSource);
};

exports.createGlobalContext = function() {
  return Object.create(require('./vocabulary'));
};

compile = require("./compiler").compile;

exports.compile = function(code) {
  return "(function(){" + (compile(code, {
    embedded: true
  })) + "})()";
};

exports.fn = {
  compile: function(code) {
    return "function(){" + (compile(code, {
      embedded: true
    })) + "}";
  }
};
}, "array": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, LengthError, prod, strideForShape, _ref;



prod = require('./helpers').prod;

_ref = require('./errors'), LengthError = _ref.LengthError, DomainError = _ref.DomainError;

this.APLArray = APLArray = (function() {
  function APLArray(data, shape, stride, offset) {
    var i, tmp0, tmp1, tmp2, x, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
    this.data = data;
    this.shape = shape;
    this.stride = stride;
    this.offset = offset != null ? offset : 0;
    if (this.shape == null) {
      this.shape = [this.data.length];
    }
    if (this.stride == null) {
      this.stride = strideForShape(this.shape);
    }
    if (!(this.data instanceof Array || typeof this.data === 'string')) {
      throw Error("\"assert @data instanceof Array or typeof @data is 'string'\" at src/array.coffee:14");
    }
    if (!(this.shape instanceof Array)) {
      throw Error("\"assert @shape instanceof Array\" at src/array.coffee:15");
    }
    if (!(this.stride instanceof Array)) {
      throw Error("\"assert @stride instanceof Array\" at src/array.coffee:16");
    }
    if (!(this.data.length === 0 || ((tmp0 = this.offset) === ~~tmp0 && ((0) <= (_ref1 = tmp0) && _ref1 < this.data.length)))) {
      throw Error("\"assert @data.length is 0 or isInt @offset, 0, @data.length\" at src/array.coffee:17");
    }
    if (!(this.shape.length === this.stride.length)) {
      throw Error("\"assert @shape.length is @stride.length\" at src/array.coffee:18");
    }
    _ref2 = this.shape;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      x = _ref2[_i];
      if (!((tmp1 = (x)) === ~~tmp1 && (0) <= tmp1)) {
        throw Error("\"for x in @shape then assert isInt x, 0\" at src/array.coffee:19");
      }
    }
    if (this.data.length) {
      _ref3 = this.stride;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        x = _ref3[i];
        if (!((tmp2 = (x)) === ~~tmp2 && ((-this.data.length) <= (_ref4 = tmp2) && _ref4 < (this.data.length + 1)))) {
          throw Error("\"for x, i in @stride then assert isInt x, -@data.length, @data.length + 1\" at src/array.coffee:21");
        }
      }
    } else {
      if (!(prod(this.shape) === 0)) {
        throw Error("\"assert prod(@shape) is 0\" at src/array.coffee:23");
      }
    }
  }

  APLArray.prototype.get = function(indices) {
    var axis, index, p, _i, _len;
    p = this.offset;
    for (axis = _i = 0, _len = indices.length; _i < _len; axis = ++_i) {
      index = indices[axis];
      p += index * this.stride[axis];
    }
    return this.data[p];
  };

  APLArray.prototype.empty = function() {
    var d, _i, _len, _ref1;
    _ref1 = this.shape;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      d = _ref1[_i];
      if (!d) {
        return true;
      }
    }
    return false;
  };

  APLArray.prototype.each = function(f) {
    var axis, indices, p;
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:36");
    }
    if (this.empty()) {
      return;
    }
    p = this.offset;
    indices = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.shape;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        axis = _ref1[_i];
        _results.push(0);
      }
      return _results;
    }).call(this);
    while (true) {
      f(this.data[p], indices);
      axis = this.shape.length - 1;
      while (axis >= 0 && indices[axis] + 1 === this.shape[axis]) {
        p -= indices[axis] * this.stride[axis];
        indices[axis--] = 0;
      }
      if (axis < 0) {
        break;
      }
      indices[axis]++;
      p += this.stride[axis];
    }
  };

  APLArray.prototype.each2 = function(a, f) {
    var axis, indices, p, q, _i, _ref1;
    if (!(a instanceof APLArray)) {
      throw Error("\"assert a instanceof APLArray\" at src/array.coffee:52");
    }
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:53");
    }
    if (!(this.shape.length === a.shape.length)) {
      throw Error("\"assert @shape.length is a.shape.length\" at src/array.coffee:54");
    }
    for (axis = _i = 0, _ref1 = this.shape.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; axis = 0 <= _ref1 ? ++_i : --_i) {
      if (!(this.shape[axis] === a.shape[axis])) {
        throw Error("\"assert @shape[axis] is a.shape[axis]\" at src/array.coffee:56");
      }
    }
    if (this.empty()) {
      return;
    }
    p = this.offset;
    q = a.offset;
    indices = (function() {
      var _j, _len, _ref2, _results;
      _ref2 = this.shape;
      _results = [];
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        axis = _ref2[_j];
        _results.push(0);
      }
      return _results;
    }).call(this);
    while (true) {
      f(this.data[p], a.data[q], indices);
      axis = this.shape.length - 1;
      while (axis >= 0 && indices[axis] + 1 === this.shape[axis]) {
        p -= indices[axis] * this.stride[axis];
        q -= indices[axis] * a.stride[axis];
        indices[axis--] = 0;
      }
      if (axis < 0) {
        break;
      }
      indices[axis]++;
      p += this.stride[axis];
      q += a.stride[axis];
    }
  };

  APLArray.prototype.map = function(f) {
    var data;
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:75");
    }
    data = [];
    this.each(function(x, indices) {
      return data.push(f(x, indices));
    });
    return new APLArray(data, this.shape);
  };

  APLArray.prototype.map2 = function(a, f) {
    var data;
    if (!(a instanceof APLArray)) {
      throw Error("\"assert a instanceof APLArray\" at src/array.coffee:81");
    }
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:82");
    }
    data = [];
    this.each2(a, function(x, y, indices) {
      return data.push(f(x, y, indices));
    });
    return new APLArray(data, this.shape);
  };

  APLArray.prototype.toArray = function(limit) {
    var e, r;
    if (limit == null) {
      limit = Infinity;
    }
    r = [];
    try {
      this.each(function(x) {
        if (r.length >= limit) {
          throw 'break';
        }
        r.push(x);
      });
    } catch (_error) {
      e = _error;
      if (e !== 'break') {
        throw e;
      }
    }
    return r;
  };

  APLArray.prototype.toInt = function(start, end) {
    var r;
    if (start == null) {
      start = -Infinity;
    }
    if (end == null) {
      end = Infinity;
    }
    r = this.unwrap();
    if (typeof r !== 'number' || r !== ~~r || !((start <= r && r < end))) {
      throw DomainError();
    }
    return r;
  };

  APLArray.prototype.toBool = function() {
    return this.toInt(0, 2);
  };

  APLArray.prototype.isSingleton = function() {
    var n, _i, _len, _ref1;
    _ref1 = this.shape;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      n = _ref1[_i];
      if (n !== 1) {
        return false;
      }
    }
    return true;
  };

  APLArray.prototype.isSimple = function() {
    return this.shape.length === 0 && !(this.data[this.offset] instanceof APLArray);
  };

  APLArray.prototype.unwrap = function() {
    if (prod(this.shape) !== 1) {
      throw LengthError();
    }
    return this.data[this.offset];
  };

  APLArray.prototype.getPrototype = function() {
    if (this.empty() || typeof this.data[this.offset] !== 'string') {
      return 0;
    } else {
      return ' ';
    }
  };

  return APLArray;

})();

this.strideForShape = strideForShape = function(shape) {
  var i, r, tmp3, _i, _ref1;
  if (!(shape instanceof Array)) {
    throw Error("\"assert shape instanceof Array\" at src/array.coffee:124");
  }
  if (shape.length === 0) {
    return [];
  }
  r = Array(shape.length);
  r[r.length - 1] = 1;
  for (i = _i = _ref1 = r.length - 2; _i >= 0; i = _i += -1) {
    if (!((tmp3 = shape[i]) === ~~tmp3 && (0) <= tmp3)) {
      throw Error("\"assert isInt shape[i], 0\" at src/array.coffee:129");
    }
    r[i] = r[i + 1] * shape[i + 1];
  }
  return r;
};

APLArray.zero = new APLArray([0], []);

APLArray.one = new APLArray([1], []);

APLArray.zilde = new APLArray([], [0]);

APLArray.scalar = function(x) {
  return new APLArray([x], []);
};

APLArray.bool = [APLArray.zero, APLArray.one];
}, "command": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var astToString, compile, exec, fs, nodes, optimist, repl, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };



optimist = require('optimist');

fs = require('fs');

_ref = require('./compiler'), nodes = _ref.nodes, compile = _ref.compile, exec = _ref.exec;

this.main = function() {
  var aplCode, argv, b, ctx, filename, jsCode, k, knownOptions, opts, vocabulary;
  argv = optimist.usage('Usage: apl [options] path/to/script.apl [args]\n\nIf called without options, `apl` will run your script.').describe({
    c: 'compile to JavaScript and save as .js files',
    h: 'display this help message',
    i: 'run an interactive APL REPL',
    n: 'print out the parse tree that the parser produces',
    p: 'print out the compiled JavaScript',
    s: 'listen for and compile scripts over stdio'
  }).alias({
    c: 'compile',
    h: 'help',
    i: 'interactive',
    n: 'nodes',
    p: 'print',
    s: 'stdio'
  }).boolean('chinps'.split('')).argv;
  if (argv.help) {
    return optimist.showHelp();
  }
  knownOptions = 'c compile h help i interactive n nodes p print s stdio _'.split(' ');
  for (k in argv) {
    if (!((__indexOf.call(knownOptions, k) < 0) && !k.match(/^\$\d+/))) {
      continue;
    }
    process.stderr.write("Unknown option, \"" + k + "\"\n\n");
    optimist.showHelp();
    return;
  }
  if (argv.interactive && (argv.compile || argv.nodes || argv.print || argv.stdio)) {
    process.stderr.write('Option -i (--interactive) is incompatible with the following options:\n  -c, --compile\n  -n, --nodes\n  -p, --print\n  -s, --stdio\n\n');
    optimist.showHelp();
    return;
  }
  if (argv.interactive && argv._.length) {
    process.stderr.write('Option -i (--interactive) cannot be used with positional arguments.\n\n');
    optimist.showHelp();
    return;
  }
  vocabulary = require('./vocabulary');
  ctx = Object.create(vocabulary);
  if (argv.interactive || !(argv._.length || argv.stdio)) {
    return repl(ctx);
  }
  opts = {};
  if (argv.stdio) {
    opts.file = '<stdin>';
    aplCode = Buffer.concat((function() {
      var _results;
      _results = [];
      while (true) {
        b = new Buffer(1024);
        k = fs.readSync(0, b, 0, b.length, null);
        if (!k) {
          break;
        }
        _results.push(b.slice(0, k));
      }
      return _results;
    })()).toString('utf8');
  } else {
    opts.file = argv._[0];
    aplCode = fs.readFileSync(opts.file, 'utf8');
  }
  if (argv.nodes) {
    process.stdout.write(astToString(nodes(aplCode, opts)));
    return;
  }
  jsCode = compile(aplCode, opts);
  if (argv.compile) {
    jsCode = "\#!/usr/bin/env node\nvar _ = require('apl').createGlobalContext();\n" + jsCode;
    if (argv.stdio || argv.print) {
      return process.stdout.write(jsCode);
    } else {
      filename = argv._[0].replace(/\.(apl|coffee)$/, '.js');
      return fs.writeFileSync(filename, jsCode, 'utf8');
    }
  } else {
    return (new Function("var _ = arguments[0];\n" + jsCode))(require('./apl').createGlobalContext());
  }
};

repl = function(ctx) {
  var format, rl;
  rl = require('readline').createInterface(process.stdin, process.stdout);
  rl.setPrompt('      ');
  format = require('./vocabulary/format').format;
  rl.on('line', function(line) {
    var e, result;
    try {
      if (!line.match(/^[\ \t\f\r\n]*$/)) {
        result = exec(line, {
          ctx: ctx,
          exposeTopLevelScope: true
        });
        process.stdout.write(format(result).join('\n') + '\n');
      }
    } catch (_error) {
      e = _error;
      process.stdout.write(e.toString());
    }
    rl.prompt();
  });
  rl.on('close', function() {
    process.stdout.write('\n');
    process.exit(0);
  });
  rl.prompt();
};

astToString = function(x, indent) {
  var y;
  if (indent == null) {
    indent = '';
  }
  if (x instanceof Array) {
    if (x.length === 2 && !(x[1] instanceof Array)) {
      return "" + indent + x[0] + " " + (JSON.stringify(x[1])) + "\n";
    } else {
      return "" + indent + x[0] + "\n" + (((function() {
        var _i, _len, _ref1, _results;
        _ref1 = x.slice(1);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          y = _ref1[_i];
          _results.push(astToString(y, indent + '  '));
        }
        return _results;
      })()).join(''));
    }
  } else {
    return "" + indent + (JSON.stringify(x)) + "\n";
  }
};
}, "compiler": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var SyntaxError, all, compile, compilerError, lhsToJavaScript, nodes, parser, resolveExprs, toJavaScript, vocabulary;



parser = require('./parser');

vocabulary = require('./vocabulary');

all = require('./helpers').all;

SyntaxError = require('./errors').SyntaxError;

resolveExprs = function(ast, opts) {
  var k, m, node, queue, scopeNode, v, varInfo, vars, visit, visitLHS, _i, _j, _len, _len1, _ref, _ref1, _ref2;
  if (opts == null) {
    opts = {};
  }
  ast.vars = {
    '⍺': {
      type: 'X',
      jsCode: '_a'
    },
    '⍵': {
      type: 'X',
      jsCode: '_w'
    },
    '∇': {
      type: 'F',
      jsCode: 'arguments.callee'
    }
  };
  _ref = opts.ctx;
  for (k in _ref) {
    v = _ref[k];
    ast.vars[k] = varInfo = {
      type: 'X',
      jsCode: "_[" + (JSON.stringify(k)) + "]"
    };
    if (typeof v === 'function') {
      varInfo.type = 'F';
      if ((m = v.aplMetaInfo) != null) {
        if (m.isPrefixAdverb) {
          varInfo.isPrefixAdverb = true;
        }
        if (m.isPostfixAdverb) {
          varInfo.isPostfixAdverb = true;
        }
        if (m.isConjunction) {
          varInfo.isConjunction = true;
        }
      }
      if (/^[gs]et_.*/.test(k)) {
        ast.vars[k.slice(4)] = {
          type: 'X'
        };
      }
    }
  }
  if (opts.vars) {
    _ref1 = opts.vars;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      v = _ref1[_i];
      ast.vars[v.name] = {
        type: 'X',
        jsCode: v.name
      };
    }
  }
  ast.scopeDepth = 0;
  if (opts.exposeTopLevelScope) {
    ast.scopeObjectJS = '_';
    ast.scopeInitJS = '';
  } else {
    ast.scopeObjectJS = '_0';
    ast.scopeInitJS = "var _0 = {}";
  }
  queue = [ast];
  while (queue.length) {
    vars = (scopeNode = queue.shift()).vars;
    visit = function(node) {
      var a, c, h, i, j, name, t, x, _j, _k, _len1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      node.scopeNode = scopeNode;
      switch (node[0]) {
        case 'body':
          node.vars = Object.create(vars);
          node.scopeDepth = scopeNode.scopeDepth + 1;
          node.scopeObjectJS = '_' + node.scopeDepth;
          node.scopeInitJS = "var " + node.scopeObjectJS + " = {}";
          queue.push(node);
          return null;
        case 'guard':
          visit(node[1]);
          return visit(node[2]);
        case 'assign':
          h = visit(node[2]);
          visitLHS(node[1], h.type);
          return h;
        case 'symbol':
          name = node[1];
          if (((_ref2 = (v = vars["get_" + name])) != null ? _ref2.type : void 0) === 'F') {
            v.used = true;
            return {
              type: 'X'
            };
          } else {
            v = vars[name];
            if (!v) {
              compilerError(node, opts, "Symbol '" + name + "' is referenced before assignment.");
            }
            v.used = true;
            return v;
          }
          break;
        case 'lambda':
          visit(node[1]);
          return {
            type: 'F'
          };
        case 'string':
        case 'number':
        case 'embedded':
          return {
            type: 'X'
          };
        case 'index':
          _ref3 = node.slice(2);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            c = _ref3[_j];
            if (!(c !== null)) {
              continue;
            }
            t = visit(c);
            if (t.type !== 'X') {
              compilerError(node, opts, 'Only expressions of type data can be used as an index.');
            }
          }
          return visit(node[1]);
        case 'expr':
          a = node.slice(1);
          h = Array(a.length);
          for (i = _k = _ref4 = a.length - 1; _ref4 <= 0 ? _k <= 0 : _k >= 0; i = _ref4 <= 0 ? ++_k : --_k) {
            h[i] = visit(a[i]);
          }
          i = 0;
          while (i < a.length - 1) {
            if ((h[i].type === (_ref5 = h[i + 1].type) && _ref5 === 'X')) {
              j = i + 2;
              while (j < a.length && h[j].type === 'X') {
                j++;
              }
              [].splice.apply(a, [i, j - i].concat(_ref6 = [['vector'].concat(a.slice(i, j))])), _ref6;
              [].splice.apply(h, [i, j - i].concat(_ref7 = [
                {
                  type: 'X'
                }
              ])), _ref7;
            } else {
              i++;
            }
          }
          i = a.length - 2;
          while (--i >= 0) {
            if (h[i + 1].isConjunction && (h[i].type === 'F' || h[i + 2].type === 'F')) {
              [].splice.apply(a, [i, (i + 3) - i].concat(_ref8 = [['conjunction'].concat(a.slice(i, i + 3))])), _ref8;
              [].splice.apply(h, [i, (i + 3) - i].concat(_ref9 = [
                {
                  type: 'F'
                }
              ])), _ref9;
              i--;
            }
          }
          i = a.length - 1;
          while (--i >= 0) {
            if (h[i].isPrefixAdverb && h[i + 1].type === 'F') {
              [].splice.apply(a, [i, (i + 2) - i].concat(_ref10 = [['prefixAdverb'].concat(a.slice(i, i + 2))])), _ref10;
              [].splice.apply(h, [i, (i + 2) - i].concat(_ref11 = [
                {
                  type: 'F'
                }
              ])), _ref11;
            }
          }
          i = 0;
          while (i < a.length - 1) {
            if (h[i].type === 'F' && h[i + 1].isPostfixAdverb) {
              [].splice.apply(a, [i, (i + 2) - i].concat(_ref12 = [['postfixAdverb'].concat(a.slice(i, i + 2))])), _ref12;
              [].splice.apply(h, [i, (i + 2) - i].concat(_ref13 = [
                {
                  type: 'F'
                }
              ])), _ref13;
            } else {
              i++;
            }
          }
          if (h.length === 2 && (h[0].type === (_ref14 = h[1].type) && _ref14 === 'F')) {
            a = [['hook'].concat(a)];
            h = [
              {
                type: 'F'
              }
            ];
          }
          if (h.length >= 3 && h.length % 2 === 1 && all((function() {
            var _l, _len2, _results;
            _results = [];
            for (_l = 0, _len2 = h.length; _l < _len2; _l++) {
              x = h[_l];
              _results.push(x.type === 'F');
            }
            return _results;
          })())) {
            a = [['fork'].concat(a)];
            h = [
              {
                type: 'F'
              }
            ];
          }
          if (h[h.length - 1].type === 'F') {
            if (h.length > 1) {
              compilerError(a[h.length - 1], opts, 'Trailing function in expression');
            }
          } else {
            while (h.length > 1) {
              if (h.length === 2 || h[h.length - 3].type === 'F') {
                [].splice.apply(a, [(_ref15 = h.length - 2), 9e9].concat(_ref16 = [['monadic'].concat(a.slice(h.length - 2))])), _ref16;
                [].splice.apply(h, [(_ref17 = h.length - 2), 9e9].concat(_ref18 = [
                  {
                    type: 'X'
                  }
                ])), _ref18;
              } else {
                [].splice.apply(a, [(_ref19 = h.length - 3), 9e9].concat(_ref20 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref20;
                [].splice.apply(h, [(_ref21 = h.length - 3), 9e9].concat(_ref22 = [
                  {
                    type: 'X'
                  }
                ])), _ref22;
              }
            }
          }
          [].splice.apply(node, [0, 9e9].concat(_ref23 = a[0])), _ref23;
          return h[0];
        default:
          throw Error("Unrecognised node type, '" + node[0] + "'");
      }
    };
    visitLHS = function(node, rhsType) {
      var child, name, _j, _k, _len1, _len2, _ref2, _ref3;
      node.scopeNode = scopeNode;
      switch (node[0]) {
        case 'symbol':
          name = node[1];
          if (name === '∇') {
            compilerError(node, opts, 'Assignment to ∇ is not allowed.');
          }
          if (vars[name]) {
            if (vars[name].type !== rhsType) {
              compilerError(node, opts, ("Inconsistent usage of symbol '" + name + "', it is ") + "assigned both nouns and verbs.");
            }
          } else {
            vars[name] = {
              type: rhsType,
              jsCode: "" + scopeNode.scopeObjectJS + "[" + (JSON.stringify(name)) + "]"
            };
          }
          break;
        case 'expr':
          if (rhsType !== 'X') {
            compilerError(node, opts, 'Strand assignment can be used only for nouns.');
          }
          _ref2 = node.slice(1);
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            child = _ref2[_j];
            visitLHS(child, rhsType);
          }
          break;
        case 'index':
          if (rhsType !== 'X') {
            compilerError(node, opts, 'Index assignment can be used only for nouns.');
          }
          visitLHS(node[1], 'X');
          _ref3 = node.slice(2);
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            child = _ref3[_k];
            if (child) {
              visit(child);
            }
          }
          break;
        default:
          compilerError(node, opts, "Invalid LHS node type: " + (JSON.stringify(node[0])));
      }
      return {
        type: rhsType
      };
    };
    _ref2 = scopeNode.slice(1);
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      node = _ref2[_j];
      visit(node);
    }
  }
};

toJavaScript = function(node, opts) {
  var a, c, child, d, i, n, name, rhsJS, s, v, vars, x, _i, _len, _ref, _ref1;
  switch (node[0]) {
    case 'body':
      if (node.length === 1) {
        return 'return _["get_⍬"]();\n';
      } else {
        a = [node.scopeInitJS];
        _ref = node.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          a.push(toJavaScript(child, opts));
        }
        a[a.length - 1] = "return " + a[a.length - 1] + ";";
        return a.join(';\n');
      }
      break;
    case 'guard':
      return "if (_._bool(" + (toJavaScript(node[1], opts)) + ")) {\n  return " + (toJavaScript(node[2], opts)) + ";\n}";
    case 'assign':
      vars = node.scopeNode.vars;
      rhsJS = toJavaScript(node[2], opts);
      return lhsToJavaScript(node[1], opts, rhsJS);
    case 'symbol':
      name = node[1];
      vars = node.scopeNode.vars;
      if (((_ref1 = (v = vars["get_" + name])) != null ? _ref1.type : void 0) === 'F') {
        v.used = true;
        return "" + v.jsCode + "()";
      } else {
        v = vars[name];
        v.used = true;
        return v.jsCode;
      }
      break;
    case 'lambda':
      return "(function (_w, _a) {\n  " + (toJavaScript(node[1], opts)) + "\n})";
    case 'string':
      s = node[1];
      d = s[0];
      return "_._aplify(" + (d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d) + ")";
    case 'number':
      s = node[1].replace(/¯/g, '-');
      a = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = s.split(/j/i);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          x = _ref2[_j];
          if (x === '-') {
            _results.push('Infinity');
          } else if (x === '--') {
            _results.push('-Infinity');
          } else if (x.match(/^-?0x/i)) {
            _results.push(parseInt(x, 16));
          } else {
            _results.push(parseFloat(x));
          }
        }
        return _results;
      })();
      if (a.length === 1 || a[1] === 0) {
        return "_._aplify(" + a[0] + ")";
      } else {
        return "new _._complex(" + a[0] + ", " + a[1] + ")";
      }
      break;
    case 'index':
      return "_._index(        _._aplify([" + (((function() {
        var _j, _len1, _ref2, _results;
        _ref2 = node.slice(2);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          c = _ref2[_j];
          if (c) {
            _results.push(toJavaScript(c, opts));
          }
        }
        return _results;
      })()).join(', ')) + "]),        " + (toJavaScript(node[1], opts)) + ",        _._aplify([" + ((function() {
        var _j, _len1, _ref2, _results;
        _ref2 = node.slice(2);
        _results = [];
        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
          c = _ref2[i];
          if (c !== null) {
            _results.push(i);
          }
        }
        return _results;
      })()) + "])      )";
    case 'expr':
      throw Error('No "expr" nodes are expected at this stage.');
      break;
    case 'vector':
      n = node.length - 1;
      return "_._aplify([" + (((function() {
        var _j, _len1, _ref2, _results;
        _ref2 = node.slice(1);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          child = _ref2[_j];
          _results.push(toJavaScript(child, opts));
        }
        return _results;
      })()).join(', ')) + "])";
    case 'monadic':
      return "" + (toJavaScript(node[1], opts)) + "(" + (toJavaScript(node[2], opts)) + ")";
    case 'dyadic':
      return "" + (toJavaScript(node[2], opts)) + "(" + (toJavaScript(node[3], opts)) + ", " + (toJavaScript(node[1], opts)) + ")";
    case 'prefixAdverb':
      return "" + (toJavaScript(node[1], opts)) + "(" + (toJavaScript(node[2], opts)) + ")";
    case 'conjunction':
      return "" + (toJavaScript(node[2], opts)) + "(" + (toJavaScript(node[3], opts)) + ", " + (toJavaScript(node[1], opts)) + ")";
    case 'postfixAdverb':
      return "" + (toJavaScript(node[2], opts)) + "(" + (toJavaScript(node[1], opts)) + ")";
    case 'hook':
      return "_._hook(" + (toJavaScript(node[2], opts)) + ", " + (toJavaScript(node[1], opts)) + ")";
    case 'fork':
      return "_._fork([" + ((function() {
        var _j, _len1, _ref2, _results;
        _ref2 = node.slice(1);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          c = _ref2[_j];
          _results.push(toJavaScript(c, opts));
        }
        return _results;
      })()) + "])";
    case 'embedded':
      return "_._aplify(" + (node[1].replace(/(^«|»$)/g, '')) + ")";
    default:
      throw Error("Unrecognised node type, '" + node[0] + "'");
  }
};

lhsToJavaScript = function(node, opts, rhsJS) {
  var c, child, i, name, v, vars, _ref;
  switch (node[0]) {
    case 'symbol':
      name = node[1];
      vars = node.scopeNode.vars;
      if (((_ref = (v = vars["set_" + name])) != null ? _ref.type : void 0) === 'F') {
        v.used = true;
        return "" + v.jsCode + "(" + rhsJS + ")";
      } else {
        return "" + vars[name].jsCode + " = " + rhsJS;
      }
      break;
    case 'expr':
      return "(function (_x) {\n  if (_x.isSingleton()) {\n    " + (((function() {
        var _i, _len, _ref1, _results;
        _ref1 = node.slice(1);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          child = _ref1[_i];
          _results.push(lhsToJavaScript(child, opts, '_x'));
        }
        return _results;
      })()).join('; ')) + "\n  } else if (_x.shape.length === 1 && _x.shape[0] === " + (node.length - 1) + ") {\n    var _y = _x.toArray();\n    " + (((function() {
        var _i, _len, _ref1, _results;
        _ref1 = node.slice(1);
        _results = [];
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          child = _ref1[i];
          _results.push(lhsToJavaScript(child, opts, "_._aplify(_y[" + i + "])"));
        }
        return _results;
      })()).join('; ')) + "\n  } else {\n    throw Error('LENGTH ERROR, Cannot perform strand assignment');\n  }\n  return _x;\n})(" + rhsJS + ")";
    case 'index':
      return lhsToJavaScript(node[1], opts, "_._substitute(\n  " + rhsJS + ",\n  _._aplify([" + (((function() {
        var _i, _len, _ref1, _results;
        _ref1 = node.slice(2);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          if (c) {
            _results.push(toJavaScript(c, opts));
          }
        }
        return _results;
      })()).join(', ')) + "]),\n  " + (toJavaScript(node[1], opts)) + ",\n  _._aplify([" + ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = node.slice(2);
        _results = [];
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          c = _ref1[i];
          if (c !== null) {
            _results.push(i);
          }
        }
        return _results;
      })()) + "])\n)");
    default:
      throw Error("Unrecognised node type, '" + node[0] + "'");
  }
};

compilerError = function(node, opts, message) {
  throw SyntaxError(message, {
    file: opts.file,
    line: node.startLine,
    col: node.startCol,
    aplCode: opts.aplCode
  });
};

this.nodes = nodes = function(aplCode, opts) {
  var ast;
  if (opts == null) {
    opts = {};
  }
  opts.aplCode = aplCode;
  if (opts.ctx == null) {
    opts.ctx = Object.create(vocabulary);
  }
  ast = parser.parse(aplCode, opts);
  resolveExprs(ast, opts);
  return ast;
};

this.compile = compile = function(aplCode, opts) {
  var ast, jsCode;
  if (opts == null) {
    opts = {};
  }
  opts.aplCode = aplCode;
  ast = nodes(aplCode, opts);
  if (opts.exposeTopLevelScope) {
    ast.scopeObjectJS = '_';
  }
  jsCode = toJavaScript(ast, opts);
  if (opts.embedded) {
    jsCode = "var _ = require('apl').createGlobalContext(),\n    _a = arguments[0],\n    _w = arguments[1];\n" + jsCode;
  }
  return jsCode;
};

this.exec = function(aplCode, opts) {
  var jsCode;
  if (opts == null) {
    opts = {};
  }
  opts.aplCode = aplCode;
  jsCode = compile(aplCode, opts);
  return (new Function("var _ = arguments[0];\n" + jsCode))(opts.ctx);
};
}, "complex": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var Complex, DomainError, complexify, simplify;



DomainError = require('./errors').DomainError;

this.complexify = complexify = function(x) {
  if (typeof x === 'number') {
    return new Complex(x, 0);
  } else if (x instanceof Complex) {
    return x;
  } else {
    throw DomainError();
  }
};

this.simplify = simplify = function(re, im) {
  if (im !== 0) {
    return new Complex(re, im);
  } else {
    return re;
  }
};

this.Complex = Complex = (function() {
  var acos, add, asin, atan, cosh, direction, divide, exp, firstquadrant, floor, gcd, iszero, itimes, log, multiply, negate, negitimes, pow, residue, sinh, sqrt, subtract, tanh;

  function Complex(re, im) {
    this.re = re;
    this.im = im != null ? im : 0;
    if (!(typeof this.re === 'number')) {
      throw Error("\"assert typeof @re is 'number'\" at src/complex.coffee:23");
    }
    if (!(typeof this.im === 'number')) {
      throw Error("\"assert typeof @im is 'number'\" at src/complex.coffee:24");
    }
    if (isNaN(this.re) || isNaN(this.im)) {
      throw DomainError('NaN');
    }
  }

  Complex.prototype.toString = function() {
    return ("" + this.re + "J" + this.im).replace(/-|Infinity/g, '¯');
  };

  Complex.exp = exp = function(x) {
    var r;
    x = complexify(x);
    r = Math.exp(x.re);
    return simplify(r * Math.cos(x.im), r * Math.sin(x.im));
  };

  Complex.log = log = function(x) {
    if (typeof x === 'number' && x > 0) {
      return Math.log(x);
    } else {
      x = complexify(x);
      return simplify(Math.log(Math.sqrt(x.re * x.re + x.im * x.im)), direction(x));
    }
  };

  Complex.conjugate = function(x) {
    return new Complex(x.re, -x.im);
  };

  Complex.negate = negate = function(x) {
    return new Complex(-x.re, -x.im);
  };

  Complex.itimes = itimes = function(x) {
    x = complexify(x);
    return simplify(-x.im, x.re);
  };

  Complex.negitimes = negitimes = function(x) {
    x = complexify(x);
    return simplify(x.im, -x.re);
  };

  Complex.add = add = function(x, y) {
    x = complexify(x);
    y = complexify(y);
    return simplify(x.re + y.re, x.im + y.im);
  };

  Complex.subtract = subtract = function(x, y) {
    x = complexify(x);
    y = complexify(y);
    return simplify(x.re - y.re, x.im - y.im);
  };

  Complex.multiply = multiply = function(x, y) {
    x = complexify(x);
    y = complexify(y);
    return simplify(x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re);
  };

  Complex.divide = divide = function(x, y) {
    var d;
    x = complexify(x);
    y = complexify(y);
    d = y.re * y.re + y.im * y.im;
    return simplify((x.re * y.re + x.im * y.im) / d, (y.re * x.im - y.im * x.re) / d);
  };

  Complex.pow = pow = function(x, y) {
    var _ref;
    if ((typeof x === (_ref = typeof y) && _ref === 'number') && x >= 0) {
      return Math.pow(x, y);
    } else {
      return exp(multiply(y, log(x)));
    }
  };

  Complex.sqrt = sqrt = function(x) {
    if (typeof x === 'number' && x >= 0) {
      return Math.sqrt(x);
    } else {
      return pow(x, 0.5);
    }
  };

  Complex.magnitude = function(x) {
    return Math.sqrt(x.re * x.re + x.im * x.im);
  };

  Complex.direction = direction = function(x) {
    return Math.atan2(x.im, x.re);
  };

  Complex.sin = function(x) {
    return negitimes(sinh(itimes(x)));
  };

  Complex.cos = function(x) {
    return cosh(itimes(x));
  };

  Complex.tan = function(x) {
    return negitimes(tanh(itimes(x)));
  };

  Complex.asin = asin = function(x) {
    x = complexify(x);
    return negitimes(log(add(itimes(x), sqrt(subtract(1, pow(x, 2))))));
  };

  Complex.acos = acos = function(x) {
    var r;
    x = complexify(x);
    r = negitimes(log(add(x, sqrt(subtract(pow(x, 2), 1)))));
    if (r instanceof Complex && (r.re < 0 || (r.re === 0 && r.im < 0))) {
      return negate(r);
    } else {
      return r;
    }
  };

  Complex.atan = atan = function(x) {
    var ix;
    x = complexify(x);
    ix = itimes(x);
    return multiply(new Complex(0, .5), subtract(log(subtract(1, ix)), log(add(1, ix))));
  };

  Complex.sinh = sinh = function(x) {
    var a;
    a = exp(x);
    return multiply(0.5, subtract(a, divide(1, a)));
  };

  Complex.cosh = cosh = function(x) {
    var a;
    a = exp(x);
    return multiply(0.5, add(a, divide(1, a)));
  };

  Complex.tanh = tanh = function(x) {
    var a, b;
    a = exp(x);
    b = divide(1, a);
    return divide(subtract(a, b), add(a, b));
  };

  Complex.asinh = function(x) {
    return itimes(asin(negitimes(x)));
  };

  Complex.acosh = function(x) {
    var sign;
    x = complexify(x);
    sign = x.im > 0 || (x.im === 0 && x.re <= 1) ? 1 : -1;
    return multiply(new Complex(0, sign), acos(x));
  };

  Complex.atanh = function(x) {
    return itimes(atan(negitimes(x)));
  };

  Complex.floor = floor = function(x) {
    var i, im, r, re, _ref, _ref1;
    if (typeof x === 'number') {
      return Math.floor(x);
    } else {
      x = complexify(x);
      _ref = [Math.floor(x.re), Math.floor(x.im)], re = _ref[0], im = _ref[1];
      _ref1 = [x.re - re, x.im - im], r = _ref1[0], i = _ref1[1];
      if (r + i >= 1) {
        if (r >= i) {
          re++;
        } else {
          im++;
        }
      }
      return simplify(re, im);
    }
  };

  Complex.ceil = function(x) {
    var i, im, r, re, _ref, _ref1;
    if (typeof x === 'number') {
      return Math.ceil(x);
    } else {
      x = complexify(x);
      _ref = [Math.ceil(x.re), Math.ceil(x.im)], re = _ref[0], im = _ref[1];
      _ref1 = [re - x.re, im - x.im], r = _ref1[0], i = _ref1[1];
      if (r + i >= 1) {
        if (r >= i) {
          re--;
        } else {
          im--;
        }
      }
      return simplify(re, im);
    }
  };

  iszero = function(x) {
    return x === 0 || (x instanceof Complex && x.re === 0 && x.im === 0);
  };

  Complex.residue = residue = function(x, y) {
    var _ref;
    if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
      if (x === 0) {
        return y;
      } else {
        return y - x * Math.floor(y / x);
      }
    } else {
      if (iszero(x)) {
        return y;
      } else {
        return subtract(y, multiply(x, floor(divide(y, x))));
      }
    }
  };

  Complex.isint = function(x) {
    if (typeof x === 'number') {
      return x === Math.floor(x);
    } else {
      return (x.re === Math.floor(x.re)) && (x.im === Math.floor(x.im));
    }
  };

  firstquadrant = function(x) {
    if (typeof x === 'number') {
      return Math.abs(x);
    } else {
      if (x.re < 0) {
        x = negate(x);
      }
      if (x.im < 0) {
        x = itimes(x);
      }
      if (x.re === 0) {
        x = x.im;
      }
      return x;
    }
  };

  Complex.gcd = gcd = function(x, y) {
    var _ref, _ref1, _ref2;
    if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
      while (y) {
        _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];
      }
      return Math.abs(x);
    } else {
      while (!iszero(y)) {
        _ref2 = [y, residue(y, x)], x = _ref2[0], y = _ref2[1];
      }
      return firstquadrant(x);
    }
  };

  Complex.lcm = function(x, y) {
    var p;
    p = multiply(x, y);
    if (iszero(p)) {
      return p;
    } else {
      return divide(p, gcd(x, y));
    }
  };

  return Complex;

})();
}, "errors": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLError, repeat;



repeat = require('./helpers').repeat;

APLError = function(name, message, opts) {
  var e, k, v, _ref;
  if (message == null) {
    message = '';
  }
  if (!(typeof name === 'string')) {
    throw Error("\"assert typeof name is 'string'\" at src/errors.coffee:5");
  }
  if (!(typeof message === 'string')) {
    throw Error("\"assert typeof message is 'string'\" at src/errors.coffee:6");
  }
  if (opts != null) {
    if (!(typeof opts === 'object')) {
      throw Error("\"assert typeof opts is 'object'\" at src/errors.coffee:8");
    }
    if ((opts.aplCode != null) && (opts.line != null) && (opts.col != null)) {
      if (!(typeof opts.aplCode === 'string')) {
        throw Error("\"assert typeof opts.aplCode is 'string'\" at src/errors.coffee:10");
      }
      if (!(typeof opts.line === 'number')) {
        throw Error("\"assert typeof opts.line is 'number'\" at src/errors.coffee:11");
      }
      if (!(typeof opts.col === 'number')) {
        throw Error("\"assert typeof opts.col is 'number'\" at src/errors.coffee:12");
      }
      if (!((_ref = typeof opts.file) === 'string' || _ref === 'undefined')) {
        throw Error("\"assert typeof opts.file in ['string', 'undefined']\" at src/errors.coffee:13");
      }
      message += "\n" + (opts.file || '-') + ":#" + opts.line + ":" + opts.col + "\n" + (opts.aplCode.split('\n')[opts.line - 1]) + "\n" + (repeat('_', opts.col - 1)) + "^";
    }
  }
  e = Error(message);
  e.name = name;
  for (k in opts) {
    v = opts[k];
    e[k] = v;
  }
  return e;
};

this.SyntaxError = function(message, opts) {
  return APLError('SYNTAX ERROR', message, opts);
};

this.DomainError = function(message, opts) {
  return APLError('DOMAIN ERROR', message, opts);
};

this.LengthError = function(message, opts) {
  return APLError('LENGTH ERROR', message, opts);
};

this.RankError = function(message, opts) {
  return APLError('RANK ERROR', message, opts);
};

this.IndexError = function(message, opts) {
  return APLError('INDEX ERROR', message, opts);
};

this.NonceError = function(message, opts) {
  return APLError('NONCE ERROR', message, opts);
};
}, "helpers": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var repeat;



this.prod = function(xs) {
  var r, x, _i, _len;
  r = 1;
  for (_i = 0, _len = xs.length; _i < _len; _i++) {
    x = xs[_i];
    r *= x;
  }
  return r;
};

this.all = function(xs) {
  var x, _i, _len;
  for (_i = 0, _len = xs.length; _i < _len; _i++) {
    x = xs[_i];
    if (!x) {
      return false;
    }
  }
  return true;
};

this.repeat = repeat = function(a, n) {
  var m, tmp0;
  if (!(typeof a === 'string' || a instanceof Array)) {
    throw Error("\"assert typeof a is 'string' or a instanceof Array\" at src/helpers.coffee:8");
  }
  if (!((tmp0 = (n)) === ~~tmp0 && (0) <= tmp0)) {
    throw Error("\"assert isInt n, 0\" at src/helpers.coffee:9");
  }
  if (!n) {
    return a.slice(0, 0);
  }
  m = n * a.length;
  while (a.length * 2 < m) {
    a = a.concat(a);
  }
  return a.concat(a.slice(0, m - a.length));
};
}, "lexer": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var SyntaxError, tokenDefs;



SyntaxError = require('./errors').SyntaxError;

tokenDefs = [['-', /^(?:[ \t]+|[⍝\#].*)+/], ['newline', /^[\n\r]+/], ['separator', /^[◇⋄]/], ['number', /^¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯)(?:j¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯))?/i], ['string', /^(?:'(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*")+/], ['', /^[\(\)\[\]\{\}:;←]/], ['embedded', /^«[^»]*»/], ['symbol', /^(?:⎕?[a-z_][0-9a-z_]*|[^¯'":«»])/i]];

this.tokenize = function(aplCode, opts) {
  var col, line, stack;
  if (opts == null) {
    opts = {};
  }
  line = col = 1;
  stack = ['{'];
  return {
    next: function() {
      var a, m, re, startCol, startLine, t, type, _i, _len, _ref;
      while (true) {
        if (!aplCode) {
          return {
            type: 'eof',
            value: '',
            startLine: line,
            startCol: col,
            endLine: line,
            endCol: col
          };
        }
        startLine = line;
        startCol = col;
        type = null;
        for (_i = 0, _len = tokenDefs.length; _i < _len; _i++) {
          _ref = tokenDefs[_i], t = _ref[0], re = _ref[1];
          if (!(m = aplCode.match(re))) {
            continue;
          }
          type = t || m[0];
          break;
        }
        if (!type) {
          throw SyntaxError('Unrecognised token', {
            file: opts.file,
            line: line,
            col: col,
            aplCode: opts.aplCode
          });
        }
        a = m[0].split('\n');
        line += a.length - 1;
        col = (a.length === 1 ? col : 1) + a[a.length - 1].length;
        aplCode = aplCode.substring(m[0].length);
        if (type !== '-') {
          if (type === '(' || type === '[' || type === '{') {
            stack.push(type);
          } else if (type === ')' || type === ']' || type === '}') {
            stack.pop();
          }
          if (type !== 'newline' || stack[stack.length - 1] === '{') {
            return {
              type: type,
              startLine: startLine,
              startCol: startCol,
              value: m[0],
              endLine: line,
              endCol: col
            };
          }
        }
      }
    }
  };
};
}, "macros": function(exports, require, module) {// Generated by CoffeeScript 1.6.3

}, "parser": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var SyntaxError, lexer,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };



lexer = require('./lexer');

SyntaxError = require('./errors').SyntaxError;

this.parse = function(aplCode, opts) {
  var consume, demand, parseBody, parseExpr, parseIndexable, parseIndices, parseItem, parserError, result, token, tokenStream;
  if (opts == null) {
    opts = {};
  }
  tokenStream = lexer.tokenize(aplCode);
  token = tokenStream.next();
  consume = function(tt) {
    var _ref;
    if (_ref = token.type, __indexOf.call(tt.split(' '), _ref) >= 0) {
      return token = tokenStream.next();
    }
  };
  demand = function(tt) {
    if (token.type !== tt) {
      parserError("Expected token of type '" + tt + "' but got '" + token.type + "'");
    }
    token = tokenStream.next();
  };
  parserError = function(message) {
    throw SyntaxError(message, {
      file: opts.file,
      line: token.startLine,
      col: token.startCol,
      aplCode: aplCode
    });
  };
  parseBody = function() {
    var body, expr, _ref, _ref1;
    body = ['body'];
    while (true) {
      if ((_ref = token.type) === 'eof' || _ref === '}') {
        return body;
      }
      while (consume('separator newline')) {}
      if ((_ref1 = token.type) === 'eof' || _ref1 === '}') {
        return body;
      }
      expr = parseExpr();
      if (consume(':')) {
        expr = ['guard', expr, parseExpr()];
      }
      body.push(expr);
    }
  };
  parseExpr = function() {
    var expr, item, _ref;
    expr = ['expr'];
    while (true) {
      item = parseItem();
      if (consume('←')) {
        return expr.concat([['assign', item, parseExpr()]]);
      }
      expr.push(item);
      if (_ref = token.type, __indexOf.call(') ] } : ; separator newline eof'.split(' '), _ref) >= 0) {
        return expr;
      }
    }
  };
  parseItem = function() {
    var item;
    item = parseIndexable();
    if (consume('[')) {
      item = ['index', item].concat(parseIndices());
      demand(']');
    }
    return item;
  };
  parseIndices = function() {
    var indices;
    indices = [];
    while (true) {
      if (consume(';')) {
        indices.push(null);
      } else if (token.type === ']') {
        indices.push(null);
        return indices;
      } else {
        indices.push(parseExpr());
        if (token.type === ']') {
          return indices;
        }
        demand(';');
      }
    }
  };
  parseIndexable = function() {
    var b, expr, t;
    t = token;
    if (consume('number string symbol embedded')) {
      return [t.type, t.value];
    } else if (consume('(')) {
      expr = parseExpr();
      demand(')');
      return expr;
    } else if (consume('{')) {
      b = parseBody();
      demand('}');
      return ['lambda', b];
    } else {
      return parserError("Encountered unexpected token of type '" + token.type + "'");
    }
  };
  result = parseBody();
  demand('eof');
  return result;
};
}, "vocabulary": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var alias, k, m, moduleNames, v, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;



moduleNames = 'arithmetic backslash circle comma commute comparisons compose cupcap decode\ndisclose dot drop each enclose encode epsilon exclamation execute find\nfloorceil forkhook format grade identity iota logic poweroperator quad\nquestion rho rotate slash special squish tack take transpose variant vhelpers\nzilde'.split(/\s+/);

for (_i = 0, _len = moduleNames.length; _i < _len; _i++) {
  m = moduleNames[_i];
  _ref = require("./vocabulary/" + m).vocabulary;
  for (k in _ref) {
    v = _ref[k];
    this[k] = v;
    _ref3 = (_ref1 = v != null ? (_ref2 = v.aplMetaInfo) != null ? _ref2.aliases : void 0 : void 0) != null ? _ref1 : [];
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      alias = _ref3[_j];
      this[alias] = v;
    }
  }
}
}, "vocabulary/arithmetic": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Complex, aka, exp, numeric, pervasive, real, simplify, withIdentity, _ref, _ref1;



_ref = require('./vhelpers'), numeric = _ref.numeric, pervasive = _ref.pervasive, real = _ref.real, withIdentity = _ref.withIdentity, aka = _ref.aka;

_ref1 = require('../complex'), Complex = _ref1.Complex, simplify = _ref1.simplify;

APLArray = require('../array').APLArray;

this.vocabulary = {
  '+': withIdentity(0, pervasive({
    monad: numeric((function(x) {
      return x;
    }), Complex.conjugate),
    dyad: numeric((function(y, x) {
      return x + y;
    }), function(y, x) {
      return Complex.add(x, y);
    })
  })),
  '-': aka('−', withIdentity(0, pervasive({
    monad: numeric((function(x) {
      return -x;
    }), Complex.negate),
    dyad: numeric((function(y, x) {
      return x - y;
    }), function(y, x) {
      return Complex.subtract(x, y);
    })
  }))),
  '×': withIdentity(1, pervasive({
    monad: numeric((function(x) {
      return (x > 0) - (x < 0);
    }), function(x) {
      var d;
      d = Math.sqrt(x.re * x.re + x.im * x.im);
      return simplify(x.re / d, x.im / d);
    }),
    dyad: numeric((function(y, x) {
      return x * y;
    }), function(y, x) {
      return Complex.multiply(x, y);
    })
  })),
  '÷': withIdentity(1, pervasive({
    monad: numeric((function(x) {
      return 1 / x;
    }), function(x) {
      var d;
      d = x.re * x.re + x.im * x.im;
      return simplify(x.re / d, -x.im / d);
    }),
    dyad: numeric((function(y, x) {
      return x / y;
    }), function(y, x) {
      return Complex.divide(x, y);
    })
  })),
  '*': aka('⋆', withIdentity(1, pervasive({
    monad: exp = numeric(Math.exp, Complex.exp),
    dyad: function(y, x) {
      return Complex.pow(x, y);
    }
  }))),
  '⍟': pervasive({
    monad: Complex.log,
    dyad: function(y, x) {
      var _ref2;
      if ((typeof x === (_ref2 = typeof y) && _ref2 === 'number') && x > 0 && y > 0) {
        return Math.log(y) / Math.log(x);
      } else {
        return Complex.divide(Complex.log(y), Complex.log(x));
      }
    }
  }),
  '|': aka('∣', withIdentity(0, pervasive({
    monad: numeric((function(x) {
      return Math.abs(x);
    }), Complex.magnitude),
    dyad: function(y, x) {
      return Complex.residue(x, y);
    }
  })))
};
}, "vocabulary/backslash": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, LengthError, NonceError, RankError, adverb, expand, repeat, scan, _ref;



APLArray = require('../array').APLArray;

repeat = require('../helpers').repeat;

_ref = require('../errors'), RankError = _ref.RankError, NonceError = _ref.NonceError, DomainError = _ref.DomainError, LengthError = _ref.LengthError;

adverb = require('./vhelpers').adverb;

this.vocabulary = {
  '\\': adverb(function(omega, alpha, axis) {
    if (typeof omega === 'function') {
      return scan(omega, void 0, axis);
    } else {
      return expand(omega, alpha, axis);
    }
  }),
  '⍀': adverb(function(omega, alpha, axis) {
    if (axis == null) {
      axis = APLArray.zero;
    }
    if (typeof omega === 'function') {
      return scan(omega, void 0, axis);
    } else {
      return expand(omega, alpha, axis);
    }
  })
};

scan = function(f, g, axis) {
  if (!(typeof g === 'undefined')) {
    throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/backslash.coffee:50");
  }
  return function(omega, alpha) {
    if (!(alpha == null)) {
      throw Error("\"assert not alpha?\" at src/vocabulary/backslash.coffee:52");
    }
    if (omega.shape.length === 0) {
      return omega;
    }
    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
    return omega.map(function(x, indices) {
      var a, index, j, p, y, _i, _j, _len, _ref1;
      p = omega.offset;
      for (a = _i = 0, _len = indices.length; _i < _len; a = ++_i) {
        index = indices[a];
        p += index * omega.stride[a];
      }
      if (!(x instanceof APLArray)) {
        x = APLArray.scalar(x);
      }
      for (j = _j = 0, _ref1 = indices[axis]; _j < _ref1; j = _j += 1) {
        p -= omega.stride[axis];
        y = omega.data[p];
        if (!(y instanceof APLArray)) {
          y = APLArray.scalar(y);
        }
        x = f(x, y);
      }
      if (x.shape.length === 0) {
        x = x.unwrap();
      }
      return x;
    });
  };
};

expand = function(omega, alpha, axis) {
  var a, b, data, filler, i, indices, p, shape, tmp0, x, _i, _len, _ref1;
  if (omega.shape.length === 0) {
    throw NonceError('Expand of scalar not implemented');
  }
  axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  a = alpha.toArray();
  shape = omega.shape.slice(0);
  shape[axis] = a.length;
  b = [];
  i = 0;
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    x = a[_i];
    if (!((tmp0 = (x)) === ~~tmp0 && ((0) <= (_ref1 = tmp0) && _ref1 < (2)))) {
      throw DomainError();
    }
    b.push(x > 0 ? i++ : null);
  }
  if (i !== omega.shape[axis]) {
    throw LengthError();
  }
  data = [];
  if (shape[axis] !== 0 && !omega.empty()) {
    filler = omega.getPrototype();
    p = omega.offset;
    indices = repeat([0], shape.length);
    while (true) {
      x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
      data.push(x);
      i = shape.length - 1;
      while (i >= 0 && indices[i] + 1 === shape[i]) {
        if (i !== axis) {
          p -= omega.stride[i] * indices[i];
        }
        indices[i--] = 0;
      }
      if (i < 0) {
        break;
      }
      if (i !== axis) {
        p += omega.stride[i];
      }
      indices[i]++;
    }
  }
  return new APLArray(data, shape);
};
}, "vocabulary/circle": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var Complex, DomainError, numeric, pervasive, simplify, _ref, _ref1;



_ref = require('./vhelpers'), numeric = _ref.numeric, pervasive = _ref.pervasive;

DomainError = require('../errors').DomainError;

_ref1 = require('../complex'), Complex = _ref1.Complex, simplify = _ref1.simplify;

this.vocabulary = {
  '○': pervasive({
    monad: numeric((function(x) {
      return Math.PI * x;
    }), function(x) {
      return new Complex(Math.PI * x.re, Math.PI * x.im);
    }),
    dyad: function(x, i) {
      var a, b, t;
      if (typeof x === 'number') {
        switch (i) {
          case -12:
            return Complex.exp(simplify(0, x));
          case -11:
            return simplify(0, x);
          case -10:
            return x;
          case -9:
            return x;
          case -8:
            return simplify(0, -Math.sqrt(1 + x * x));
          case -7:
            return Complex.atanh(x);
          case -6:
            return Complex.acosh(x);
          case -5:
            return Complex.asinh(x);
          case -4:
            t = Complex.sqrt(x * x - 1);
            if (x < -1) {
              return -t;
            } else {
              return t;
            }
            break;
          case -3:
            return Complex.atan(x);
          case -2:
            return Complex.acos(x);
          case -1:
            return Complex.asin(x);
          case 0:
            return Complex.sqrt(1 - x * x);
          case 1:
            return Math.sin(x);
          case 2:
            return Math.cos(x);
          case 3:
            return Math.tan(x);
          case 4:
            return Math.sqrt(1 + x * x);
          case 5:
            a = Math.exp(x);
            b = 1 / a;
            return 0.5 * (a - b);
          case 6:
            a = Math.exp(x);
            b = 1 / a;
            return 0.5 * (a + b);
          case 7:
            a = Math.exp(x);
            b = 1 / a;
            return (a - b) / (a + b);
          case 8:
            return Complex.sqrt(-1 - x * x);
          case 9:
            return x;
          case 10:
            return Math.abs(x);
          case 11:
            return 0;
          case 12:
            return 0;
          default:
            throw DomainError('Unknown circular or hyperbolic function ' + i);
        }
      } else if (x instanceof Complex) {
        switch (i) {
          case -12:
            return Complex.exp(simplify(-x.im, x.re));
          case -11:
            return Complex.itimes(x);
          case -10:
            return Complex.conjugate(x);
          case -9:
            return x;
          case -8:
            t = Complex.subtract(-1, Complex.multiply(x, x));
            return Complex.negate(Complex.sqrt(t));
          case -7:
            return Complex.atanh(x);
          case -6:
            return Complex.acosh(x);
          case -5:
            return Complex.asinh(x);
          case -4:
            if (x.re === -1 && x.im === 0) {
              return 0;
            } else {
              a = Complex.add(x, 1);
              b = Complex.subtract(x, 1);
              return Complex.multiply(a, Complex.sqrt(Complex.divide(b, a)));
            }
            break;
          case -3:
            return Complex.atan(x);
          case -2:
            return Complex.acos(x);
          case -1:
            return Complex.asin(x);
          case 0:
            return Complex.sqrt(Complex.subtract(1, Complex.multiply(x, x)));
          case 1:
            return Complex.sin(x);
          case 2:
            return Complex.cos(x);
          case 3:
            return Complex.tan(x);
          case 4:
            return Complex.sqrt(Complex.add(1, Complex.multiply(x, x)));
          case 5:
            return Complex.sinh(x);
          case 6:
            return Complex.cosh(x);
          case 7:
            return Complex.tanh(x);
          case 8:
            return Complex.sqrt(Complex.subtract(-1, Complex.multiply(x, x)));
          case 9:
            return x.re;
          case 10:
            return Complex.magnitude(x);
          case 11:
            return x.im;
          case 12:
            return Complex.direction(x);
          default:
            throw DomainError('Unknown circular or hyperbolic function ' + i);
        }
      } else {
        throw DomainError();
      }
    }
  })
};
}, "vocabulary/comma": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, LengthError, RankError, catenate, prod, repeat, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), DomainError = _ref.DomainError, RankError = _ref.RankError, LengthError = _ref.LengthError;

_ref1 = require('../helpers'), prod = _ref1.prod, repeat = _ref1.repeat;

this.vocabulary = {
  ',': function(omega, alpha, axis) {
    var data;
    if (alpha) {
      return catenate(omega, alpha, axis);
    } else {
      data = [];
      omega.each(function(x) {
        return data.push(x);
      });
      return new APLArray(data);
    }
  },
  '⍪': function(omega, alpha, axis) {
    var data;
    if (axis == null) {
      axis = APLArray.zero;
    }
    if (alpha) {
      return catenate(omega, alpha, axis);
    } else {
      data = [];
      omega.each(function(x) {
        return data.push(x);
      });
      return new APLArray(data, [data.length, 1]);
    }
  }
};

catenate = function(omega, alpha, axis) {
  var a, data, i, nAxes, p, pIndices, q, r, rStride, s, shape, stride, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, _i, _j, _ref2, _ref3;
  if (!(alpha)) {
    throw Error("\"assert alpha\" at src/vocabulary/comma.coffee:65");
  }
  if (!(typeof axis === 'undefined' || axis instanceof APLArray)) {
    throw Error("\"assert typeof axis is 'undefined' or axis instanceof APLArray\" at src/vocabulary/comma.coffee:66");
  }
  nAxes = Math.max(alpha.shape.length, omega.shape.length);
  if (axis) {
    axis = axis.unwrap();
    if (typeof axis !== 'number') {
      throw DomainError();
    }
    if (!((-1 < axis && axis < nAxes))) {
      throw RankError();
    }
  } else {
    axis = nAxes - 1;
  }
  if (alpha.shape.length === 0 && omega.shape.length === 0) {
    return new APLArray([alpha.unwrap(), omega.unwrap()]);
  } else if (alpha.shape.length === 0) {
    s = omega.shape.slice(0);
    if ((tmp0 = (axis)) === ~~tmp0) {
      s[axis] = 1;
    }
    alpha = new APLArray([alpha.unwrap()], s, repeat([0], omega.shape.length));
  } else if (omega.shape.length === 0) {
    s = alpha.shape.slice(0);
    if ((tmp1 = (axis)) === ~~tmp1) {
      s[axis] = 1;
    }
    omega = new APLArray([omega.unwrap()], s, repeat([0], alpha.shape.length));
  } else if (alpha.shape.length + 1 === omega.shape.length) {
    if (!((tmp2 = (axis)) === ~~tmp2)) {
      throw RankError();
    }
    shape = alpha.shape.slice(0);
    shape.splice(axis, 0, 1);
    stride = alpha.stride.slice(0);
    stride.splice(axis, 0, 0);
    alpha = new APLArray(alpha.data, shape, stride, alpha.offset);
  } else if (alpha.shape.length === omega.shape.length + 1) {
    if (!((tmp3 = (axis)) === ~~tmp3)) {
      throw RankError();
    }
    shape = omega.shape.slice(0);
    shape.splice(axis, 0, 1);
    stride = omega.stride.slice(0);
    stride.splice(axis, 0, 0);
    omega = new APLArray(omega.data, shape, stride, omega.offset);
  } else if (alpha.shape.length !== omega.shape.length) {
    throw RankError();
  }
  if (!(alpha.shape.length === omega.shape.length)) {
    throw Error("\"assert alpha.shape.length is omega.shape.length\" at src/vocabulary/comma.coffee:103");
  }
  for (i = _i = 0, _ref2 = alpha.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
    if (i !== axis && alpha.shape[i] !== omega.shape[i]) {
      throw LengthError();
    }
  }
  shape = alpha.shape.slice(0);
  if ((tmp4 = (axis)) === ~~tmp4) {
    shape[axis] += omega.shape[axis];
  } else {
    shape.splice(Math.ceil(axis), 0, 2);
  }
  data = Array(prod(shape));
  stride = Array(shape.length);
  stride[shape.length - 1] = 1;
  for (i = _j = _ref3 = shape.length - 2; _j >= 0; i = _j += -1) {
    stride[i] = stride[i + 1] * shape[i + 1];
  }
  if ((tmp5 = (axis)) === ~~tmp5) {
    rStride = stride;
  } else {
    rStride = stride.slice(0);
    rStride.splice(Math.ceil(axis), 1);
  }
  if (!alpha.empty()) {
    r = 0;
    p = alpha.offset;
    pIndices = repeat([0], alpha.shape.length);
    while (true) {
      data[r] = alpha.data[p];
      a = pIndices.length - 1;
      while (a >= 0 && pIndices[a] + 1 === alpha.shape[a]) {
        p -= pIndices[a] * alpha.stride[a];
        r -= pIndices[a] * rStride[a];
        pIndices[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += alpha.stride[a];
      r += rStride[a];
      pIndices[a]++;
    }
  }
  if (!omega.empty()) {
    r = (tmp6 = (axis)) === ~~tmp6 ? stride[axis] * alpha.shape[axis] : stride[Math.ceil(axis)];
    q = omega.offset;
    pIndices = repeat([0], omega.shape.length);
    while (true) {
      data[r] = omega.data[q];
      a = pIndices.length - 1;
      while (a >= 0 && pIndices[a] + 1 === omega.shape[a]) {
        q -= pIndices[a] * omega.stride[a];
        r -= pIndices[a] * rStride[a];
        pIndices[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      q += omega.stride[a];
      r += rStride[a];
      pIndices[a]++;
    }
  }
  return new APLArray(data, shape, stride);
};
}, "vocabulary/commute": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var adverb;



adverb = require('./vhelpers').adverb;

this.vocabulary = {
  '⍨': adverb(function(f, g) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/commute.coffee:17");
    }
    if (!(g == null)) {
      throw Error("\"assert not g?\" at src/vocabulary/commute.coffee:18");
    }
    return function(omega, alpha, axis) {
      if (alpha) {
        return f(alpha, omega, axis);
      } else {
        return f(omega, omega, axis);
      }
    };
  })
};
}, "vocabulary/comparisons": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Complex, depthOf, eq, match, pervasive, real, withIdentity, _ref;



APLArray = require('../array').APLArray;

_ref = require('./vhelpers'), pervasive = _ref.pervasive, real = _ref.real, match = _ref.match, withIdentity = _ref.withIdentity;

Complex = require('../complex').Complex;

this.vocabulary = {
  '=': withIdentity(1, pervasive({
    dyad: eq = function(y, x) {
      if (x instanceof Complex && y instanceof Complex) {
        return +(x.re === y.re && x.im === y.im);
      } else {
        return +(x === y);
      }
    }
  })),
  '≠': withIdentity(0, pervasive({
    dyad: function(y, x) {
      return 1 - eq(y, x);
    }
  })),
  '<': withIdentity(0, pervasive({
    dyad: real(function(y, x) {
      return +(x < y);
    })
  })),
  '>': withIdentity(0, pervasive({
    dyad: real(function(y, x) {
      return +(x > y);
    })
  })),
  '≤': withIdentity(1, pervasive({
    dyad: real(function(y, x) {
      return +(x <= y);
    })
  })),
  '≥': withIdentity(1, pervasive({
    dyad: real(function(y, x) {
      return +(x >= y);
    })
  })),
  '≡': function(omega, alpha) {
    if (alpha) {
      return APLArray.bool[+match(omega, alpha)];
    } else {
      return new APLArray([depthOf(omega)], []);
    }
  },
  '≢': function(omega, alpha) {
    if (alpha) {
      return APLArray.bool[+(!match(omega, alpha))];
    } else {
      if (omega.shape.length) {
        return new APLArray([omega.shape[0]], []);
      } else {
        return APLArray.one;
      }
    }
  }
};

depthOf = function(x) {
  var r;
  if (x instanceof APLArray) {
    if (x.shape.length === 0 && !(x.data[0] instanceof APLArray)) {
      return 0;
    }
    r = 0;
    x.each(function(y) {
      return r = Math.max(r, depthOf(y));
    });
    return r + 1;
  } else {
    return 0;
  }
};
}, "vocabulary/compose": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var conjunction;



conjunction = require('./vhelpers').conjunction;

this.vocabulary = {
  '∘': conjunction(function(g, f) {
    if (typeof f === 'function') {
      if (typeof g === 'function') {
        return function(omega, alpha) {
          return f(g(omega), alpha);
        };
      } else {
        return function(omega, alpha) {
          if (!(alpha == null)) {
            throw Error("\"assert not alpha?\" at src/vocabulary/compose.coffee:23");
          }
          return f(g, omega);
        };
      }
    } else {
      if (!(typeof g === 'function')) {
        throw Error("\"assert typeof g is 'function'\" at src/vocabulary/compose.coffee:26");
      }
      return function(omega, alpha) {
        if (!(alpha == null)) {
          throw Error("\"assert not alpha?\" at src/vocabulary/compose.coffee:28");
        }
        return g(omega, f);
      };
    }
  })
};
}, "vocabulary/cupcap": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, RankError, contains, match;



APLArray = require('../array').APLArray;

match = require('./vhelpers').match;

RankError = require('../errors').RankError;

this.vocabulary = {
  '∪': function(omega, alpha) {
    var a, data, _i, _len, _ref;
    if (alpha) {
      data = [];
      _ref = [alpha, omega];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        if (a.shape.length > 1) {
          throw RankError();
        }
        a.each(function(x) {
          if (!contains(data, x)) {
            return data.push(x);
          }
        });
      }
      return new APLArray(data);
    } else {
      data = [];
      omega.each(function(x) {
        if (!contains(data, x)) {
          return data.push(x);
        }
      });
      return new APLArray(data);
    }
  },
  '∩': function(omega, alpha) {
    var b, data, x, _i, _len, _ref;
    if (alpha) {
      data = [];
      b = omega.toArray();
      _ref = alpha.toArray();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        if (contains(b, x)) {
          data.push(x);
        }
      }
      return new APLArray(data);
    } else {
      throw Error('Not implemented');
    }
  }
};

contains = function(a, x) {
  var y, _i, _len;
  if (!(a instanceof Array)) {
    throw Error("\"assert a instanceof Array\" at src/vocabulary/cupcap.coffee:62");
  }
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    y = a[_i];
    if (match(x, y)) {
      return true;
    }
  }
  return false;
};
}, "vocabulary/decode": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray;



APLArray = require('../array').APLArray;

this.vocabulary = {
  '⊥': function(omega, alpha) {
    var a, b, data, firstDimB, i, j, k, lastDimA, x, y, z, _i, _j, _k, _ref, _ref1, _ref2;
    if (!(alpha)) {
      throw Error("\"assert alpha\" at src/vocabulary/decode.coffee:56");
    }
    if (alpha.shape.length === 0) {
      alpha = new APLArray([alpha.unwrap()]);
    }
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    lastDimA = alpha.shape[alpha.shape.length - 1];
    firstDimB = omega.shape[0];
    if (lastDimA !== 1 && firstDimB !== 1 && lastDimA !== firstDimB) {
      throw LengthError();
    }
    a = alpha.toArray();
    b = omega.toArray();
    data = [];
    for (i = _i = 0, _ref = a.length / lastDimA; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = b.length / firstDimB; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        x = a.slice(i * lastDimA, (i + 1) * lastDimA);
        y = (function() {
          var _k, _results;
          _results = [];
          for (k = _k = 0; 0 <= firstDimB ? _k < firstDimB : _k > firstDimB; k = 0 <= firstDimB ? ++_k : --_k) {
            _results.push(b[j + k * (b.length / firstDimB)]);
          }
          return _results;
        })();
        if (x.length === 1) {
          x = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (_k = 0, _ref2 = y.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
              _results.push(x[0]);
            }
            return _results;
          })();
        }
        if (y.length === 1) {
          y = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (_k = 0, _ref2 = x.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
              _results.push(y[0]);
            }
            return _results;
          })();
        }
        z = y[0];
        for (k = _k = 1, _ref2 = y.length; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 1 <= _ref2 ? ++_k : --_k) {
          z = z * x[k] + y[k];
        }
        data.push(z);
      }
    }
    return new APLArray(data, alpha.shape.slice(0, -1).concat(omega.shape.slice(1)));
  }
};
}, "vocabulary/disclose": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, IndexError, RankError, _ref;



APLArray = require('../array').APLArray;

_ref = require('../errors'), RankError = _ref.RankError, IndexError = _ref.IndexError;

this.vocabulary = {
  '⊃': function(omega, alpha) {
    var i, path, pick, x, _i, _j, _len, _ref1;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      x = omega;
      path = alpha.toArray();
      for (_i = 0, _len = path.length; _i < _len; _i++) {
        pick = path[_i];
        if (pick instanceof APLArray) {
          if (pick.shape.length > 1) {
            throw RankError();
          }
          pick = pick.toArray();
        } else {
          pick = [pick];
        }
        if (pick.length !== x.shape.length) {
          throw RankError();
        }
        for (i = _j = 0, _ref1 = pick.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          if (pick[i] >= x.shape[i]) {
            throw IndexError();
          }
        }
        x = x.get(pick);
        if (!(x instanceof APLArray)) {
          x = APLArray.scalar(x);
        }
      }
      return x;
    } else {
      if (omega.empty()) {
        return APLArray.zero;
      }
      x = omega.get([]);
      if (x instanceof APLArray) {
        return x;
      } else {
        return APLArray.scalar(x);
      }
    }
  }
};
}, "vocabulary/dot": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, conjunction, each, enclose, innerProduct, jot, outerProduct, reduce;



APLArray = require('../array').APLArray;

reduce = require('./slash').vocabulary['/'];

enclose = require('./enclose').vocabulary['⊂'];

jot = require('./compose').vocabulary['∘'];

each = require('./each').vocabulary['¨'];

conjunction = require('./vhelpers').conjunction;

this.vocabulary = {
  '.': conjunction(function(g, f) {
    if (f === jot) {
      return outerProduct(g);
    } else {
      return innerProduct(g, f);
    }
  })
};

outerProduct = function(f) {
  if (!(typeof f === 'function')) {
    throw Error("\"assert typeof f is 'function'\" at src/vocabulary/dot.coffee:47");
  }
  return function(omega, alpha) {
    var a, b, data, x, y, z, _i, _j, _len, _len1;
    if (!alpha) {
      throw Error('Adverb ∘. (Outer product) can be applied to dyadic verbs only');
    }
    a = alpha.toArray();
    b = omega.toArray();
    data = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
        y = b[_j];
        if (!(x instanceof APLArray)) {
          x = APLArray.scalar(x);
        }
        if (!(y instanceof APLArray)) {
          y = APLArray.scalar(y);
        }
        z = f(y, x);
        if (z.shape.length === 0) {
          z = z.unwrap();
        }
        data.push(z);
      }
    }
    return new APLArray(data, alpha.shape.concat(omega.shape));
  };
};

innerProduct = function(g, f) {
  var F, G;
  F = each(reduce(f));
  G = outerProduct(g);
  return function(omega, alpha) {
    if (alpha.shape.length === 0) {
      alpha = new APLArray([alpha.unwrap()]);
    }
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    return F(G(enclose(omega, void 0, new APLArray([0])), enclose(alpha, void 0, new APLArray([alpha.shape.length - 1]))));
  };
};
}, "vocabulary/drop": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, RankError, prod, repeat, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../helpers'), repeat = _ref.repeat, prod = _ref.prod;

_ref1 = require('../errors'), DomainError = _ref1.DomainError, RankError = _ref1.RankError;

this.vocabulary = {
  '↓': function(omega, alpha, axis) {
    var a, array, data, i, ishape, obound, offset, oshape, shape, tmp0, x, _i, _j, _k, _len, _len1;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      a = alpha.toArray();
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        if (!((tmp0 = (x)) === ~~tmp0)) {
          throw DomainError();
        }
      }
      if (omega.shape.length === 0) {
        omega = new APLArray(omega.data, repeat([1], a.length), omega.stride, omega.offset);
      } else {
        if (a.length > omega.shape.length) {
          throw RankError();
        }
      }
      shape = omega.shape.slice(0);
      offset = omega.offset;
      for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
        x = a[i];
        shape[i] = Math.max(0, omega.shape[i] - Math.abs(x));
        if (x > 0) {
          offset += x * omega.stride[i];
        }
      }
      if (prod(shape) === 0) {
        return new APLArray([], shape);
      } else {
        return new APLArray(omega.data, shape, omega.stride, offset);
      }
    } else {
      if (omega.shape.length === 0) {
        throw NonceError('Split of scalar not implemented');
      }
      oshape = omega.shape.slice(0, omega.shape.length - 1);
      obound = oshape.reduce((function(a, b) {
        return a * b;
      }), 1);
      ishape = omega.shape[omega.shape.length - 1];
      array = omega.toArray();
      data = [];
      for (i = _k = 0; 0 <= obound ? _k < obound : _k > obound; i = 0 <= obound ? ++_k : --_k) {
        offset = i * ishape;
        data.push(new APLArray(array.slice(offset, offset + ishape)));
      }
      return new APLArray(data, oshape);
    }
  }
};
}, "vocabulary/each": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, LengthError, adverb, arrayEquals;



APLArray = require('../array').APLArray;

LengthError = require('../errors').LengthError;

adverb = require('./vhelpers').adverb;

this.vocabulary = {
  '¨': adverb(function(f, g) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/each.coffee:23");
    }
    if (!(typeof g === 'undefined')) {
      throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/each.coffee:24");
    }
    return function(omega, alpha) {
      var x, y;
      if (!alpha) {
        return omega.map(function(x) {
          var r;
          if (!(x instanceof APLArray)) {
            x = new APLArray([x], []);
          }
          r = f(x);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:30");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else if (arrayEquals(alpha.shape, omega.shape)) {
        return omega.map2(alpha, function(x, y) {
          var r;
          if (!(x instanceof APLArray)) {
            x = new APLArray([x], []);
          }
          if (!(y instanceof APLArray)) {
            y = new APLArray([y], []);
          }
          r = f(x, y);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:37");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else if (alpha.isSingleton()) {
        y = alpha.data[0] instanceof APLArray ? alpha.unwrap() : alpha;
        return omega.map(function(x) {
          var r;
          if (!(x instanceof APLArray)) {
            x = new APLArray([x], []);
          }
          r = f(x, y);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:44");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else if (omega.isSingleton()) {
        x = omega.data[0] instanceof APLArray ? omega.unwrap() : omega;
        return alpha.map(function(y) {
          var r;
          if (!(y instanceof APLArray)) {
            y = new APLArray([y], []);
          }
          r = f(x, y);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:51");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else {
        throw LengthError();
      }
    };
  })
};

arrayEquals = function(a, b) {
  var i, x, _i, _len;
  if (!(a instanceof Array)) {
    throw Error("\"assert a instanceof Array\" at src/vocabulary/each.coffee:57");
  }
  if (!(b instanceof Array)) {
    throw Error("\"assert b instanceof Array\" at src/vocabulary/each.coffee:58");
  }
  if (a.length !== b.length) {
    return false;
  }
  for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
    x = a[i];
    if (x !== b[i]) {
      return false;
    }
  }
  return true;
};
}, "vocabulary/enclose": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, getAxisList, repeat,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };



APLArray = require('../array').APLArray;

repeat = require('../helpers').repeat;

getAxisList = require('./vhelpers').getAxisList;

this.vocabulary = {
  '⊂': function(omega, alpha, axes) {
    var a, axis, data, indices, p, resultAxes, shape, stride, unitShape, unitStride, _i, _ref, _results;
    if (alpha) {
      throw Error('Not implemented');
    } else {
      axes = axes != null ? getAxisList(axes, omega.shape.length) : (function() {
        _results = [];
        for (var _i = 0, _ref = omega.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      if (omega.isSimple()) {
        return omega;
      }
      unitShape = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = axes.length; _j < _len; _j++) {
          axis = axes[_j];
          _results1.push(omega.shape[axis]);
        }
        return _results1;
      })();
      unitStride = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = axes.length; _j < _len; _j++) {
          axis = axes[_j];
          _results1.push(omega.stride[axis]);
        }
        return _results1;
      })();
      resultAxes = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (axis = _j = 0, _ref1 = omega.shape.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; axis = 0 <= _ref1 ? ++_j : --_j) {
          if (__indexOf.call(axes, axis) < 0) {
            _results1.push(axis);
          }
        }
        return _results1;
      })();
      shape = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
          axis = resultAxes[_j];
          _results1.push(omega.shape[axis]);
        }
        return _results1;
      })();
      stride = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
          axis = resultAxes[_j];
          _results1.push(omega.stride[axis]);
        }
        return _results1;
      })();
      data = [];
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        data.push(new APLArray(omega.data, unitShape, unitStride, p));
        a = indices.length - 1;
        while (a >= 0 && indices[a] + 1 === shape[a]) {
          p -= indices[a] * stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += stride[a];
        indices[a]++;
      }
      return new APLArray(data, shape);
    }
  }
};
}, "vocabulary/encode": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, prod;



APLArray = require('../array').APLArray;

prod = require('../helpers').prod;

this.vocabulary = {
  '⊤': function(omega, alpha) {
    var a, b, data, i, isNeg, j, k, m, n, shape, x, y, _i, _j, _k, _len, _ref;
    if (!(alpha)) {
      throw Error("\"assert alpha\" at src/vocabulary/encode.coffee:44");
    }
    a = alpha.toArray();
    b = omega.toArray();
    shape = alpha.shape.concat(omega.shape);
    data = Array(prod(shape));
    n = alpha.shape.length ? alpha.shape[0] : 1;
    m = a.length / n;
    for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
      for (j = _j = 0, _len = b.length; _j < _len; j = ++_j) {
        y = b[j];
        if (isNeg = y < 0) {
          y = -y;
        }
        for (k = _k = _ref = n - 1; _k >= 0; k = _k += -1) {
          x = a[k * m + i];
          if (x === 0) {
            data[(k * m + i) * b.length + j] = y;
            y = 0;
          } else {
            data[(k * m + i) * b.length + j] = y % x;
            y = Math.round((y - (y % x)) / x);
          }
        }
      }
    }
    return new APLArray(data, shape);
  }
};
}, "vocabulary/epsilon": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, aka, enlist, match, _ref;



APLArray = require('../array').APLArray;

_ref = require('./vhelpers'), match = _ref.match, aka = _ref.aka;

this.vocabulary = {
  '∊': aka('∈', function(omega, alpha) {
    var a, data;
    if (alpha) {
      a = omega.toArray();
      return alpha.map(function(x) {
        var y, _i, _len;
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          y = a[_i];
          if (match(x, y)) {
            return 1;
          }
        }
        return 0;
      });
    } else {
      data = [];
      enlist(omega, data);
      return new APLArray(data);
    }
  })
};

enlist = function(x, r) {
  if (x instanceof APLArray) {
    return x.each(function(y) {
      return enlist(y, r);
    });
  } else {
    return r.push(x);
  }
};
}, "vocabulary/exclamation": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Beta, DomainError, lnΓ, negInt, pervasive, prod, real, smallFactorials, withIdentity, Γ, _ref;



_ref = require('./vhelpers'), pervasive = _ref.pervasive, real = _ref.real, withIdentity = _ref.withIdentity;

prod = require('../helpers').prod;

APLArray = require('../array').APLArray;

DomainError = require('../errors').DomainError;

Γ = require('gamma');

lnΓ = Γ.log;

this.vocabulary = {
  '!': withIdentity(1, pervasive({
    monad: real(function(x) {
      var tmp0;
      if (!((tmp0 = (x)) === ~~tmp0)) {
        return Γ(x + 1);
      } else if (x < 0) {
        throw DomainError();
      } else if (x < smallFactorials.length) {
        return smallFactorials[x];
      } else {
        return Math.round(Γ(x + 1));
      }
    }),
    dyad: Beta = real(function(n, k) {
      var r, tmp1, tmp2;
      r = (function() {
        switch (4 * negInt(k) + 2 * negInt(n) + negInt(n - k)) {
          case 0x0:
            return Math.exp(lnΓ(n + 1) - lnΓ(k + 1) - lnΓ(n - k + 1));
          case 0x1:
            return 0;
          case 0x2:
            throw DomainError();
            break;
          case 0x3:
            return Math.pow(-1, k) * Beta(k - n - 1, k);
          case 0x4:
            return 0;
          case 0x5:
            break;
          case 0x6:
            return Math.pow(-1, n - k) * Beta(Math.abs(k + 1), Math.abs(n + 1));
          case 0x7:
            return 0;
        }
      })();
      if (((tmp1 = (n)) === ~~tmp1) && ((tmp2 = (k)) === ~~tmp2)) {
        return Math.round(r);
      } else {
        return r;
      }
    })
  }))
};

negInt = function(x) {
  var tmp3;
  return ((tmp3 = (x)) === ~~tmp3) && x < 0;
};

smallFactorials = (function() {
  var i, x;
  return [x = 1].concat((function() {
    var _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 25; i = ++_i) {
      _results.push(x *= i);
    }
    return _results;
  })());
})();
}, "vocabulary/execute": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var DomainError;



DomainError = require('../errors').DomainError;

this.vocabulary = {
  '⍎': function(omega, alpha) {
    var s;
    if (alpha) {
      throw Error('Not implemented');
    } else {
      s = '';
      omega.each(function(c) {
        if (typeof c !== 'string') {
          throw DomainError();
        }
        return s += c;
      });
      return require('../compiler').exec(s);
    }
  }
};
}, "vocabulary/find": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, match, prod, repeat, strideForShape, _ref, _ref1;



_ref = require('../array'), APLArray = _ref.APLArray, strideForShape = _ref.strideForShape;

_ref1 = require('../helpers'), prod = _ref1.prod, repeat = _ref1.repeat;

match = require('./vhelpers').match;

this.vocabulary = {
  '⍷': function(omega, alpha) {
    var a, d, data, findShape, i, indices, p, q, stride, _i, _ref2;
    if (alpha) {
      if (alpha.shape.length > omega.shape.length) {
        return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
      }
      if (alpha.shape.length < omega.shape.length) {
        alpha = new APLArray(alpha.data, repeat([1], omega.shape.length - alpha.shape.length).concat(alpha.shape), repeat([0], omega.shape.length - alpha.shape.length).concat(alpha.stride), alpha.offset);
      }
      if (prod(alpha.shape) === 0) {
        return new APLArray([1], omega.shape, repeat([0], omega.shape.length));
      }
      findShape = [];
      for (i = _i = 0, _ref2 = omega.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        d = omega.shape[i] - alpha.shape[i] + 1;
        if (d <= 0) {
          return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
        }
        findShape.push(d);
      }
      stride = strideForShape(omega.shape);
      data = repeat([0], prod(omega.shape));
      p = omega.offset;
      q = 0;
      indices = repeat([0], findShape.length);
      while (true) {
        data[q] = +match(alpha, new APLArray(omega.data, alpha.shape, omega.stride, p));
        a = findShape.length - 1;
        while (a >= 0 && indices[a] + 1 === findShape[a]) {
          p -= indices[a] * omega.stride[a];
          q -= indices[a] * stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += omega.stride[a];
        q += stride[a];
        indices[a]++;
      }
      return new APLArray(data, omega.shape);
    } else {
      throw Error('Not implemented');
    }
  }
};
}, "vocabulary/floorceil": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Complex, numeric, pervasive, real, withIdentity, _ref;



_ref = require('./vhelpers'), numeric = _ref.numeric, pervasive = _ref.pervasive, real = _ref.real, withIdentity = _ref.withIdentity;

APLArray = require('../array').APLArray;

Complex = require('../complex').Complex;

this.vocabulary = {
  '⌊': withIdentity(Infinity, pervasive({
    monad: Complex.floor,
    dyad: real(function(y, x) {
      return Math.min(y, x);
    })
  })),
  '⌈': withIdentity(-Infinity, pervasive({
    monad: Complex.ceil,
    dyad: real(function(y, x) {
      return Math.max(y, x);
    })
  }))
};
}, "vocabulary/forkhook": function(exports, require, module) {// Generated by CoffeeScript 1.6.3


this.vocabulary = {
  _hook: function(g, f) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/forkhook.coffee:23");
    }
    if (!(typeof g === 'function')) {
      throw Error("\"assert typeof g is 'function'\" at src/vocabulary/forkhook.coffee:24");
    }
    return function(b, a) {
      return f(g(b), a != null ? a : b);
    };
  },
  _fork: function(verbs) {
    var f, _i, _len;
    if (!(verbs.length % 2 === 1)) {
      throw Error("\"assert verbs.length % 2 is 1\" at src/vocabulary/forkhook.coffee:42");
    }
    if (!(verbs.length >= 3)) {
      throw Error("\"assert verbs.length >= 3\" at src/vocabulary/forkhook.coffee:43");
    }
    for (_i = 0, _len = verbs.length; _i < _len; _i++) {
      f = verbs[_i];
      if (!(typeof f === 'function')) {
        throw Error("\"for f in verbs then assert typeof f is 'function'\" at src/vocabulary/forkhook.coffee:44");
      }
    }
    return function(b, a) {
      var i, r, _j, _ref;
      r = verbs[verbs.length - 1](b, a);
      for (i = _j = _ref = verbs.length - 2; _j > 0; i = _j += -2) {
        r = verbs[i](r, verbs[i - 1](b, a));
      }
      return r;
    };
  }
};
}, "vocabulary/format": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, format, prod, repeat, _ref;



APLArray = require('../array').APLArray;

_ref = require('../helpers'), prod = _ref.prod, repeat = _ref.repeat;

this.vocabulary = {
  '⍕': function(omega, alpha) {
    var t;
    if (alpha) {
      throw Error('Not implemented');
    } else {
      t = format(omega);
      return new APLArray(t.join(''), [t.length, t[0].length]);
    }
  }
};

this.format = format = function(a) {
  var bottom, box, c, cols, d, grid, i, j, k, left, nCols, nRows, r, result, right, rows, sa, step, t, x, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
  if (typeof a === 'undefined') {
    return ['undefined'];
  } else if (a === null) {
    return ['null'];
  } else if (typeof a === 'string') {
    return [a];
  } else if (typeof a === 'number') {
    return [('' + a).replace(/-|Infinity/g, '¯')];
  } else if (typeof a === 'function') {
    return ['function'];
  } else if (!(a instanceof APLArray)) {
    return ['' + a];
  } else if (a.length === 0) {
    return [''];
  } else {
    sa = a.shape;
    a = a.toArray();
    if (!sa.length) {
      return format(a[0]);
    }
    nRows = prod(sa.slice(0, sa.length - 1));
    nCols = sa[sa.length - 1];
    rows = (function() {
      var _i, _results;
      _results = [];
      for (_i = 0; 0 <= nRows ? _i < nRows : _i > nRows; 0 <= nRows ? _i++ : _i--) {
        _results.push({
          height: 0,
          bottomMargin: 0
        });
      }
      return _results;
    })();
    cols = (function() {
      var _i, _results;
      _results = [];
      for (_i = 0; 0 <= nCols ? _i < nCols : _i > nCols; 0 <= nCols ? _i++ : _i--) {
        _results.push({
          type: 0,
          width: 0,
          leftMargin: 0,
          rightMargin: 0
        });
      }
      return _results;
    })();
    grid = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = rows.length; _i < _len; i = ++_i) {
        r = rows[i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (j = _j = 0, _len1 = cols.length; _j < _len1; j = ++_j) {
            c = cols[j];
            x = a[nCols * i + j];
            box = format(x);
            r.height = Math.max(r.height, box.length);
            c.width = Math.max(c.width, box[0].length);
            c.type = Math.max(c.type, typeof x === 'string' && x.length === 1 ? 0 : !(x instanceof APLArray) ? 1 : 2);
            _results1.push(box);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    step = 1;
    for (d = _i = _ref1 = sa.length - 2; _i >= 1; d = _i += -1) {
      step *= sa[d];
      for (i = _j = _ref2 = step - 1, _ref3 = nRows - 1; step > 0 ? _j < _ref3 : _j > _ref3; i = _j += step) {
        rows[i].bottomMargin++;
      }
    }
    for (j = _k = 0, _len = cols.length; _k < _len; j = ++_k) {
      c = cols[j];
      if (j !== nCols - 1 && !((c.type === (_ref4 = cols[j + 1].type) && _ref4 === 0))) {
        c.rightMargin++;
      }
      if (c.type === 2) {
        c.leftMargin++;
        c.rightMargin++;
      }
    }
    result = [];
    for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {
      r = rows[i];
      for (j = _m = 0, _len2 = cols.length; _m < _len2; j = ++_m) {
        c = cols[j];
        t = grid[i][j];
        if (c.type === 1) {
          left = repeat(' ', c.leftMargin + c.width - t[0].length);
          right = repeat(' ', c.rightMargin);
        } else {
          left = repeat(' ', c.leftMargin);
          right = repeat(' ', c.rightMargin + c.width - t[0].length);
        }
        for (k = _n = 0, _ref5 = t.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; k = 0 <= _ref5 ? ++_n : --_n) {
          t[k] = left + t[k] + right;
        }
        bottom = repeat(' ', t[0].length);
        for (_o = _ref6 = t.length, _ref7 = r.height + r.bottomMargin; _ref6 <= _ref7 ? _o < _ref7 : _o > _ref7; _ref6 <= _ref7 ? _o++ : _o--) {
          t.push(bottom);
        }
      }
      for (k = _p = 0, _ref8 = r.height + r.bottomMargin; 0 <= _ref8 ? _p < _ref8 : _p > _ref8; k = 0 <= _ref8 ? ++_p : --_p) {
        result.push(((function() {
          var _q, _results;
          _results = [];
          for (j = _q = 0; 0 <= nCols ? _q < nCols : _q > nCols; j = 0 <= nCols ? ++_q : --_q) {
            _results.push(grid[i][j][k]);
          }
          return _results;
        })()).join(''));
      }
    }
    return result;
  }
};
}, "vocabulary/grade": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, RankError, grade, repeat, _ref;



APLArray = require('../array').APLArray;

_ref = require('../errors'), RankError = _ref.RankError, DomainError = _ref.DomainError;

repeat = require('../helpers').repeat;

this.vocabulary = {
  '⍋': function(omega, alpha) {
    return grade(omega, alpha, 1);
  },
  '⍒': function(omega, alpha) {
    return grade(omega, alpha, -1);
  }
};

grade = function(omega, alpha, direction) {
  var h, _i, _ref1, _results;
  h = {};
  if (alpha) {
    if (!alpha.shape.length) {
      throw RankError();
    }
    h = {};
    alpha.each(function(x, indices) {
      if (typeof x !== 'string') {
        throw DomainError();
      }
      return h[x] = indices[indices.length - 1];
    });
  }
  if (!omega.shape.length) {
    throw RankError();
  }
  return new APLArray((function() {
    _results = [];
    for (var _i = 0, _ref1 = omega.shape[0]; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).sort(function(i, j) {
    var a, indices, p, tx, ty, x, y;
    p = omega.offset;
    indices = repeat([0], omega.shape.length);
    while (true) {
      x = omega.data[p + i * omega.stride[0]];
      y = omega.data[p + j * omega.stride[0]];
      tx = typeof x;
      ty = typeof y;
      if (tx < ty) {
        return -direction;
      }
      if (tx > ty) {
        return direction;
      }
      if (h[x] != null) {
        x = h[x];
      }
      if (h[y] != null) {
        y = h[y];
      }
      if (x < y) {
        return -direction;
      }
      if (x > y) {
        return direction;
      }
      a = indices.length - 1;
      while (a > 0 && indices[a] + 1 === omega.shape[a]) {
        p -= omega.stride[a] * indices[a];
        indices[a--] = 0;
      }
      if (a <= 0) {
        break;
      }
      p += omega.stride[a];
      indices[a]++;
    }
    return 0;
  }));
};
}, "vocabulary/identity": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, RankError, conjunction, withIdentity, _ref;



APLArray = require('../array').APLArray;

_ref = require('./vhelpers'), withIdentity = _ref.withIdentity, conjunction = _ref.conjunction;

RankError = require('../errors').RankError;

this.vocabulary = {
  '⍁': conjunction(function(f, x) {
    var _ref1;
    if (f instanceof APLArray) {
      _ref1 = [x, f], f = _ref1[0], x = _ref1[1];
    }
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/identity.coffee:18");
    }
    if (!(x instanceof APLArray)) {
      throw Error("\"assert x instanceof APLArray\" at src/vocabulary/identity.coffee:19");
    }
    if (!x.isSingleton()) {
      throw RankError();
    }
    if (x.shape.length) {
      x = APLArray.scalar(x.unwrap());
    }
    return withIdentity(x, function(omega, alpha, axis) {
      return f(omega, alpha, axis);
    });
  })
};
}, "vocabulary/iota": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, RankError, match, prod, repeat, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), DomainError = _ref.DomainError, RankError = _ref.RankError;

_ref1 = require('../helpers'), repeat = _ref1.repeat, prod = _ref1.prod;

match = require('./vhelpers').match;

this.vocabulary = {
  '⍳': function(omega, alpha) {
    var a, axis, d, data, indices, tmp0, _i, _j, _len, _ref2, _results;
    if (alpha) {
      if (alpha.shape.length !== 1) {
        throw RankError();
      }
      return omega.map(function(x) {
        var e, r;
        try {
          r = alpha.shape;
          alpha.each(function(y, indices) {
            if (match(x, y)) {
              r = indices;
              throw 'break';
            }
          });
        } catch (_error) {
          e = _error;
          if (e !== 'break') {
            throw e;
          }
        }
        if (r.length === 1) {
          return r[0];
        } else {
          return new APLArray(r);
        }
      });
    } else {
      if (omega.shape.length > 1) {
        throw RankError();
      }
      a = omega.toArray();
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        d = a[_i];
        if (!((tmp0 = (d)) === ~~tmp0 && (0) <= tmp0)) {
          throw DomainError();
        }
      }
      data = [];
      if (prod(a)) {
        if (a.length === 1) {
          data = (function() {
            _results = [];
            for (var _j = 0, _ref2 = a[0]; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--){ _results.push(_j); }
            return _results;
          }).apply(this);
        } else {
          indices = repeat([0], a.length);
          while (true) {
            data.push(new APLArray(indices.slice(0)));
            axis = a.length - 1;
            while (axis >= 0 && indices[axis] + 1 === a[axis]) {
              indices[axis--] = 0;
            }
            if (axis < 0) {
              break;
            }
            indices[axis]++;
          }
        }
      }
      return new APLArray(data, a);
    }
  }
};
}, "vocabulary/logic": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Complex, DomainError, RankError, aka, bool, match, negate, pervasive, real, withIdentity, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), RankError = _ref.RankError, DomainError = _ref.DomainError;

_ref1 = require('./vhelpers'), real = _ref1.real, pervasive = _ref1.pervasive, bool = _ref1.bool, match = _ref1.match, withIdentity = _ref1.withIdentity, aka = _ref1.aka;

Complex = require('../complex').Complex;

this.vocabulary = {
  '~': function(omega, alpha) {
    var data;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      data = [];
      alpha.each(function(x) {
        var e;
        try {
          omega.each(function(y) {
            if (match(x, y)) {
              throw 'break';
            }
          });
          return data.push(x);
        } catch (_error) {
          e = _error;
          if (e !== 'break') {
            throw e;
          }
        }
      });
      return new APLArray(data);
    } else {
      return negate(omega);
    }
  },
  '∨': withIdentity(0, pervasive({
    dyad: function(y, x) {
      if (!(Complex.isint(x)) || !(Complex.isint(y))) {
        throw DomainError('∨ is implemented only for Gaussian integers');
      }
      return Complex.gcd(x, y);
    }
  })),
  '∧': aka('^', withIdentity(1, pervasive({
    dyad: function(y, x) {
      if (!(Complex.isint(x)) || !(Complex.isint(y))) {
        throw DomainError('∧ is implemented only for Gaussian integers');
      }
      return Complex.lcm(x, y);
    }
  }))),
  '⍱': pervasive({
    dyad: real(function(y, x) {
      return +(!(bool(x) | bool(y)));
    })
  }),
  '⍲': pervasive({
    dyad: real(function(y, x) {
      return +(!(bool(x) & bool(y)));
    })
  })
};

negate = pervasive({
  monad: function(x) {
    return +(!bool(x));
  }
});
}, "vocabulary/poweroperator": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, conjunction;



conjunction = require('./vhelpers').conjunction;

APLArray = require('../array').APLArray;

this.vocabulary = {
  '⍣': conjunction(function(g, f) {
    var h, n;
    if (f instanceof APLArray && typeof g === 'function') {
      h = f;
      f = g;
      g = h;
    } else {
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/poweroperator.coffee:19");
      }
    }
    if (typeof g === 'function') {
      return function(omega, alpha) {
        var omega1;
        while (true) {
          omega1 = f(omega, alpha);
          if (g(omega, omega1).toBool()) {
            return omega;
          }
          omega = omega1;
        }
      };
    } else {
      n = g.toInt(0);
      return function(omega, alpha) {
        var _i;
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          omega = f(omega, alpha);
        }
        return omega;
      };
    }
  })
};
}, "vocabulary/quad": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, format;



format = require('./format').format;

APLArray = require('../array').APLArray;

this.vocabulary = {
  'get_⎕': function() {
    if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
      return new APLArray(prompt('⎕:') || '');
    } else {
      throw Error('Reading from ⎕ is not implemented.');
    }
  },
  'set_⎕': function(x) {
    var s;
    s = format(x).join('\n') + '\n';
    if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
      window.alert(s);
    } else {
      process.stdout.write(s);
    }
    return x;
  },
  'get_⍞': function() {
    if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
      return prompt('') || '';
    } else {
      throw Error('Reading from ⍞ is not implemented.');
    }
  },
  'set_⍞': function(x) {
    var s;
    s = format(x).join('\n');
    if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
      window.alert(s);
    } else {
      process.stdout.write(s);
    }
    return x;
  }
};
}, "vocabulary/question": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, deal, pervasive, real, roll, _ref;



APLArray = require('../array').APLArray;

DomainError = require('../errors').DomainError;

_ref = require('./vhelpers'), real = _ref.real, pervasive = _ref.pervasive;

this.vocabulary = {
  '?': function(omega, alpha) {
    if (alpha) {
      return deal(omega, alpha);
    } else {
      return roll(omega);
    }
  }
};

roll = pervasive({
  monad: real(function(x) {
    return Math.floor(Math.random() * x);
  })
});

deal = function(omega, alpha) {
  var available, x, y, _i, _results;
  y = omega.unwrap();
  x = alpha.unwrap();
  if (x > y) {
    throw DomainError();
  }
  available = (function() {
    _results = [];
    for (var _i = 0; 0 <= y ? _i < y : _i > y; 0 <= y ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
  return new APLArray((function() {
    var _j, _results1;
    _results1 = [];
    for (_j = 0; 0 <= x ? _j < x : _j > x; 0 <= x ? _j++ : _j--) {
      _results1.push(available.splice(Math.floor(available.length * Math.random()), 1)[0]);
    }
    return _results1;
  })());
};
}, "vocabulary/rho": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, RankError, prod, repeat, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), RankError = _ref.RankError, DomainError = _ref.DomainError;

_ref1 = require('../helpers'), prod = _ref1.prod, repeat = _ref1.repeat;

this.vocabulary = {
  '⍴': function(omega, alpha) {
    var a, d, n, shape, tmp0, _i, _len;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      shape = alpha.toArray();
      for (_i = 0, _len = shape.length; _i < _len; _i++) {
        d = shape[_i];
        if (!((tmp0 = (d)) === ~~tmp0 && (0) <= tmp0)) {
          throw DomainError();
        }
      }
      n = prod(shape);
      a = omega.toArray(n);
      if (!(a.length <= n)) {
        throw Error("\"assert a.length <= n\" at src/vocabulary/rho.coffee:25");
      }
      if (a.length) {
        while (2 * a.length < n) {
          a = a.concat(a);
        }
        if (a.length !== n) {
          a = a.concat(a.slice(0, n - a.length));
        }
      } else {
        a = repeat([omega.getPrototype()], n);
      }
      return new APLArray(a, shape);
    } else {
      return new APLArray(omega.shape);
    }
  }
};
}, "vocabulary/rotate": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, IndexError, LengthError, prod, repeat, rotate, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), DomainError = _ref.DomainError, LengthError = _ref.LengthError, IndexError = _ref.IndexError;

_ref1 = require('../helpers'), prod = _ref1.prod, repeat = _ref1.repeat;

this.vocabulary = {
  '⌽': rotate = function(omega, alpha, axis) {
    var a, data, indices, n, offset, p, shape, step, stride, tmp0, tmp1, tmp2;
    if (!(typeof axis === 'undefined' || axis instanceof APLArray)) {
      throw Error("\"assert typeof axis is 'undefined' or axis instanceof APLArray\" at src/vocabulary/rotate.coffee:9");
    }
    if (alpha) {
      axis = !axis ? omega.shape.length - 1 : axis.unwrap();
      if (!((tmp0 = (axis)) === ~~tmp0)) {
        throw DomainError();
      }
      if (omega.shape.length && !((0 <= axis && axis < omega.shape.length))) {
        throw IndexError();
      }
      step = alpha.unwrap();
      if (!((tmp1 = (step)) === ~~tmp1)) {
        throw DomainError();
      }
      if (!step) {
        return omega;
      }
      n = omega.shape[axis];
      step = (n + (step % n)) % n;
      if (omega.empty() || step === 0) {
        return omega;
      }
      data = [];
      shape = omega.shape, stride = omega.stride;
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        data.push(omega.data[p + ((indices[axis] + step) % shape[axis] - indices[axis]) * stride[axis]]);
        a = shape.length - 1;
        while (a >= 0 && indices[a] + 1 === shape[a]) {
          p -= indices[a] * stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        indices[a]++;
        p += stride[a];
      }
      return new APLArray(data, shape);
    } else {
      if (axis) {
        if (!axis.isSingleton()) {
          throw LengthError();
        }
        axis = axis.unwrap();
        if (!((tmp2 = (axis)) === ~~tmp2)) {
          throw DomainError();
        }
        if (!((0 <= axis && axis < omega.shape.length))) {
          throw IndexError();
        }
      } else {
        axis = [omega.shape.length - 1];
      }
      if (omega.shape.length === 0) {
        return omega;
      }
      stride = omega.stride.slice(0);
      stride[axis] = -stride[axis];
      offset = omega.offset + (omega.shape[axis] - 1) * omega.stride[axis];
      return new APLArray(omega.data, omega.shape, stride, offset);
    }
  },
  '⊖': function(omega, alpha, axis) {
    if (axis == null) {
      axis = APLArray.zero;
    }
    return rotate(omega, alpha, axis);
  }
};
}, "vocabulary/slash": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, LengthError, RankError, adverb, compressOrReplicate, reduce, repeat, _ref;



APLArray = require('../array').APLArray;

_ref = require('../errors'), RankError = _ref.RankError, LengthError = _ref.LengthError, DomainError = _ref.DomainError;

repeat = require('../helpers').repeat;

adverb = require('./vhelpers').adverb;

this.vocabulary = {
  '/': adverb(function(omega, alpha, axis) {
    if (typeof omega === 'function') {
      return reduce(omega, alpha, axis);
    } else {
      return compressOrReplicate(omega, alpha, axis);
    }
  }),
  '⌿': adverb(function(omega, alpha, axis) {
    if (axis == null) {
      axis = APLArray.zero;
    }
    if (typeof omega === 'function') {
      return reduce(omega, alpha, axis);
    } else {
      return compressOrReplicate(omega, alpha, axis);
    }
  })
};

reduce = this.reduce = function(f, g, axis0) {
  if (!(typeof f === 'function')) {
    throw Error("\"assert typeof f is 'function'\" at src/vocabulary/slash.coffee:42");
  }
  if (!(typeof g === 'undefined')) {
    throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/slash.coffee:43");
  }
  if (!((typeof axis0 === 'undefined') || (axis0 instanceof APLArray))) {
    throw Error("\"assert((typeof axis0 is 'undefined') or (axis0 instanceof APLArray))\" at src/vocabulary/slash.coffee:44");
  }
  return function(omega, alpha) {
    var a, axis, data, i, indices, isBackwards, isMonadic, isNWise, n, p, rShape, shape, x, y, z, _i, _j, _ref1, _ref2;
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    axis = axis0 != null ? axis0.toInt() : omega.shape.length - 1;
    if (!((0 <= axis && axis < omega.shape.length))) {
      throw RankError();
    }
    if (alpha) {
      isNWise = true;
      n = alpha.toInt();
      if (n < 0) {
        isBackwards = true;
        n = -n;
      }
    } else {
      n = omega.shape[axis];
      isMonadic = true;
    }
    shape = omega.shape.slice(0);
    shape[axis] = omega.shape[axis] - n + 1;
    rShape = shape;
    if (isNWise) {
      if (shape[axis] === 0) {
        return new APLArray([], rShape);
      }
      if (shape[axis] < 0) {
        throw LengthError();
      }
    } else {
      rShape = rShape.slice(0);
      rShape.splice(axis, 1);
    }
    if (omega.empty()) {
      if ((z = (_ref1 = f.aplMetaInfo) != null ? _ref1.identity : void 0) != null) {
        if (!(z.shape.length === 0)) {
          throw Error("\"assert z.shape.length is 0\" at src/vocabulary/slash.coffee:72");
        }
        return new APLArray(z.data, rShape, repeat([0], rShape.length), z.offset);
      } else {
        throw DomainError();
      }
    }
    data = [];
    indices = repeat([0], shape.length);
    p = omega.offset;
    while (true) {
      if (isBackwards) {
        x = omega.data[p];
        x = x instanceof APLArray ? x : APLArray.scalar(x);
        for (i = _i = 1; _i < n; i = _i += 1) {
          y = omega.data[p + i * omega.stride[axis]];
          y = y instanceof APLArray ? y : APLArray.scalar(y);
          x = f(x, y);
        }
      } else {
        x = omega.data[p + (n - 1) * omega.stride[axis]];
        x = x instanceof APLArray ? x : APLArray.scalar(x);
        for (i = _j = _ref2 = n - 2; _j >= 0; i = _j += -1) {
          y = omega.data[p + i * omega.stride[axis]];
          y = y instanceof APLArray ? y : APLArray.scalar(y);
          x = f(x, y);
        }
      }
      if (x.shape.length === 0) {
        x = x.unwrap();
      }
      data.push(x);
      a = indices.length - 1;
      while (a >= 0 && indices[a] + 1 === shape[a]) {
        p -= indices[a] * omega.stride[a];
        indices[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += omega.stride[a];
      indices[a]++;
    }
    return new APLArray(data, rShape);
  };
};

compressOrReplicate = function(omega, alpha, axis) {
  var a, b, data, filler, i, indices, n, p, shape, tmp0, x, _i, _j, _len, _ref1;
  if (omega.shape.length === 0) {
    omega = new APLArray([omega.unwrap()]);
  }
  axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  a = alpha.toArray();
  n = omega.shape[axis];
  if (a.length === 1) {
    a = repeat(a, n);
  }
  if (n !== 1 && n !== a.length) {
    throw LengthError();
  }
  shape = omega.shape.slice(0);
  shape[axis] = 0;
  b = [];
  for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
    x = a[i];
    if (!((tmp0 = (x)) === ~~tmp0)) {
      throw DomainError();
    }
    shape[axis] += Math.abs(x);
    for (_j = 0, _ref1 = Math.abs(x); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--) {
      b.push(x > 0 ? i : null);
    }
  }
  if (n === 1) {
    b = (function() {
      var _k, _len1, _results;
      _results = [];
      for (_k = 0, _len1 = b.length; _k < _len1; _k++) {
        x = b[_k];
        _results.push(x != null ? 0 : x);
      }
      return _results;
    })();
  }
  data = [];
  if (shape[axis] !== 0 && !omega.empty()) {
    filler = omega.getPrototype();
    p = omega.offset;
    indices = repeat([0], shape.length);
    while (true) {
      x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
      data.push(x);
      i = shape.length - 1;
      while (i >= 0 && indices[i] + 1 === shape[i]) {
        if (i !== axis) {
          p -= omega.stride[i] * indices[i];
        }
        indices[i--] = 0;
      }
      if (i < 0) {
        break;
      }
      if (i !== axis) {
        p += omega.stride[i];
      }
      indices[i]++;
    }
  }
  return new APLArray(data, shape);
};
}, "vocabulary/special": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Complex, match;



APLArray = require('../array').APLArray;

Complex = require('../complex').Complex;

match = require('./vhelpers').match;

this.vocabulary = {
  _aplify: function(x) {
    var y;
    if (!(x != null)) {
      throw Error("\"assert x?\" at src/vocabulary/special.coffee:9");
    }
    if (typeof x === 'string') {
      if (x.length === 1) {
        return APLArray.scalar(x);
      } else {
        return new APLArray(x);
      }
    } else if (typeof x === 'number') {
      return APLArray.scalar(x);
    } else if (x instanceof Array) {
      return new APLArray((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          y = x[_i];
          if (y instanceof APLArray && y.shape.length === 0) {
            _results.push(y.unwrap());
          } else {
            _results.push(y);
          }
        }
        return _results;
      })());
    } else if (x instanceof APLArray) {
      return x;
    } else {
      throw Error('Cannot aplify object ' + x);
    }
  },
  _complex: function(re, im) {
    return APLArray.scalar(new Complex(re, im));
  },
  _bool: function(x) {
    if (!(x instanceof APLArray)) {
      throw Error("\"assert x instanceof APLArray\" at src/vocabulary/special.coffee:24");
    }
    return x.toBool();
  },
  'get_⎕IO': function() {
    return APLArray.zero;
  },
  'set_⎕IO': function(x) {
    if (match(x, APLArray.zero)) {
      return x;
    } else {
      throw Error('The index origin (⎕IO) is fixed at 0');
    }
  }
};
}, "vocabulary/squish": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, IndexError, LengthError, RankError, prepareForIndexing, prod, repeat, squish, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), DomainError = _ref.DomainError, IndexError = _ref.IndexError, RankError = _ref.RankError, LengthError = _ref.LengthError;

_ref1 = require('../helpers'), prod = _ref1.prod, repeat = _ref1.repeat;

this.vocabulary = {
  '⌷': squish = function(omega, alpha, axes) {
    var a, data, p, subscriptShapes, subscripts, u, _i, _ref2, _ref3, _ref4;
    if (typeof omega === 'function') {
      return function(x, y) {
        return omega(x, y, alpha);
      };
    }
    if (!alpha) {
      throw Error('Not implemented');
    }
    _ref2 = prepareForIndexing(omega, alpha, axes), subscripts = _ref2[0], subscriptShapes = _ref2[1];
    data = [];
    u = repeat([0], subscripts.length);
    p = omega.offset;
    for (a = _i = 0, _ref3 = subscripts.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; a = 0 <= _ref3 ? ++_i : --_i) {
      p += subscripts[a][0] * omega.stride[a];
    }
    while (true) {
      data.push(omega.data[p]);
      a = subscripts.length - 1;
      while (a >= 0 && u[a] + 1 === subscripts[a].length) {
        p += (subscripts[a][0] - subscripts[a][u[a]]) * omega.stride[a];
        u[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += (subscripts[a][u[a] + 1] - subscripts[a][u[a]]) * omega.stride[a];
      u[a]++;
    }
    return new APLArray(data, (_ref4 = []).concat.apply(_ref4, subscriptShapes));
  },
  _index: function(alpha, omega, axes) {
    return squish(omega, alpha, axes);
  },
  _substitute: function(value, alpha, omega, axes) {
    var a, i, indexShape, n, p, q, r, subscriptShapes, subscripts, u, _i, _j, _len, _ref2, _ref3, _ref4;
    _ref2 = prepareForIndexing(omega, alpha, axes), subscripts = _ref2[0], subscriptShapes = _ref2[1];
    indexShape = (_ref3 = []).concat.apply(_ref3, subscriptShapes);
    if (value.isSingleton()) {
      value = new APLArray([value.unwrap()], indexShape, repeat([0], indexShape.length));
    } else {
      if (value.shape.length !== indexShape.length) {
        throw RankError();
      } else {
        for (i = _i = 0, _len = indexShape.length; _i < _len; i = ++_i) {
          n = indexShape[i];
          if (value.shape[i] !== n) {
            throw LengthError();
          }
        }
      }
    }
    r = new APLArray(omega.toArray(), omega.shape);
    p = 0;
    for (a = _j = 0, _ref4 = subscripts.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; a = 0 <= _ref4 ? ++_j : --_j) {
      p += subscripts[a][0] * r.stride[a];
    }
    q = value.offset;
    u = repeat([0], subscripts.length);
    while (true) {
      r.data[p] = value.data[q];
      a = subscripts.length - 1;
      while (a >= 0 && u[a] + 1 === subscripts[a].length) {
        p += (subscripts[a][0] - subscripts[a][u[a]]) * r.stride[a];
        q -= u[a] * value.stride[a];
        u[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += (subscripts[a][u[a] + 1] - subscripts[a][u[a]]) * r.stride[a];
      q += value.stride[a];
      u[a]++;
    }
    return r;
  }
};

prepareForIndexing = function(omega, alpha, axes) {
  var alphaItems, axis, d, i, subscriptShapes, subscripts, tmp0, tmp1, x, _i, _j, _k, _l, _len, _len1, _m, _ref2, _ref3, _ref4, _ref5, _results, _results1;
  if (!(alpha instanceof APLArray)) {
    throw Error("\"assert alpha instanceof APLArray\" at src/vocabulary/squish.coffee:114");
  }
  if (!(omega instanceof APLArray)) {
    throw Error("\"assert omega instanceof APLArray\" at src/vocabulary/squish.coffee:115");
  }
  if (!((axes == null) || axes instanceof APLArray)) {
    throw Error("\"assert (not axes?) or axes instanceof APLArray\" at src/vocabulary/squish.coffee:116");
  }
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  alphaItems = alpha.toArray();
  if (alphaItems.length > omega.shape.length) {
    throw LengthError();
  }
  axes = axes ? axes.toArray() : (function() {
    _results = [];
    for (var _i = 0, _ref2 = alphaItems.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
  if (alphaItems.length !== axes.length) {
    throw LengthError();
  }
  subscripts = Array(omega.shape.length);
  subscriptShapes = Array(omega.shape.length);
  for (i = _j = 0, _len = axes.length; _j < _len; i = ++_j) {
    axis = axes[i];
    if (!((tmp0 = (axis)) === ~~tmp0)) {
      throw DomainError();
    }
    if (!((0 <= axis && axis < omega.shape.length))) {
      throw RankError();
    }
    if (typeof subscripts[axis] !== 'undefined') {
      throw RankError('Duplicate axis');
    }
    d = alphaItems[i];
    subscripts[axis] = d instanceof APLArray ? d.toArray() : [d];
    if (!subscripts[axis].length) {
      throw Error("\"assert subscripts[axis].length\" at src/vocabulary/squish.coffee:133");
    }
    subscriptShapes[axis] = d instanceof APLArray ? d.shape : [];
    _ref3 = subscripts[axis];
    for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
      x = _ref3[_k];
      if (!((tmp1 = (x)) === ~~tmp1)) {
        throw DomainError();
      }
      if (!((0 <= x && x < omega.shape[axis]))) {
        throw IndexError();
      }
    }
  }
  for (i = _l = 0, _ref4 = subscripts.length; 0 <= _ref4 ? _l < _ref4 : _l > _ref4; i = 0 <= _ref4 ? ++_l : --_l) {
    if (!(typeof subscripts[i] === 'undefined')) {
      continue;
    }
    subscripts[i] = (function() {
      _results1 = [];
      for (var _m = 0, _ref5 = omega.shape[i]; 0 <= _ref5 ? _m < _ref5 : _m > _ref5; 0 <= _ref5 ? _m++ : _m--){ _results1.push(_m); }
      return _results1;
    }).apply(this);
    subscriptShapes[i] = [omega.shape[i]];
  }
  return [subscripts, subscriptShapes];
};
}, "vocabulary/tack": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray;



APLArray = require('../array').APLArray;

this.vocabulary = {
  '⊣': function(omega, alpha) {
    if (alpha == null) {
      alpha = APLArray.zilde;
    }
    return alpha;
  },
  '⊢': function(omega) {
    return omega;
  }
};
}, "vocabulary/take": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, NonceError, RankError, mix, prod, repeat, take, _ref, _ref1;



APLArray = require('../array').APLArray;

_ref = require('../errors'), DomainError = _ref.DomainError, RankError = _ref.RankError, NonceError = _ref.NonceError;

_ref1 = require('../helpers'), prod = _ref1.prod, repeat = _ref1.repeat;

this.vocabulary = {
  '↑': function(omega, alpha) {
    if (alpha) {
      return take(omega, alpha);
    } else {
      return mix(omega);
    }
  }
};

take = function(omega, alpha) {
  var a, axis, copyIndices, copyShape, data, i, mustCopy, offset, p, q, shape, stride, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref2;
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  if (omega.shape.length === 0) {
    omega = new APLArray([omega.unwrap()], (alpha.shape.length === 0 ? [1] : repeat([1], alpha.shape[0])));
  }
  a = alpha.toArray();
  if (a.length > omega.shape.length) {
    throw RankError();
  }
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    x = a[_i];
    if (typeof x !== 'number' || x !== Math.floor(x)) {
      throw DomainError();
    }
  }
  mustCopy = false;
  shape = omega.shape.slice(0);
  for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
    x = a[i];
    shape[i] = Math.abs(x);
    if (shape[i] > omega.shape[i]) {
      mustCopy = true;
    }
  }
  if (mustCopy) {
    stride = Array(shape.length);
    stride[stride.length - 1] = 1;
    for (i = _k = _ref2 = stride.length - 2; _k >= 0; i = _k += -1) {
      stride[i] = stride[i + 1] * shape[i + 1];
    }
    data = repeat([omega.getPrototype()], prod(shape));
    copyShape = shape.slice(0);
    p = omega.offset;
    q = 0;
    for (i = _l = 0, _len2 = a.length; _l < _len2; i = ++_l) {
      x = a[i];
      copyShape[i] = Math.min(omega.shape[i], Math.abs(x));
      if (x < 0) {
        if (x < -omega.shape[i]) {
          q -= (x + omega.shape[i]) * stride[i];
        } else {
          p += (x + omega.shape[i]) * omega.stride[i];
        }
      }
    }
    if (prod(copyShape)) {
      copyIndices = repeat([0], copyShape.length);
      while (true) {
        data[q] = omega.data[p];
        axis = copyShape.length - 1;
        while (axis >= 0 && copyIndices[axis] + 1 === copyShape[axis]) {
          p -= copyIndices[axis] * omega.stride[axis];
          q -= copyIndices[axis] * stride[axis];
          copyIndices[axis--] = 0;
        }
        if (axis < 0) {
          break;
        }
        p += omega.stride[axis];
        q += stride[axis];
        copyIndices[axis]++;
      }
    }
    return new APLArray(data, shape, stride);
  } else {
    offset = omega.offset;
    for (i = _m = 0, _len3 = a.length; _m < _len3; i = ++_m) {
      x = a[i];
      if (x < 0) {
        offset += (omega.shape[i] + x) * omega.stride[i];
      }
    }
    return new APLArray(omega.data, shape, omega.stride, offset);
  }
};

mix = function(omega) {
  var data, s, shape, shapes, x;
  if (omega.shape.length === 0) {
    x = omega.data[omega.offset];
    if (x instanceof APLArray) {
      return x;
    } else {
      return APLArray.scalar(x);
    }
  } else {
    shapes = [];
    omega.each(function(x) {
      return shapes.push(x.shape);
    });
    if (shapes.length === 0) {
      throw NonceError('Mix of empty array not implemented');
    }
    shape = shapes.reduce(function(a, b) {
      var i, _i, _ref2, _results;
      if (a.length !== b.length) {
        throw NonceError('Mix of different ranks not implemented');
      }
      _results = [];
      for (i = _i = 0, _ref2 = a.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        _results.push(Math.max(a[i], b[i]));
      }
      return _results;
    });
    s = new APLArray(shape);
    data = [];
    omega.each(function(x) {
      return data = data.concat((take(x, s)).toArray());
    });
    return new APLArray(data, omega.shape.concat(shape));
  }
};
}, "vocabulary/transpose": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, DomainError, LengthError, RankError, _ref;



APLArray = require('../array').APLArray;

_ref = require('../errors'), DomainError = _ref.DomainError, RankError = _ref.RankError, LengthError = _ref.LengthError;

this.vocabulary = {
  '⍉': function(omega, alpha) {
    var i, n, shape, stride, tmp0, x, _i, _len, _ref1;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      if (alpha.shape.length === 0) {
        alpha = new APLArray([alpha.unwrap()]);
      }
      n = omega.shape.length;
      if (alpha.shape[0] !== n) {
        throw LengthError();
      }
      shape = Array(n);
      stride = Array(n);
      _ref1 = alpha.toArray();
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        x = _ref1[i];
        if (!((tmp0 = (x)) === ~~tmp0 && (0) <= tmp0)) {
          throw DomainError();
        }
        if (x >= n) {
          throw RankError();
        }
        if (shape[x] != null) {
          throw DomainError('Duplicate axis');
        }
        shape[x] = omega.shape[i];
        stride[x] = omega.stride[i];
      }
      return new APLArray(omega.data, shape, stride, omega.offset);
    } else {
      return new APLArray(omega.data, omega.shape.slice(0).reverse(), omega.stride.slice(0).reverse(), omega.offset);
    }
  }
};
}, "vocabulary/variant": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var conjunction;



conjunction = require('./vhelpers').conjunction;

this.vocabulary = {
  '⍠': conjunction(function(f, g) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/variant.coffee:11");
    }
    if (!(typeof g === 'function')) {
      throw Error("\"assert typeof g is 'function'\" at src/vocabulary/variant.coffee:12");
    }
    return function(omega, alpha, axis) {
      return (alpha != null ? f : g)(omega, alpha, axis);
    };
  })
};
}, "vocabulary/vhelpers": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray, Complex, DomainError, LengthError, RankError, SyntaxError, approx, complexify, eps, match, meta, multiplicitySymbol, numApprox, _ref, _ref1,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };



_ref = require('../errors'), DomainError = _ref.DomainError, LengthError = _ref.LengthError, RankError = _ref.RankError, SyntaxError = _ref.SyntaxError;

APLArray = require('../array').APLArray;

_ref1 = require('../complex'), Complex = _ref1.Complex, complexify = _ref1.complexify;

multiplicitySymbol = function(z) {
  if (z instanceof APLArray) {
    if (z.isSingleton()) {
      return '1';
    } else {
      return '*';
    }
  } else {
    return '.';
  }
};

this.pervasive = function(_arg) {
  var F, dyad, monad, pervadeDyadic, pervadeMonadic;
  monad = _arg.monad, dyad = _arg.dyad;
  pervadeMonadic = monad ? function(x) {
    var r;
    if (x instanceof APLArray) {
      return x.map(pervadeMonadic);
    } else {
      r = monad(x);
      if (typeof r === 'number' && isNaN(r)) {
        throw DomainError('NaN');
      }
      return r;
    }
  } : function() {
    throw Error('Not implemented');
  };
  pervadeDyadic = dyad ? function(x, y) {
    var axis, r, tx, ty, xi, yi, _i, _ref2;
    tx = multiplicitySymbol(x);
    ty = multiplicitySymbol(y);
    switch (tx + ty) {
      case '..':
        r = dyad(x, y);
        if (typeof r === 'number' && isNaN(r)) {
          throw DomainError('NaN');
        }
        return r;
      case '.1':
        return y.map(function(yi) {
          return pervadeDyadic(x, yi);
        });
      case '.*':
        return y.map(function(yi) {
          return pervadeDyadic(x, yi);
        });
      case '1.':
        return x.map(function(xi) {
          return pervadeDyadic(xi, y);
        });
      case '*.':
        return x.map(function(xi) {
          return pervadeDyadic(xi, y);
        });
      case '1*':
        xi = x.unwrap();
        return y.map(function(yi) {
          return pervadeDyadic(xi, yi);
        });
      case '*1':
        yi = y.unwrap();
        return x.map(function(xi) {
          return pervadeDyadic(xi, yi);
        });
      case '11':
        yi = y.unwrap();
        return x.map(function(xi) {
          return pervadeDyadic(xi, yi);
        });
      case '**':
        if (x.shape.length !== y.shape.length) {
          throw RankError();
        }
        for (axis = _i = 0, _ref2 = x.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; axis = 0 <= _ref2 ? ++_i : --_i) {
          if (x.shape[axis] !== y.shape[axis]) {
            throw LengthError();
          }
        }
        return x.map2(y, pervadeDyadic);
    }
  } : function() {
    throw Error('Not implemented');
  };
  return F = function(omega, alpha) {
    if (!(omega instanceof APLArray)) {
      throw Error("\"assert omega instanceof APLArray\" at src/vocabulary/vhelpers.coffee:53");
    }
    if (!(alpha instanceof APLArray || typeof alpha === 'undefined')) {
      throw Error("\"assert alpha instanceof APLArray or typeof alpha is 'undefined'\" at src/vocabulary/vhelpers.coffee:54");
    }
    return (alpha ? pervadeDyadic : pervadeMonadic)(omega, alpha);
  };
};

this.real = function(f) {
  return function(x, y, axis) {
    if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
      return f(x, y, axis);
    } else {
      throw DomainError();
    }
  };
};

this.numeric = function(f, g) {
  return function(x, y, axis) {
    if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
      return f(x, y, axis);
    } else {
      x = complexify(x);
      if (y != null) {
        y = complexify(y);
      }
      return g(x, y, axis);
    }
  };
};

this.match = match = function(x, y) {
  var axis, r, _i, _ref2;
  if (x instanceof APLArray) {
    if (!(y instanceof APLArray)) {
      return false;
    } else {
      if (x.shape.length !== y.shape.length) {
        return false;
      }
      for (axis = _i = 0, _ref2 = x.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; axis = 0 <= _ref2 ? ++_i : --_i) {
        if (x.shape[axis] !== y.shape[axis]) {
          return false;
        }
      }
      r = true;
      x.each2(y, function(xi, yi) {
        if (!match(xi, yi)) {
          return r = false;
        }
      });
      return r;
    }
  } else {
    if (y instanceof APLArray) {
      return false;
    } else {
      if (x instanceof Complex && y instanceof Complex) {
        return x.re === y.re && x.im === y.im;
      } else {
        return x === y;
      }
    }
  }
};

eps = 1e-13;

numApprox = function(x, y) {
  return x === y || Math.abs(x - y) < eps;
};

this.approx = approx = function(x, y) {
  var axis, r, _i, _ref2, _ref3, _ref4;
  if (x instanceof APLArray) {
    if (!(y instanceof APLArray)) {
      return false;
    } else {
      if (x.shape.length !== y.shape.length) {
        return false;
      }
      for (axis = _i = 0, _ref2 = x.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; axis = 0 <= _ref2 ? ++_i : --_i) {
        if (x.shape[axis] !== y.shape[axis]) {
          return false;
        }
      }
      r = true;
      x.each2(y, function(xi, yi) {
        if (!approx(xi, yi)) {
          return r = false;
        }
      });
      return r;
    }
  } else {
    if (y instanceof APLArray) {
      return false;
    } else if (!((x != null) && (y != null))) {
      return false;
    } else {
      if (typeof x === 'number') {
        x = new Complex(x);
      }
      if (typeof y === 'number') {
        y = new Complex(y);
      }
      if (x instanceof Complex) {
        return y instanceof Complex && numApprox(x.re, y.re) && numApprox(x.im, y.im);
      } else {
        return (_ref3 = (_ref4 = typeof x['≡'] === "function" ? x['≡'](y) : void 0) != null ? _ref4 : typeof y['≡'] === "function" ? y['≡'](x) : void 0) != null ? _ref3 : x === y;
      }
    }
  }
};

this.bool = function(x) {
  if (x !== 0 && x !== 1) {
    throw DomainError();
  }
  return x;
};

this.getAxisList = function(axes, rank) {
  var a, i, tmp0, tmp1, tmp2, x, _i, _len, _ref2, _ref3;
  if (!((tmp0 = (rank)) === ~~tmp0 && (0) <= tmp0)) {
    throw Error("\"assert isInt rank, 0\" at src/vocabulary/vhelpers.coffee:124");
  }
  if (typeof axes === 'undefined') {
    return [];
  }
  if (!(axes instanceof APLArray)) {
    throw Error("\"assert axes instanceof APLArray\" at src/vocabulary/vhelpers.coffee:126");
  }
  if (axes.shape.length !== 1 || axes.shape[0] !== 1) {
    throw SyntaxError();
  }
  a = axes.unwrap();
  if (a instanceof APLArray) {
    a = a.toArray();
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      x = a[i];
      if (!((tmp1 = (x)) === ~~tmp1 && ((0) <= (_ref2 = tmp1) && _ref2 < (rank)))) {
        throw DomainError();
      }
      if (__indexOf.call(a.slice(0, i), x) >= 0) {
        throw Error('Non-unique axes');
      }
    }
    return a;
  } else if ((tmp2 = (a)) === ~~tmp2 && ((0) <= (_ref3 = tmp2) && _ref3 < (rank))) {
    return [a];
  } else {
    throw DomainError();
  }
};

meta = function(f, name, value) {
  if (!(typeof f === 'function')) {
    throw Error("\"assert typeof f is 'function'\" at src/vocabulary/vhelpers.coffee:144");
  }
  if (!(typeof name === 'string')) {
    throw Error("\"assert typeof name is 'string'\" at src/vocabulary/vhelpers.coffee:145");
  }
  (f.aplMetaInfo != null ? f.aplMetaInfo : f.aplMetaInfo = {})[name] = value;
  return f;
};

this.withIdentity = function(x, f) {
  if (!(x instanceof APLArray)) {
    x = APLArray.scalar(x);
  }
  return meta(f, 'identity', x);
};

this.adverb = function(f) {
  return meta(f, 'isPostfixAdverb', true);
};

this.prefixAdverb = function(f) {
  return meta(f, 'isPrefixAdverb', true);
};

this.conjunction = function(f) {
  return meta(f, 'isConjunction', true);
};

this.aka = function(aliases, f) {
  if (typeof aliases === 'string') {
    aliases = [aliases];
  } else {
    if (!(aliases instanceof Array)) {
      throw Error("\"assert aliases instanceof Array\" at src/vocabulary/vhelpers.coffee:161");
    }
  }
  return meta(f, 'aliases', aliases);
};
}, "vocabulary/zilde": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var APLArray;



APLArray = require('../array').APLArray;

this.vocabulary = {
  'get_⍬': function() {
    return APLArray.zilde;
  },
  'set_⍬': function() {
    throw Error('Symbol zilde (⍬) is read-only.');
  }
};
}, "gamma": function(exports, require, module) {// transliterated from the python snippet here:
// http://en.wikipedia.org/wiki/Lanczos_approximation

var g = 7;
var p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
];

var g_ln = 607/128;
var p_ln = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.21743961811521264320e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.26190838401581408670e-4,
    0.36899182659531622704e-5
];

// Spouge approximation (suitable for large arguments)
function lngamma(z) {

    if(z < 0) return Number('0/0');
    var x = p_ln[0];
    for(var i = p_ln.length - 1; i > 0; --i) x += p_ln[i] / (z + i);
    var t = z + g_ln + 0.5;
    return .5*Math.log(2*Math.PI)+(z+.5)*Math.log(t)-t+Math.log(x)-Math.log(z);
}

module.exports = function gamma (z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    }
    else if(z > 100) return Math.exp(lngamma(z));
    else {
        z -= 1;
        var x = p[0];
        for (var i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        var t = z + g + 0.5;

        return Math.sqrt(2 * Math.PI)
            * Math.pow(t, z + 0.5)
            * Math.exp(-t)
            * x
        ;
    }
};

module.exports.log = lngamma;
}});
var apl = require("apl");
