//usr/bin/env node "$0" $@ ; exit $?
// Generated by CoffeeScript 1.6.3
var __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function() {
  var APLArray, Beta, Complex, DYA, EMB, GET, JEQ, LAM, LDC, MON, POP, RET, SET, SPL, VEC, addVocabulary, adverb, aka, all, apl, aplError, aplify, approx, arrayEquals, bool, compile, compileAST, complexify, compressOrReplicate, conjunction, contains, cps, deal, depthOf, domainError, enlist, eq, exec, execInternal, exp, expand, extend, first, format, getAxisList, grade, indexError, innerProduct, lengthError, lnΓ, match, negInt, nonceError, numApprox, numeric, outerProduct, parse, pervasive, prelude, prepareForIndexing, prod, rankError, real, reduce, repeat, roll, rotate, scan, simplify, smallFactorials, squish, strideForShape, syntaxError, take, tokenDefs, tokenize, vm, vocabulary, withIdentity, Γ, λ, _ref;

  prod = function(xs) {
    var r, x, _i, _len;
    r = 1;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      r *= x;
    }
    return r;
  };
  all = function(xs) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (!x) {
        return false;
      }
    }
    return true;
  };
  repeat = function(a, n) {
    var m, tmp0;
    if (!(typeof a === 'string' || a instanceof Array)) {
      throw Error("\"assert typeof a is 'string' or a instanceof Array\" at src/helpers.coffee:6");
    }
    if (!((tmp0 = (n)) === ~~tmp0 && (0) <= tmp0)) {
      throw Error("\"assert isInt n, 0\" at src/helpers.coffee:7");
    }
    if (!n) {
      return a.slice(0, 0);
    }
    m = n * a.length;
    while (a.length * 2 < m) {
      a = a.concat(a);
    }
    return a.concat(a.slice(0, m - a.length));
  };
  extend = function(x, y) {
    var k;
    for (k in y) {
      x[k] = y[k];
    }
    return x;
  };
  aplError = function(name, message, opts) {
    var e, k, v, _ref;
    if (message == null) {
      message = '';
    }
    if (!(typeof name === 'string')) {
      throw Error("\"assert typeof name is 'string'\" at src/errors.coffee:2");
    }
    if (!(typeof message === 'string')) {
      throw Error("\"assert typeof message is 'string'\" at src/errors.coffee:3");
    }
    if (opts != null) {
      if (!(typeof opts === 'object')) {
        throw Error("\"assert typeof opts is 'object'\" at src/errors.coffee:5");
      }
      if ((opts.aplCode != null) && (opts.line != null) && (opts.col != null)) {
        if (!(typeof opts.aplCode === 'string')) {
          throw Error("\"assert typeof opts.aplCode is 'string'\" at src/errors.coffee:7");
        }
        if (!(typeof opts.line === 'number')) {
          throw Error("\"assert typeof opts.line is 'number'\" at src/errors.coffee:8");
        }
        if (!(typeof opts.col === 'number')) {
          throw Error("\"assert typeof opts.col is 'number'\" at src/errors.coffee:9");
        }
        if (!((_ref = typeof opts.file) === 'string' || _ref === 'undefined')) {
          throw Error("\"assert typeof opts.file in ['string', 'undefined']\" at src/errors.coffee:10");
        }
        message += "\n" + (opts.file || '-') + ":#" + opts.line + ":" + opts.col + "\n" + (opts.aplCode.split('\n')[opts.line - 1]) + "\n" + (repeat('_', opts.col - 1)) + "^";
      }
    }
    e = Error(message);
    e.name = name;
    for (k in opts) {
      v = opts[k];
      e[k] = v;
    }
    throw e;
  };
  syntaxError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['SYNTAX ERROR'].concat(__slice.call(a)));
  };
  domainError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['DOMAIN ERROR'].concat(__slice.call(a)));
  };
  lengthError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['LENGTH ERROR'].concat(__slice.call(a)));
  };
  rankError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['RANK ERROR'].concat(__slice.call(a)));
  };
  indexError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['INDEX ERROR'].concat(__slice.call(a)));
  };
  nonceError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['NONCE ERROR'].concat(__slice.call(a)));
  };
  APLArray = (function() {
    function APLArray(data, shape, stride, offset) {
      var i, tmp1, tmp2, tmp3, x, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      this.data = data;
      this.shape = shape;
      this.stride = stride;
      this.offset = offset != null ? offset : 0;
      if (this.shape == null) {
        this.shape = [this.data.length];
      }
      if (this.stride == null) {
        this.stride = strideForShape(this.shape);
      }
      if (!(this.data instanceof Array || typeof this.data === 'string')) {
        throw Error("\"assert @data instanceof Array or typeof @data is 'string'\" at src/array.coffee:6");
      }
      if (!(this.shape instanceof Array)) {
        throw Error("\"assert @shape instanceof Array\" at src/array.coffee:7");
      }
      if (!(this.stride instanceof Array)) {
        throw Error("\"assert @stride instanceof Array\" at src/array.coffee:8");
      }
      if (!(this.data.length === 0 || ((tmp1 = this.offset) === ~~tmp1 && ((0) <= (_ref = tmp1) && _ref < this.data.length)))) {
        throw Error("\"assert @data.length is 0 or isInt @offset, 0, @data.length\" at src/array.coffee:9");
      }
      if (!(this.shape.length === this.stride.length)) {
        throw Error("\"assert @shape.length is @stride.length\" at src/array.coffee:10");
      }
      _ref1 = this.shape;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        if (!((tmp2 = (x)) === ~~tmp2 && (0) <= tmp2)) {
          throw Error("\"for x in @shape then assert isInt x, 0\" at src/array.coffee:11");
        }
      }
      if (this.data.length) {
        _ref2 = this.stride;
        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
          x = _ref2[i];
          if (!((tmp3 = (x)) === ~~tmp3 && ((-this.data.length) <= (_ref3 = tmp3) && _ref3 < (this.data.length + 1)))) {
            throw Error("\"for x, i in @stride then assert isInt x, -@data.length, @data.length + 1\" at src/array.coffee:13");
          }
        }
      } else {
        if (!(prod(this.shape) === 0)) {
          throw Error("\"assert prod(@shape) is 0\" at src/array.coffee:15");
        }
      }
    }

    APLArray.prototype.empty = function() {
      var d, _i, _len, _ref;
      _ref = this.shape;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        if (!d) {
          return true;
        }
      }
      return false;
    };

    APLArray.prototype.each = function(f) {
      var axis, indices, p;
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/array.coffee:22");
      }
      if (this.empty()) {
        return;
      }
      p = this.offset;
      indices = (function() {
        var _i, _len, _ref, _results;
        _ref = this.shape;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          axis = _ref[_i];
          _results.push(0);
        }
        return _results;
      }).call(this);
      while (true) {
        f(this.data[p], indices);
        axis = this.shape.length - 1;
        while (axis >= 0 && indices[axis] + 1 === this.shape[axis]) {
          p -= indices[axis] * this.stride[axis];
          indices[axis--] = 0;
        }
        if (axis < 0) {
          break;
        }
        indices[axis]++;
        p += this.stride[axis];
      }
    };

    APLArray.prototype.each2 = function(a, f) {
      var axis, indices, p, q, _i, _ref;
      if (!(a instanceof APLArray)) {
        throw Error("\"assert a instanceof APLArray\" at src/array.coffee:38");
      }
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/array.coffee:39");
      }
      if (!(this.shape.length === a.shape.length)) {
        throw Error("\"assert @shape.length is a.shape.length\" at src/array.coffee:40");
      }
      for (axis = _i = 0, _ref = this.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; axis = 0 <= _ref ? ++_i : --_i) {
        if (!(this.shape[axis] === a.shape[axis])) {
          throw Error("\"assert @shape[axis] is a.shape[axis]\" at src/array.coffee:42");
        }
      }
      if (this.empty()) {
        return;
      }
      p = this.offset;
      q = a.offset;
      indices = (function() {
        var _j, _len, _ref1, _results;
        _ref1 = this.shape;
        _results = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          axis = _ref1[_j];
          _results.push(0);
        }
        return _results;
      }).call(this);
      while (true) {
        f(this.data[p], a.data[q], indices);
        axis = this.shape.length - 1;
        while (axis >= 0 && indices[axis] + 1 === this.shape[axis]) {
          p -= indices[axis] * this.stride[axis];
          q -= indices[axis] * a.stride[axis];
          indices[axis--] = 0;
        }
        if (axis < 0) {
          break;
        }
        indices[axis]++;
        p += this.stride[axis];
        q += a.stride[axis];
      }
    };

    APLArray.prototype.map = function(f) {
      var data;
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/array.coffee:61");
      }
      data = [];
      this.each(function(x, indices) {
        return data.push(f(x, indices));
      });
      return new APLArray(data, this.shape);
    };

    APLArray.prototype.map2 = function(a, f) {
      var data;
      if (!(a instanceof APLArray)) {
        throw Error("\"assert a instanceof APLArray\" at src/array.coffee:67");
      }
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/array.coffee:68");
      }
      data = [];
      this.each2(a, function(x, y, indices) {
        return data.push(f(x, y, indices));
      });
      return new APLArray(data, this.shape);
    };

    APLArray.prototype.toArray = function(limit) {
      var e, r;
      if (limit == null) {
        limit = Infinity;
      }
      r = [];
      try {
        this.each(function(x) {
          if (r.length >= limit) {
            throw 'break';
          }
          r.push(x);
        });
      } catch (_error) {
        e = _error;
        if (e !== 'break') {
          throw e;
        }
      }
      return r;
    };

    APLArray.prototype.toInt = function(start, end) {
      var r;
      if (start == null) {
        start = -Infinity;
      }
      if (end == null) {
        end = Infinity;
      }
      r = this.unwrap();
      if (typeof r !== 'number' || r !== ~~r || !((start <= r && r < end))) {
        return domainError();
      } else {
        return r;
      }
    };

    APLArray.prototype.toBool = function() {
      return this.toInt(0, 2);
    };

    APLArray.prototype.toSimpleString = function() {
      var a, x, _i, _len;
      if (this.shape.length > 1) {
        rankError();
      }
      if (typeof this.data === 'string') {
        if (this.shape.length === 0) {
          return this.data[this.offset];
        }
        if (this.shape[0] === 0) {
          return '';
        }
        if (this.stride[0] === 1) {
          return this.data.slice(this.offset, this.offset + this.shape[0]);
        }
        return this.toArray.join('');
      } else {
        a = this.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          if (typeof x !== 'string') {
            domainError();
          }
        }
        return a.join('');
      }
    };

    APLArray.prototype.isSingleton = function() {
      var n, _i, _len, _ref;
      _ref = this.shape;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (n !== 1) {
          return false;
        }
      }
      return true;
    };

    APLArray.prototype.isSimple = function() {
      return this.shape.length === 0 && !(this.data[this.offset] instanceof APLArray);
    };

    APLArray.prototype.unwrap = function() {
      if (prod(this.shape) === 1) {
        return this.data[this.offset];
      } else {
        return lengthError();
      }
    };

    APLArray.prototype.getPrototype = function() {
      if (this.empty() || typeof this.data[this.offset] !== 'string') {
        return 0;
      } else {
        return ' ';
      }
    };

    APLArray.prototype.toString = function() {
      return format(this).join('\n');
    };

    return APLArray;

  })();
  strideForShape = function(shape) {
    var i, r, tmp4, _i, _ref;
    if (!(shape instanceof Array)) {
      throw Error("\"assert shape instanceof Array\" at src/array.coffee:112");
    }
    if (shape.length === 0) {
      return [];
    }
    r = Array(shape.length);
    r[r.length - 1] = 1;
    for (i = _i = _ref = r.length - 2; _i >= 0; i = _i += -1) {
      if (!((tmp4 = shape[i]) === ~~tmp4 && (0) <= tmp4)) {
        throw Error("\"assert isInt shape[i], 0\" at src/array.coffee:117");
      }
      r[i] = r[i + 1] * shape[i + 1];
    }
    return r;
  };
  APLArray.zero = new APLArray([0], []);
  APLArray.one = new APLArray([1], []);
  APLArray.zilde = new APLArray([], [0]);
  APLArray.scalar = function(x) {
    return new APLArray([x], []);
  };
  APLArray.bool = [APLArray.zero, APLArray.one];
  complexify = function(x) {
    if (typeof x === 'number') {
      return new Complex(x, 0);
    } else if (x instanceof Complex) {
      return x;
    } else {
      return domainError();
    }
  };
  simplify = function(re, im) {
    if (im !== 0) {
      return new Complex(re, im);
    } else {
      return re;
    }
  };
  Complex = (function() {
    var acos, add, asin, atan, cosh, direction, divide, exp, firstquadrant, floor, gcd, iszero, itimes, log, multiply, negate, negitimes, pow, residue, sinh, sqrt, subtract, tanh;

    function Complex(re, im) {
      this.re = re;
      this.im = im != null ? im : 0;
      if (!(typeof this.re === 'number')) {
        throw Error("\"assert typeof @re is 'number'\" at src/complex.coffee:20");
      }
      if (!(typeof this.im === 'number')) {
        throw Error("\"assert typeof @im is 'number'\" at src/complex.coffee:21");
      }
      if (isNaN(this.re) || isNaN(this.im)) {
        domainError('NaN');
      }
    }

    Complex.prototype.toString = function() {
      return ("" + this.re + "J" + this.im).replace(/-|Infinity/g, '¯');
    };

    Complex.exp = exp = function(x) {
      var r;
      x = complexify(x);
      r = Math.exp(x.re);
      return simplify(r * Math.cos(x.im), r * Math.sin(x.im));
    };

    Complex.log = log = function(x) {
      if (typeof x === 'number' && x > 0) {
        return Math.log(x);
      } else {
        x = complexify(x);
        return simplify(Math.log(Math.sqrt(x.re * x.re + x.im * x.im)), direction(x));
      }
    };

    Complex.conjugate = function(x) {
      return new Complex(x.re, -x.im);
    };

    Complex.negate = negate = function(x) {
      return new Complex(-x.re, -x.im);
    };

    Complex.itimes = itimes = function(x) {
      x = complexify(x);
      return simplify(-x.im, x.re);
    };

    Complex.negitimes = negitimes = function(x) {
      x = complexify(x);
      return simplify(x.im, -x.re);
    };

    Complex.add = add = function(x, y) {
      x = complexify(x);
      y = complexify(y);
      return simplify(x.re + y.re, x.im + y.im);
    };

    Complex.subtract = subtract = function(x, y) {
      x = complexify(x);
      y = complexify(y);
      return simplify(x.re - y.re, x.im - y.im);
    };

    Complex.multiply = multiply = function(x, y) {
      x = complexify(x);
      y = complexify(y);
      return simplify(x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re);
    };

    Complex.divide = divide = function(x, y) {
      var d;
      x = complexify(x);
      y = complexify(y);
      d = y.re * y.re + y.im * y.im;
      return simplify((x.re * y.re + x.im * y.im) / d, (y.re * x.im - y.im * x.re) / d);
    };

    Complex.pow = pow = function(x, y) {
      var _ref;
      if ((typeof x === (_ref = typeof y) && _ref === 'number') && x >= 0) {
        return Math.pow(x, y);
      } else {
        return exp(multiply(y, log(x)));
      }
    };

    Complex.sqrt = sqrt = function(x) {
      if (typeof x === 'number' && x >= 0) {
        return Math.sqrt(x);
      } else {
        return pow(x, 0.5);
      }
    };

    Complex.magnitude = function(x) {
      return Math.sqrt(x.re * x.re + x.im * x.im);
    };

    Complex.direction = direction = function(x) {
      return Math.atan2(x.im, x.re);
    };

    Complex.sin = function(x) {
      return negitimes(sinh(itimes(x)));
    };

    Complex.cos = function(x) {
      return cosh(itimes(x));
    };

    Complex.tan = function(x) {
      return negitimes(tanh(itimes(x)));
    };

    Complex.asin = asin = function(x) {
      x = complexify(x);
      return negitimes(log(add(itimes(x), sqrt(subtract(1, pow(x, 2))))));
    };

    Complex.acos = acos = function(x) {
      var r;
      x = complexify(x);
      r = negitimes(log(add(x, sqrt(subtract(pow(x, 2), 1)))));
      if (r instanceof Complex && (r.re < 0 || (r.re === 0 && r.im < 0))) {
        return negate(r);
      } else {
        return r;
      }
    };

    Complex.atan = atan = function(x) {
      var ix;
      x = complexify(x);
      ix = itimes(x);
      return multiply(new Complex(0, .5), subtract(log(subtract(1, ix)), log(add(1, ix))));
    };

    Complex.sinh = sinh = function(x) {
      var a;
      a = exp(x);
      return multiply(0.5, subtract(a, divide(1, a)));
    };

    Complex.cosh = cosh = function(x) {
      var a;
      a = exp(x);
      return multiply(0.5, add(a, divide(1, a)));
    };

    Complex.tanh = tanh = function(x) {
      var a, b;
      a = exp(x);
      b = divide(1, a);
      return divide(subtract(a, b), add(a, b));
    };

    Complex.asinh = function(x) {
      return itimes(asin(negitimes(x)));
    };

    Complex.acosh = function(x) {
      var sign;
      x = complexify(x);
      sign = x.im > 0 || (x.im === 0 && x.re <= 1) ? 1 : -1;
      return multiply(new Complex(0, sign), acos(x));
    };

    Complex.atanh = function(x) {
      return itimes(atan(negitimes(x)));
    };

    Complex.floor = floor = function(x) {
      var i, im, r, re, _ref, _ref1;
      if (typeof x === 'number') {
        return Math.floor(x);
      } else {
        x = complexify(x);
        _ref = [Math.floor(x.re), Math.floor(x.im)], re = _ref[0], im = _ref[1];
        _ref1 = [x.re - re, x.im - im], r = _ref1[0], i = _ref1[1];
        if (r + i >= 1) {
          if (r >= i) {
            re++;
          } else {
            im++;
          }
        }
        return simplify(re, im);
      }
    };

    Complex.ceil = function(x) {
      var i, im, r, re, _ref, _ref1;
      if (typeof x === 'number') {
        return Math.ceil(x);
      } else {
        x = complexify(x);
        _ref = [Math.ceil(x.re), Math.ceil(x.im)], re = _ref[0], im = _ref[1];
        _ref1 = [re - x.re, im - x.im], r = _ref1[0], i = _ref1[1];
        if (r + i >= 1) {
          if (r >= i) {
            re--;
          } else {
            im--;
          }
        }
        return simplify(re, im);
      }
    };

    iszero = function(x) {
      return x === 0 || (x instanceof Complex && x.re === 0 && x.im === 0);
    };

    Complex.residue = residue = function(x, y) {
      var _ref;
      if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
        if (x === 0) {
          return y;
        } else {
          return y - x * Math.floor(y / x);
        }
      } else {
        if (iszero(x)) {
          return y;
        } else {
          return subtract(y, multiply(x, floor(divide(y, x))));
        }
      }
    };

    Complex.isint = function(x) {
      if (typeof x === 'number') {
        return x === Math.floor(x);
      } else {
        return (x.re === Math.floor(x.re)) && (x.im === Math.floor(x.im));
      }
    };

    firstquadrant = function(x) {
      if (typeof x === 'number') {
        return Math.abs(x);
      } else {
        if (x.re < 0) {
          x = negate(x);
        }
        if (x.im < 0) {
          x = itimes(x);
        }
        if (x.re === 0) {
          x = x.im;
        }
        return x;
      }
    };

    Complex.gcd = gcd = function(x, y) {
      var _ref, _ref1, _ref2;
      if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
        while (y) {
          _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];
        }
        return Math.abs(x);
      } else {
        while (!iszero(y)) {
          _ref2 = [y, residue(y, x)], x = _ref2[0], y = _ref2[1];
        }
        return firstquadrant(x);
      }
    };

    Complex.lcm = function(x, y) {
      var p;
      p = multiply(x, y);
      if (iszero(p)) {
        return p;
      } else {
        return divide(p, gcd(x, y));
      }
    };

    return Complex;

  })();
  LDC = 'LDC';
  VEC = 'VEC';
  GET = 'GET';
  SET = 'SET';
  MON = 'MON';
  DYA = 'DYA';
  LAM = 'LAM';
  RET = 'RET';
  POP = 'POP';
  SPL = 'SPL';
  JEQ = 'JEQ';
  EMB = 'EMB';
  λ = (function() {
    function λ(code, addr, env) {
      this.code = code;
      this.addr = addr;
      this.env = env;
    }

    λ.prototype.toFunction = function() {
      var _this = this;
      return function(x, y) {
        return vm({
          code: _this.code,
          env: _this.env.concat([[x, _this, y]]),
          pc: _this.addr
        });
      };
    };

    λ.prototype.toString = function() {
      return 'λ';
    };

    return λ;

  })();
  vm = function(_arg) {
    var a, code, env, f, frame, n, pc, size, stack, w, x, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    code = _arg.code, env = _arg.env, stack = _arg.stack, pc = _arg.pc;
    if (!(code instanceof Array)) {
      throw Error("\"assert code instanceof Array\" at src/vm.coffee:20");
    }
    if (!(env instanceof Array)) {
      throw Error("\"assert env instanceof Array\" at src/vm.coffee:21");
    }
    for (_i = 0, _len = env.length; _i < _len; _i++) {
      frame = env[_i];
      if (!(frame instanceof Array)) {
        throw Error("\"for frame in env then assert frame instanceof Array\" at src/vm.coffee:22");
      }
    }
    if (stack == null) {
      stack = [];
    }
    if (pc == null) {
      pc = 0;
    }
    while (true) {
      switch (code[pc++]) {
        case LDC:
          stack.push(code[pc++]);
          break;
        case VEC:
          a = [];
          _ref = stack.splice(stack.length - code[pc++]);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            x = _ref[_j];
            a.push(x.isSimple() ? x.unwrap() : x);
          }
          stack.push(new APLArray(a));
          break;
        case GET:
          stack.push(env[code[pc++]][code[pc++]]);
          break;
        case SET:
          env[code[pc++]][code[pc++]] = stack[stack.length - 1];
          break;
        case MON:
          _ref1 = stack.splice(-2), w = _ref1[0], f = _ref1[1];
          if (typeof f === 'function') {
            if (w instanceof λ) {
              w = w.toFunction();
            }
            if (f.cps) {
              f(w, void 0, void 0, function(r) {
                stack.push(r);
                vm({
                  code: code,
                  env: env,
                  stack: stack,
                  pc: pc
                });
              });
              return;
            } else {
              stack.push(f(w));
            }
          } else {
            stack.push(code, pc, env);
            code = f.code;
            pc = f.addr;
            env = f.env.concat([[w, f, null]]);
          }
          break;
        case DYA:
          _ref2 = stack.splice(-3), w = _ref2[0], f = _ref2[1], a = _ref2[2];
          if (typeof f === 'function') {
            if (w instanceof λ) {
              w = w.toFunction();
            }
            if (a instanceof λ) {
              a = a.toFunction();
            }
            if (f.cps) {
              f(w, a, void 0, function(r) {
                stack.push(r);
                vm({
                  code: code,
                  env: env,
                  stack: stack,
                  pc: pc
                });
              });
              return;
            } else {
              stack.push(f(w, a));
            }
          } else {
            stack.push(code, pc, env);
            code = f.code;
            pc = f.addr;
            env = f.env.concat([[w, f, a]]);
          }
          break;
        case LAM:
          size = code[pc++];
          stack.push(new λ(code, pc, env));
          pc += size;
          break;
        case RET:
          if (stack.length === 1) {
            return stack[0];
          }
          _ref3 = stack.splice(-4, 3), code = _ref3[0], pc = _ref3[1], env = _ref3[2];
          break;
        case POP:
          stack.pop();
          break;
        case SPL:
          n = code[pc++];
          a = stack[stack.length - 1].toArray().reverse();
          a = (function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = a.length; _k < _len2; _k++) {
              x = a[_k];
              _results.push(x instanceof APLArray ? x : new APLArray([x], []));
            }
            return _results;
          })();
          if (a.length === 1) {
            a = repeat(a, n);
          } else if (a.length !== n) {
            lengthError();
          }
          stack.push.apply(stack, a);
          break;
        case JEQ:
          n = code[pc++];
          if (!stack[stack.length - 1].toBool()) {
            pc += n;
          }
          break;
        case EMB:
          frame = env[env.length - 1];
          stack.push(code[pc++](frame[0], frame[2]));
          break;
        default:
          aplError('Unrecognized instruction: ' + code[pc - 1] + ', pc:' + pc);
      }
    }
  };
  tokenDefs = [['-', /^(?:[ \t]+|[⍝\#].*)+/], ['newline', /^[\n\r]+/], ['separator', /^[◇⋄]/], ['number', /^¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯)(?:j¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯))?/i], ['string', /^(?:'(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*")+/], ['', /^[\(\)\[\]\{\}:;←]/], ['embedded', /^«[^»]*»/], ['symbol', /^(?:⎕?[a-z_][0-9a-z_]*|⍺⍺|⍵⍵|∇∇|[^¯'":«»])/i]];
  tokenize = function(s, opts) {
    var a, col, line, m, re, stack, startCol, startLine, t, tokens, type, _i, _len, _ref;
    if (opts == null) {
      opts = {};
    }
    line = col = 1;
    stack = ['{'];
    tokens = [];
    while (s) {
      startLine = line;
      startCol = col;
      type = null;
      for (_i = 0, _len = tokenDefs.length; _i < _len; _i++) {
        _ref = tokenDefs[_i], t = _ref[0], re = _ref[1];
        if (!(m = s.match(re))) {
          continue;
        }
        type = t || m[0];
        break;
      }
      if (!type) {
        syntaxError('Unrecognized token', {
          file: opts.file,
          line: line,
          col: col,
          s: opts.s
        });
      }
      a = m[0].split('\n');
      line += a.length - 1;
      col = (a.length === 1 ? col : 1) + a[a.length - 1].length;
      s = s.slice(m[0].length);
      if (type !== '-') {
        if (type === '(' || type === '[' || type === '{') {
          stack.push(type);
        } else if (type === ')' || type === ']' || type === '}') {
          stack.pop();
        }
        if (type !== 'newline' || stack[stack.length - 1] === '{') {
          tokens.push({
            type: type,
            startLine: startLine,
            startCol: startCol,
            value: m[0],
            endLine: line,
            endCol: col
          });
        }
      }
    }
    tokens.push({
      type: 'eof',
      value: '',
      startLine: line,
      startCol: col,
      endLine: line,
      endCol: col
    });
    return tokens;
  };
  parse = function(aplCode, opts) {
    var i, parseBody, parseExpr, parserError, result, token, tokens;
    if (opts == null) {
      opts = {};
    }
    tokens = tokenize(aplCode);
    i = 0;
    token = tokens[i++];
    parserError = function(message) {
      return syntaxError(message, {
        file: opts.file,
        line: token.startLine,
        col: token.startCol,
        aplCode: aplCode
      });
    };
    parseBody = function() {
      var body, expr, _ref, _ref1, _ref2, _ref3;
      body = ['body'];
      while (true) {
        if ((_ref = token.type) === 'eof' || _ref === '}' || _ref === ';') {
          return body;
        }
        while (((_ref1 = token.type) === "separator" || _ref1 === "newline" ? token = tokens[i++] : void 0)) {}
        if ((_ref2 = token.type) === 'eof' || _ref2 === '}' || _ref2 === ';') {
          return body;
        }
        expr = parseExpr();
        if (((_ref3 = token.type) === ":" ? token = tokens[i++] : void 0)) {
          expr = ['guard', expr, parseExpr()];
        }
        body.push(expr);
      }
    };
    parseExpr = function() {
      var expr, item, t, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      expr = ['expr'];
      while (true) {
        t = token;
        if (((_ref = token.type) === "number" || _ref === "string" || _ref === "symbol" || _ref === "embedded" ? token = tokens[i++] : void 0)) {
          item = [t.type, t.value];
        } else if (((_ref1 = token.type) === "(" ? token = tokens[i++] : void 0)) {
          item = parseExpr();
          if (token.type === ')') {
            token = tokens[i++];
          } else {
            parserError("Expected token of type '" + ')' + "' but got '" + token.type + "'");
          }
        } else if (((_ref2 = token.type) === "{" ? token = tokens[i++] : void 0)) {
          item = ['lambda', parseBody()];
          while (((_ref3 = token.type) === ";" ? token = tokens[i++] : void 0)) {
            item.push(parseBody());
          }
          if (token.type === '}') {
            token = tokens[i++];
          } else {
            parserError("Expected token of type '" + '}' + "' but got '" + token.type + "'");
          }
        } else {
          parserError("Encountered unexpected token of type '" + token.type + "'");
        }
        if (((_ref4 = token.type) === "[" ? token = tokens[i++] : void 0)) {
          item = ['index', item];
          while (true) {
            if (((_ref5 = token.type) === ";" ? token = tokens[i++] : void 0)) {
              item.push(null);
            } else if (token.type === ']') {
              item.push(null);
              break;
            } else {
              item.push(parseExpr());
              if (token.type === ']') {
                break;
              } else {
                if (token.type === ';') {
                  token = tokens[i++];
                } else {
                  parserError("Expected token of type '" + ';' + "' but got '" + token.type + "'");
                }
              }
            }
          }
          if (token.type === ']') {
            token = tokens[i++];
          } else {
            parserError("Expected token of type '" + ']' + "' but got '" + token.type + "'");
          }
        }
        if (((_ref6 = token.type) === "←" ? token = tokens[i++] : void 0)) {
          return expr.concat([['assign', item, parseExpr()]]);
        }
        expr.push(item);
        if (_ref7 = token.type, __indexOf.call(') ] } : ; separator newline eof'.split(' '), _ref7) >= 0) {
          return expr;
        }
      }
    };
    result = parseBody();
    if (token.type === 'eof') {
      token = tokens[i++];
    } else {
      parserError("Expected token of type '" + 'eof' + "' but got '" + token.type + "'");
    }
    return result;
  };
  vocabulary = {};
  addVocabulary = function(h) {
    var alias, k, v, _i, _len, _ref, _ref1;
    for (k in h) {
      v = h[k];
      vocabulary[k] = v;
      _ref1 = (_ref = v != null ? v.aliases : void 0) != null ? _ref : [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        alias = _ref1[_i];
        vocabulary[alias] = v;
      }
    }
  };
  pervasive = function(_arg) {
    var dyad, monad, pervadeDyadic, pervadeMonadic;
    monad = _arg.monad, dyad = _arg.dyad;
    pervadeMonadic = monad ? function(x) {
      var r;
      if (x instanceof APLArray) {
        return x.map(pervadeMonadic);
      } else {
        r = monad(x);
        if (typeof r === 'number' && isNaN(r)) {
          domainError('NaN');
        }
        return r;
      }
    } : nonceError;
    pervadeDyadic = dyad ? function(x, y) {
      var axis, r, tx, ty, xi, yi, _i, _ref;
      tx = x instanceof APLArray ? (x.isSingleton() ? 1 : 2) : 0;
      ty = y instanceof APLArray ? (y.isSingleton() ? 1 : 2) : 0;
      switch (16 * tx + ty) {
        case 0x00:
          r = dyad(x, y);
          if (typeof r === 'number' && isNaN(r)) {
            domainError('NaN');
          }
          return r;
        case 0x01:
        case 0x02:
          return y.map(function(yi) {
            return pervadeDyadic(x, yi);
          });
        case 0x10:
        case 0x20:
          return x.map(function(xi) {
            return pervadeDyadic(xi, y);
          });
        case 0x12:
          xi = x.data[x.offset];
          return y.map(function(yi) {
            return pervadeDyadic(xi, yi);
          });
        case 0x21:
        case 0x11:
          yi = y.data[y.offset];
          return x.map(function(xi) {
            return pervadeDyadic(xi, yi);
          });
        case 0x22:
          if (x.shape.length !== y.shape.length) {
            rankError();
          }
          for (axis = _i = 0, _ref = x.shape.length; _i < _ref; axis = _i += 1) {
            if (x.shape[axis] !== y.shape[axis]) {
              lengthError();
            }
          }
          return x.map2(y, pervadeDyadic);
        default:
          if (!(0)) {
            throw Error("\"else assert 0\" at src/vocabulary/vhelpers.coffee:40");
          }
      }
    } : nonceError;
    return function(omega, alpha) {
      if (!(omega instanceof APLArray)) {
        throw Error("\"assert omega instanceof APLArray\" at src/vocabulary/vhelpers.coffee:44");
      }
      if (!(alpha instanceof APLArray || (alpha == null))) {
        throw Error("\"assert alpha instanceof APLArray or not alpha?\" at src/vocabulary/vhelpers.coffee:45");
      }
      return (alpha != null ? pervadeDyadic : pervadeMonadic)(omega, alpha);
    };
  };
  real = function(f) {
    return function(x, y, axis) {
      if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
        return f(x, y, axis);
      } else {
        return domainError();
      }
    };
  };
  numeric = function(f, g) {
    return function(x, y, axis) {
      if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
        return f(x, y, axis);
      } else {
        x = complexify(x);
        if (y != null) {
          y = complexify(y);
        }
        return g(x, y, axis);
      }
    };
  };
  match = function(x, y) {
    var axis, r, _i, _ref;
    if (x instanceof APLArray) {
      if (!(y instanceof APLArray)) {
        return false;
      } else {
        if (x.shape.length !== y.shape.length) {
          return false;
        }
        for (axis = _i = 0, _ref = x.shape.length; _i < _ref; axis = _i += 1) {
          if (x.shape[axis] !== y.shape[axis]) {
            return false;
          }
        }
        r = true;
        x.each2(y, function(xi, yi) {
          if (!match(xi, yi)) {
            return r = false;
          }
        });
        return r;
      }
    } else {
      if (y instanceof APLArray) {
        return false;
      } else {
        if (x instanceof Complex && y instanceof Complex) {
          return x.re === y.re && x.im === y.im;
        } else {
          return x === y;
        }
      }
    }
  };
  numApprox = function(x, y) {
    return x === y || Math.abs(x - y) < 1e-11;
  };
  approx = function(x, y) {
    var axis, r, _i, _ref;
    if (x instanceof APLArray) {
      if (!(y instanceof APLArray)) {
        return false;
      } else {
        if (x.shape.length !== y.shape.length) {
          return false;
        }
        for (axis = _i = 0, _ref = x.shape.length; _i < _ref; axis = _i += 1) {
          if (x.shape[axis] !== y.shape[axis]) {
            return false;
          }
        }
        r = true;
        x.each2(y, function(xi, yi) {
          if (!approx(xi, yi)) {
            return r = false;
          }
        });
        return r;
      }
    } else {
      if (y instanceof APLArray) {
        return false;
      } else if (!((x != null) && (y != null))) {
        return false;
      } else {
        if (typeof x === 'number') {
          x = new Complex(x);
        }
        if (typeof y === 'number') {
          y = new Complex(y);
        }
        if (x instanceof Complex) {
          return y instanceof Complex && numApprox(x.re, y.re) && numApprox(x.im, y.im);
        } else {
          return x === y;
        }
      }
    }
  };
  bool = function(x) {
    if (x !== 0 && x !== 1) {
      return domainError();
    } else {
      return x;
    }
  };
  getAxisList = function(axes, rank) {
    var a, i, tmp5, tmp6, tmp7, x, _i, _len, _ref, _ref1;
    if (!((tmp5 = (rank)) === ~~tmp5 && (0) <= tmp5)) {
      throw Error("\"assert isInt rank, 0\" at src/vocabulary/vhelpers.coffee:111");
    }
    if (axes == null) {
      return [];
    }
    if (!(axes instanceof APLArray)) {
      throw Error("\"assert axes instanceof APLArray\" at src/vocabulary/vhelpers.coffee:113");
    }
    if (axes.shape.length !== 1 || axes.shape[0] !== 1) {
      syntaxError();
    }
    a = axes.unwrap();
    if (a instanceof APLArray) {
      a = a.toArray();
      for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
        x = a[i];
        if (!((tmp6 = (x)) === ~~tmp6 && ((0) <= (_ref = tmp6) && _ref < (rank)))) {
          domainError();
        }
        if (__indexOf.call(a.slice(0, i), x) >= 0) {
          domainError('Non-unique axes');
        }
      }
      return a;
    } else if ((tmp7 = (a)) === ~~tmp7 && ((0) <= (_ref1 = tmp7) && _ref1 < (rank))) {
      return [a];
    } else {
      return domainError();
    }
  };
  withIdentity = function(x, f) {
    f.identity = x instanceof APLArray ? x : APLArray.scalar(x);
    return f;
  };
  adverb = function(f) {
    f.isAdverb = true;
    return f;
  };
  conjunction = function(f) {
    f.isConjunction = true;
    return f;
  };
  cps = function(f) {
    f.cps = true;
    return f;
  };
  aka = function(aliases, f) {
    if (typeof aliases === 'string') {
      aliases = [aliases];
    } else {
      if (!(aliases instanceof Array)) {
        throw Error("\"assert aliases instanceof Array\" at src/vocabulary/vhelpers.coffee:139");
      }
    }
    f.aliases = aliases;
    return f;
  };
  addVocabulary({
    '+': withIdentity(0, pervasive({
      monad: numeric((function(x) {
        return x;
      }), Complex.conjugate),
      dyad: numeric((function(y, x) {
        return x + y;
      }), function(y, x) {
        return Complex.add(x, y);
      })
    })),
    '-': aka('−', withIdentity(0, pervasive({
      monad: numeric((function(x) {
        return -x;
      }), Complex.negate),
      dyad: numeric((function(y, x) {
        return x - y;
      }), function(y, x) {
        return Complex.subtract(x, y);
      })
    }))),
    '×': withIdentity(1, pervasive({
      monad: numeric((function(x) {
        return (x > 0) - (x < 0);
      }), function(x) {
        var d;
        d = Math.sqrt(x.re * x.re + x.im * x.im);
        return simplify(x.re / d, x.im / d);
      }),
      dyad: numeric((function(y, x) {
        return x * y;
      }), function(y, x) {
        return Complex.multiply(x, y);
      })
    })),
    '÷': withIdentity(1, pervasive({
      monad: numeric((function(x) {
        return 1 / x;
      }), function(x) {
        var d;
        d = x.re * x.re + x.im * x.im;
        return simplify(x.re / d, -x.im / d);
      }),
      dyad: numeric((function(y, x) {
        return x / y;
      }), function(y, x) {
        return Complex.divide(x, y);
      })
    })),
    '*': aka('⋆', withIdentity(1, pervasive({
      monad: exp = numeric(Math.exp, Complex.exp),
      dyad: function(y, x) {
        return Complex.pow(x, y);
      }
    }))),
    '⍟': pervasive({
      monad: Complex.log,
      dyad: function(y, x) {
        var _ref;
        if ((typeof x === (_ref = typeof y) && _ref === 'number') && x > 0 && y > 0) {
          return Math.log(y) / Math.log(x);
        } else {
          return Complex.divide(Complex.log(y), Complex.log(x));
        }
      }
    }),
    '|': aka('∣', withIdentity(0, pervasive({
      monad: numeric((function(x) {
        return Math.abs(x);
      }), Complex.magnitude),
      dyad: function(y, x) {
        return Complex.residue(x, y);
      }
    })))
  });
  addVocabulary({
    '\\': adverb(function(omega, alpha, axis) {
      if (typeof omega === 'function') {
        return scan(omega, void 0, axis);
      } else {
        return expand(omega, alpha, axis);
      }
    }),
    '⍀': adverb(function(omega, alpha, axis) {
      if (axis == null) {
        axis = APLArray.zero;
      }
      if (typeof omega === 'function') {
        return scan(omega, void 0, axis);
      } else {
        return expand(omega, alpha, axis);
      }
    })
  });
  scan = function(f, g, axis) {
    if (!(typeof g === 'undefined')) {
      throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/backslash.coffee:44");
    }
    return function(omega, alpha) {
      if (!(alpha == null)) {
        throw Error("\"assert not alpha?\" at src/vocabulary/backslash.coffee:46");
      }
      if (omega.shape.length === 0) {
        return omega;
      }
      axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
      return omega.map(function(x, indices) {
        var a, index, j, p, y, _i, _j, _len, _ref;
        p = omega.offset;
        for (a = _i = 0, _len = indices.length; _i < _len; a = ++_i) {
          index = indices[a];
          p += index * omega.stride[a];
        }
        if (!(x instanceof APLArray)) {
          x = APLArray.scalar(x);
        }
        for (j = _j = 0, _ref = indices[axis]; _j < _ref; j = _j += 1) {
          p -= omega.stride[axis];
          y = omega.data[p];
          if (!(y instanceof APLArray)) {
            y = APLArray.scalar(y);
          }
          x = f(x, y);
        }
        if (x.shape.length === 0) {
          x = x.unwrap();
        }
        return x;
      });
    };
  };
  expand = function(omega, alpha, axis) {
    var a, b, data, filler, i, indices, p, shape, tmp8, x, _i, _len, _ref;
    if (omega.shape.length === 0) {
      nonceError('Expand of scalar not implemented');
    }
    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
    if (alpha.shape.length > 1) {
      rankError();
    }
    a = alpha.toArray();
    shape = omega.shape.slice(0);
    shape[axis] = a.length;
    b = [];
    i = 0;
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      if (!((tmp8 = (x)) === ~~tmp8 && ((0) <= (_ref = tmp8) && _ref < (2)))) {
        domainError();
      }
      b.push(x > 0 ? i++ : null);
    }
    if (i !== omega.shape[axis]) {
      lengthError();
    }
    data = [];
    if (shape[axis] !== 0 && !omega.empty()) {
      filler = omega.getPrototype();
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
        data.push(x);
        i = shape.length - 1;
        while (i >= 0 && indices[i] + 1 === shape[i]) {
          if (i !== axis) {
            p -= omega.stride[i] * indices[i];
          }
          indices[i--] = 0;
        }
        if (i < 0) {
          break;
        }
        if (i !== axis) {
          p += omega.stride[i];
        }
        indices[i]++;
      }
    }
    return new APLArray(data, shape);
  };
  addVocabulary({
    '○': pervasive({
      monad: numeric((function(x) {
        return Math.PI * x;
      }), function(x) {
        return new Complex(Math.PI * x.re, Math.PI * x.im);
      }),
      dyad: function(x, i) {
        var a, b, t;
        if (typeof x === 'number') {
          switch (i) {
            case -12:
              return Complex.exp(simplify(0, x));
            case -11:
              return simplify(0, x);
            case -10:
              return x;
            case -9:
              return x;
            case -8:
              return simplify(0, -Math.sqrt(1 + x * x));
            case -7:
              return Complex.atanh(x);
            case -6:
              return Complex.acosh(x);
            case -5:
              return Complex.asinh(x);
            case -4:
              t = Complex.sqrt(x * x - 1);
              if (x < -1) {
                return -t;
              } else {
                return t;
              }
              break;
            case -3:
              return Complex.atan(x);
            case -2:
              return Complex.acos(x);
            case -1:
              return Complex.asin(x);
            case 0:
              return Complex.sqrt(1 - x * x);
            case 1:
              return Math.sin(x);
            case 2:
              return Math.cos(x);
            case 3:
              return Math.tan(x);
            case 4:
              return Math.sqrt(1 + x * x);
            case 5:
              a = Math.exp(x);
              b = 1 / a;
              return 0.5 * (a - b);
            case 6:
              a = Math.exp(x);
              b = 1 / a;
              return 0.5 * (a + b);
            case 7:
              a = Math.exp(x);
              b = 1 / a;
              return (a - b) / (a + b);
            case 8:
              return Complex.sqrt(-1 - x * x);
            case 9:
              return x;
            case 10:
              return Math.abs(x);
            case 11:
              return 0;
            case 12:
              return 0;
            default:
              return domainError('Unknown circular or hyperbolic function ' + i);
          }
        } else if (x instanceof Complex) {
          switch (i) {
            case -12:
              return Complex.exp(simplify(-x.im, x.re));
            case -11:
              return Complex.itimes(x);
            case -10:
              return Complex.conjugate(x);
            case -9:
              return x;
            case -8:
              t = Complex.subtract(-1, Complex.multiply(x, x));
              return Complex.negate(Complex.sqrt(t));
            case -7:
              return Complex.atanh(x);
            case -6:
              return Complex.acosh(x);
            case -5:
              return Complex.asinh(x);
            case -4:
              if (x.re === -1 && x.im === 0) {
                return 0;
              } else {
                a = Complex.add(x, 1);
                b = Complex.subtract(x, 1);
                return Complex.multiply(a, Complex.sqrt(Complex.divide(b, a)));
              }
              break;
            case -3:
              return Complex.atan(x);
            case -2:
              return Complex.acos(x);
            case -1:
              return Complex.asin(x);
            case 0:
              return Complex.sqrt(Complex.subtract(1, Complex.multiply(x, x)));
            case 1:
              return Complex.sin(x);
            case 2:
              return Complex.cos(x);
            case 3:
              return Complex.tan(x);
            case 4:
              return Complex.sqrt(Complex.add(1, Complex.multiply(x, x)));
            case 5:
              return Complex.sinh(x);
            case 6:
              return Complex.cosh(x);
            case 7:
              return Complex.tanh(x);
            case 8:
              return Complex.sqrt(Complex.subtract(-1, Complex.multiply(x, x)));
            case 9:
              return x.re;
            case 10:
              return Complex.magnitude(x);
            case 11:
              return x.im;
            case 12:
              return Complex.direction(x);
            default:
              return domainError('Unknown circular or hyperbolic function ' + i);
          }
        } else {
          return domainError();
        }
      }
    })
  });
  addVocabulary({
    ',': function(omega, alpha, axis) {
      var a, data, i, nAxes, p, pIndices, q, r, rStride, s, shape, stride, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp9, _i, _j, _ref, _ref1;
      if (alpha) {
        nAxes = Math.max(alpha.shape.length, omega.shape.length);
        if (axis) {
          axis = axis.unwrap();
          if (typeof axis !== 'number') {
            domainError();
          }
          if (nAxes && !((0 <= axis && axis < nAxes))) {
            rankError();
          }
        } else {
          axis = nAxes - 1;
        }
        if (alpha.shape.length === 0 && omega.shape.length === 0) {
          return new APLArray([alpha.unwrap(), omega.unwrap()]);
        } else if (alpha.shape.length === 0) {
          s = omega.shape.slice(0);
          if ((tmp9 = (axis)) === ~~tmp9) {
            s[axis] = 1;
          }
          alpha = new APLArray([alpha.unwrap()], s, repeat([0], omega.shape.length));
        } else if (omega.shape.length === 0) {
          s = alpha.shape.slice(0);
          if ((tmp10 = (axis)) === ~~tmp10) {
            s[axis] = 1;
          }
          omega = new APLArray([omega.unwrap()], s, repeat([0], alpha.shape.length));
        } else if (alpha.shape.length + 1 === omega.shape.length) {
          if (!((tmp11 = (axis)) === ~~tmp11)) {
            rankError();
          }
          shape = alpha.shape.slice(0);
          shape.splice(axis, 0, 1);
          stride = alpha.stride.slice(0);
          stride.splice(axis, 0, 0);
          alpha = new APLArray(alpha.data, shape, stride, alpha.offset);
        } else if (alpha.shape.length === omega.shape.length + 1) {
          if (!((tmp12 = (axis)) === ~~tmp12)) {
            rankError();
          }
          shape = omega.shape.slice(0);
          shape.splice(axis, 0, 1);
          stride = omega.stride.slice(0);
          stride.splice(axis, 0, 0);
          omega = new APLArray(omega.data, shape, stride, omega.offset);
        } else if (alpha.shape.length !== omega.shape.length) {
          rankError();
        }
        if (!(alpha.shape.length === omega.shape.length)) {
          throw Error("\"assert alpha.shape.length is omega.shape.length\" at src/vocabulary/comma.coffee:59");
        }
        for (i = _i = 0, _ref = alpha.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (i !== axis && alpha.shape[i] !== omega.shape[i]) {
            lengthError();
          }
        }
        shape = alpha.shape.slice(0);
        if ((tmp13 = (axis)) === ~~tmp13) {
          shape[axis] += omega.shape[axis];
        } else {
          shape.splice(Math.ceil(axis), 0, 2);
        }
        data = Array(prod(shape));
        stride = Array(shape.length);
        stride[shape.length - 1] = 1;
        for (i = _j = _ref1 = shape.length - 2; _j >= 0; i = _j += -1) {
          stride[i] = stride[i + 1] * shape[i + 1];
        }
        if ((tmp14 = (axis)) === ~~tmp14) {
          rStride = stride;
        } else {
          rStride = stride.slice(0);
          rStride.splice(Math.ceil(axis), 1);
        }
        if (!alpha.empty()) {
          r = 0;
          p = alpha.offset;
          pIndices = repeat([0], alpha.shape.length);
          while (true) {
            data[r] = alpha.data[p];
            a = pIndices.length - 1;
            while (a >= 0 && pIndices[a] + 1 === alpha.shape[a]) {
              p -= pIndices[a] * alpha.stride[a];
              r -= pIndices[a] * rStride[a];
              pIndices[a--] = 0;
            }
            if (a < 0) {
              break;
            }
            p += alpha.stride[a];
            r += rStride[a];
            pIndices[a]++;
          }
        }
        if (!omega.empty()) {
          r = (tmp15 = (axis)) === ~~tmp15 ? stride[axis] * alpha.shape[axis] : stride[Math.ceil(axis)];
          q = omega.offset;
          pIndices = repeat([0], omega.shape.length);
          while (true) {
            data[r] = omega.data[q];
            a = pIndices.length - 1;
            while (a >= 0 && pIndices[a] + 1 === omega.shape[a]) {
              q -= pIndices[a] * omega.stride[a];
              r -= pIndices[a] * rStride[a];
              pIndices[a--] = 0;
            }
            if (a < 0) {
              break;
            }
            q += omega.stride[a];
            r += rStride[a];
            pIndices[a]++;
          }
        }
        return new APLArray(data, shape, stride);
      } else {
        data = [];
        omega.each(function(x) {
          return data.push(x);
        });
        return new APLArray(data);
      }
    }
  });
  addVocabulary({
    '=': withIdentity(1, pervasive({
      dyad: eq = function(y, x) {
        if (x instanceof Complex && y instanceof Complex) {
          return +(x.re === y.re && x.im === y.im);
        } else {
          return +(x === y);
        }
      }
    })),
    '≠': withIdentity(0, pervasive({
      dyad: function(y, x) {
        return 1 - eq(y, x);
      }
    })),
    '<': withIdentity(0, pervasive({
      dyad: real(function(y, x) {
        return +(x < y);
      })
    })),
    '>': withIdentity(0, pervasive({
      dyad: real(function(y, x) {
        return +(x > y);
      })
    })),
    '≤': withIdentity(1, pervasive({
      dyad: real(function(y, x) {
        return +(x <= y);
      })
    })),
    '≥': withIdentity(1, pervasive({
      dyad: real(function(y, x) {
        return +(x >= y);
      })
    })),
    '≡': function(omega, alpha) {
      if (alpha) {
        return APLArray.bool[+match(omega, alpha)];
      } else {
        return new APLArray([depthOf(omega)], []);
      }
    }
  });
  depthOf = function(x) {
    var r;
    if (x instanceof APLArray) {
      if (x.shape.length === 0 && !(x.data[0] instanceof APLArray)) {
        return 0;
      }
      r = 0;
      x.each(function(y) {
        return r = Math.max(r, depthOf(y));
      });
      return r + 1;
    } else {
      return 0;
    }
  };
  addVocabulary({
    '∘': conjunction(function(g, f) {
      if (typeof f === 'function') {
        if (typeof g === 'function') {
          return function(omega, alpha) {
            return f(g(omega), alpha);
          };
        } else {
          return function(omega, alpha) {
            if (!(alpha == null)) {
              throw Error("\"assert not alpha?\" at src/vocabulary/compose.coffee:20");
            }
            return f(g, omega);
          };
        }
      } else {
        if (!(typeof g === 'function')) {
          throw Error("\"assert typeof g is 'function'\" at src/vocabulary/compose.coffee:23");
        }
        return function(omega, alpha) {
          if (!(alpha == null)) {
            throw Error("\"assert not alpha?\" at src/vocabulary/compose.coffee:25");
          }
          return g(omega, f);
        };
      }
    })
  });
  addVocabulary({
    '∪': function(omega, alpha) {
      var a, data, _i, _len, _ref;
      if (alpha) {
        data = [];
        _ref = [alpha, omega];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          a = _ref[_i];
          if (a.shape.length > 1) {
            rankError();
          }
          a.each(function(x) {
            if (!contains(data, x)) {
              return data.push(x);
            }
          });
        }
        return new APLArray(data);
      } else {
        data = [];
        omega.each(function(x) {
          if (!contains(data, x)) {
            return data.push(x);
          }
        });
        return new APLArray(data);
      }
    },
    '∩': function(omega, alpha) {
      var b, data, x, _i, _len, _ref;
      if (alpha) {
        data = [];
        b = omega.toArray();
        _ref = alpha.toArray();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          if (contains(b, x)) {
            data.push(x);
          }
        }
        return new APLArray(data);
      } else {
        return nonceError();
      }
    }
  });
  contains = function(a, x) {
    var y, _i, _len;
    if (!(a instanceof Array)) {
      throw Error("\"assert a instanceof Array\" at src/vocabulary/cupcap.coffee:57");
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      y = a[_i];
      if (match(x, y)) {
        return true;
      }
    }
    return false;
  };
  addVocabulary({
    '⊥': function(omega, alpha) {
      var a, b, data, firstDimB, i, j, k, lastDimA, x, y, z, _i, _j, _k, _ref, _ref1, _ref2;
      if (!(alpha)) {
        throw Error("\"assert alpha\" at src/vocabulary/decode.coffee:53");
      }
      if (alpha.shape.length === 0) {
        alpha = new APLArray([alpha.unwrap()]);
      }
      if (omega.shape.length === 0) {
        omega = new APLArray([omega.unwrap()]);
      }
      lastDimA = alpha.shape[alpha.shape.length - 1];
      firstDimB = omega.shape[0];
      if (lastDimA !== 1 && firstDimB !== 1 && lastDimA !== firstDimB) {
        lengthError();
      }
      a = alpha.toArray();
      b = omega.toArray();
      data = [];
      for (i = _i = 0, _ref = a.length / lastDimA; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = b.length / firstDimB; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          x = a.slice(i * lastDimA, (i + 1) * lastDimA);
          y = (function() {
            var _k, _results;
            _results = [];
            for (k = _k = 0; 0 <= firstDimB ? _k < firstDimB : _k > firstDimB; k = 0 <= firstDimB ? ++_k : --_k) {
              _results.push(b[j + k * (b.length / firstDimB)]);
            }
            return _results;
          })();
          if (x.length === 1) {
            x = (function() {
              var _k, _ref2, _results;
              _results = [];
              for (_k = 0, _ref2 = y.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
                _results.push(x[0]);
              }
              return _results;
            })();
          }
          if (y.length === 1) {
            y = (function() {
              var _k, _ref2, _results;
              _results = [];
              for (_k = 0, _ref2 = x.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
                _results.push(y[0]);
              }
              return _results;
            })();
          }
          z = y[0];
          for (k = _k = 1, _ref2 = y.length; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 1 <= _ref2 ? ++_k : --_k) {
            z = z * x[k] + y[k];
          }
          data.push(z);
        }
      }
      return new APLArray(data, alpha.shape.slice(0, -1).concat(omega.shape.slice(1)));
    }
  });
  addVocabulary({
    '.': conjunction(function(g, f) {
      if (f === vocabulary['∘']) {
        return outerProduct(g);
      } else {
        return innerProduct(g, f);
      }
    })
  });
  outerProduct = function(f) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/dot.coffee:39");
    }
    return function(omega, alpha) {
      var a, b, data, x, y, z, _i, _j, _len, _len1;
      if (!alpha) {
        syntaxError('Adverb ∘. (Outer product) can be applied to dyadic verbs only');
      }
      a = alpha.toArray();
      b = omega.toArray();
      data = [];
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
          y = b[_j];
          if (!(x instanceof APLArray)) {
            x = APLArray.scalar(x);
          }
          if (!(y instanceof APLArray)) {
            y = APLArray.scalar(y);
          }
          z = f(y, x);
          if (z.shape.length === 0) {
            z = z.unwrap();
          }
          data.push(z);
        }
      }
      return new APLArray(data, alpha.shape.concat(omega.shape));
    };
  };
  innerProduct = function(g, f) {
    var F, G, each, enclose;
    each = vocabulary['¨'];
    enclose = vocabulary['⊂'];
    F = each(reduce(f));
    G = outerProduct(g);
    return function(omega, alpha) {
      if (alpha.shape.length === 0) {
        alpha = new APLArray([alpha.unwrap()]);
      }
      if (omega.shape.length === 0) {
        omega = new APLArray([omega.unwrap()]);
      }
      return F(G(enclose(omega, void 0, new APLArray([0])), enclose(alpha, void 0, new APLArray([alpha.shape.length - 1]))));
    };
  };
  addVocabulary({
    '↓': function(omega, alpha, axis) {
      var a, array, data, i, ishape, obound, offset, oshape, shape, tmp16, x, _i, _j, _k, _len, _len1;
      if (alpha) {
        if (alpha.shape.length > 1) {
          rankError();
        }
        a = alpha.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          if (!((tmp16 = (x)) === ~~tmp16)) {
            domainError();
          }
        }
        if (omega.shape.length === 0) {
          omega = new APLArray(omega.data, repeat([1], a.length), omega.stride, omega.offset);
        } else {
          if (a.length > omega.shape.length) {
            rankError();
          }
        }
        shape = omega.shape.slice(0);
        offset = omega.offset;
        for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
          x = a[i];
          shape[i] = Math.max(0, omega.shape[i] - Math.abs(x));
          if (x > 0) {
            offset += x * omega.stride[i];
          }
        }
        if (prod(shape) === 0) {
          return new APLArray([], shape);
        } else {
          return new APLArray(omega.data, shape, omega.stride, offset);
        }
      } else {
        if (omega.shape.length === 0) {
          nonceError('Split of scalar not implemented');
        }
        oshape = omega.shape.slice(0, omega.shape.length - 1);
        obound = oshape.reduce((function(a, b) {
          return a * b;
        }), 1);
        ishape = omega.shape[omega.shape.length - 1];
        array = omega.toArray();
        data = [];
        for (i = _k = 0; 0 <= obound ? _k < obound : _k > obound; i = 0 <= obound ? ++_k : --_k) {
          offset = i * ishape;
          data.push(new APLArray(array.slice(offset, offset + ishape)));
        }
        return new APLArray(data, oshape);
      }
    }
  });
  addVocabulary({
    '¨': adverb(function(f, g) {
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/each.coffee:18");
      }
      if (!(typeof g === 'undefined')) {
        throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/each.coffee:19");
      }
      return function(omega, alpha) {
        var x, y;
        if (!alpha) {
          return omega.map(function(x) {
            var r;
            if (!(x instanceof APLArray)) {
              x = new APLArray([x], []);
            }
            r = f(x);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:25");
            }
            if (r.shape.length === 0) {
              return r.unwrap();
            } else {
              return r;
            }
          });
        } else if (arrayEquals(alpha.shape, omega.shape)) {
          return omega.map2(alpha, function(x, y) {
            var r;
            if (!(x instanceof APLArray)) {
              x = new APLArray([x], []);
            }
            if (!(y instanceof APLArray)) {
              y = new APLArray([y], []);
            }
            r = f(x, y);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:32");
            }
            if (r.shape.length === 0) {
              return r.unwrap();
            } else {
              return r;
            }
          });
        } else if (alpha.isSingleton()) {
          y = alpha.data[0] instanceof APLArray ? alpha.unwrap() : alpha;
          return omega.map(function(x) {
            var r;
            if (!(x instanceof APLArray)) {
              x = new APLArray([x], []);
            }
            r = f(x, y);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:39");
            }
            if (r.shape.length === 0) {
              return r.unwrap();
            } else {
              return r;
            }
          });
        } else if (omega.isSingleton()) {
          x = omega.data[0] instanceof APLArray ? omega.unwrap() : omega;
          return alpha.map(function(y) {
            var r;
            if (!(y instanceof APLArray)) {
              y = new APLArray([y], []);
            }
            r = f(x, y);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:46");
            }
            if (r.shape.length === 0) {
              return r.unwrap();
            } else {
              return r;
            }
          });
        } else {
          return lengthError();
        }
      };
    })
  });
  arrayEquals = function(a, b) {
    var i, x, _i, _len;
    if (!(a instanceof Array)) {
      throw Error("\"assert a instanceof Array\" at src/vocabulary/each.coffee:52");
    }
    if (!(b instanceof Array)) {
      throw Error("\"assert b instanceof Array\" at src/vocabulary/each.coffee:53");
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      x = a[i];
      if (x !== b[i]) {
        return false;
      }
    }
    return true;
  };
  addVocabulary({
    '⊤': function(omega, alpha) {
      var a, b, data, i, isNeg, j, k, m, n, shape, x, y, _i, _j, _k, _len, _ref;
      if (!(alpha)) {
        throw Error("\"assert alpha\" at src/vocabulary/encode.coffee:40");
      }
      a = alpha.toArray();
      b = omega.toArray();
      shape = alpha.shape.concat(omega.shape);
      data = Array(prod(shape));
      n = alpha.shape.length ? alpha.shape[0] : 1;
      m = a.length / n;
      for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
        for (j = _j = 0, _len = b.length; _j < _len; j = ++_j) {
          y = b[j];
          if (isNeg = y < 0) {
            y = -y;
          }
          for (k = _k = _ref = n - 1; _k >= 0; k = _k += -1) {
            x = a[k * m + i];
            if (x === 0) {
              data[(k * m + i) * b.length + j] = y;
              y = 0;
            } else {
              data[(k * m + i) * b.length + j] = y % x;
              y = Math.round((y - (y % x)) / x);
            }
          }
        }
      }
      return new APLArray(data, shape);
    }
  });
  addVocabulary({
    '∊': aka('∈', function(omega, alpha) {
      var a, data;
      if (alpha) {
        a = omega.toArray();
        return alpha.map(function(x) {
          var y, _i, _len;
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            y = a[_i];
            if (match(x, y)) {
              return 1;
            }
          }
          return 0;
        });
      } else {
        data = [];
        enlist(omega, data);
        return new APLArray(data);
      }
    })
  });
  enlist = function(x, r) {
    if (x instanceof APLArray) {
      return x.each(function(y) {
        return enlist(y, r);
      });
    } else {
      return r.push(x);
    }
  };
  addVocabulary({
    '!': withIdentity(1, pervasive({
      monad: real(function(x) {
        var tmp17;
        if (!((tmp17 = (x)) === ~~tmp17)) {
          return Γ(x + 1);
        } else if (x < 0) {
          return domainError();
        } else if (x < smallFactorials.length) {
          return smallFactorials[x];
        } else {
          return Math.round(Γ(x + 1));
        }
      }),
      dyad: Beta = real(function(n, k) {
        var r, tmp18, tmp19;
        r = (function() {
          switch (4 * negInt(k) + 2 * negInt(n) + negInt(n - k)) {
            case 0x0:
              return Math.exp(lnΓ(n + 1) - lnΓ(k + 1) - lnΓ(n - k + 1));
            case 0x1:
              return 0;
            case 0x2:
              return domainError();
            case 0x3:
              return Math.pow(-1, k) * Beta(k - n - 1, k);
            case 0x4:
              return 0;
            case 0x5:
              break;
            case 0x6:
              return Math.pow(-1, n - k) * Beta(Math.abs(k + 1), Math.abs(n + 1));
            case 0x7:
              return 0;
          }
        })();
        if (((tmp18 = (n)) === ~~tmp18) && ((tmp19 = (k)) === ~~tmp19)) {
          return Math.round(r);
        } else {
          return r;
        }
      })
    }))
  });
  negInt = function(x) {
    var tmp20;
    return ((tmp20 = (x)) === ~~tmp20) && x < 0;
  };
  smallFactorials = (function() {
    var i, x;
    return [x = 1].concat((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 25; i = ++_i) {
        _results.push(x *= i);
      }
      return _results;
    })());
  })();
  _ref = (function() {
    var g, g_ln, p, p_ln;
    g = 7;
    p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    g_ln = 607 / 128;
    p_ln = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];
    return {
      lnΓ: function(z) {
        var i, t, x, _i, _ref;
        if (z < 0) {
          return NaN;
        }
        x = p_ln[0];
        for (i = _i = _ref = p_ln.length - 1; _i > 0; i = _i += -1) {
          x += p_ln[i] / (z + i);
        }
        t = z + g_ln + .5;
        return .5 * Math.log(2 * Math.PI) + (z + .5) * Math.log(t) - t + Math.log(x) - Math.log(z);
      },
      Γ: function(z) {
        var i, t, x, _i, _ref;
        if (z < 0.5) {
          return Math.PI / (Math.sin(Math.PI * z) * Γ(1 - z));
        } else if (z > 100) {
          return Math.exp(lnΓ(z));
        } else {
          z--;
          x = p[0];
          for (i = _i = 1, _ref = g + 2; _i < _ref; i = _i += 1) {
            x += p[i] / (z + i);
          }
          t = z + g + .5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }
      }
    };
  })(), Γ = _ref.Γ, lnΓ = _ref.lnΓ;
  addVocabulary({
    '⍎': function(omega, alpha) {
      var s;
      if (alpha) {
        return nonceError();
      } else {
        s = '';
        omega.each(function(c) {
          if (typeof c !== 'string') {
            domainError();
          }
          return s += c;
        });
        return exec(s);
      }
    }
  });
  addVocabulary({
    '⍷': function(omega, alpha) {
      var a, d, data, findShape, i, indices, p, q, stride, _i, _ref1;
      if (alpha) {
        if (alpha.shape.length > omega.shape.length) {
          return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
        }
        if (alpha.shape.length < omega.shape.length) {
          alpha = new APLArray(alpha.data, repeat([1], omega.shape.length - alpha.shape.length).concat(alpha.shape), repeat([0], omega.shape.length - alpha.shape.length).concat(alpha.stride), alpha.offset);
        }
        if (prod(alpha.shape) === 0) {
          return new APLArray([1], omega.shape, repeat([0], omega.shape.length));
        }
        findShape = [];
        for (i = _i = 0, _ref1 = omega.shape.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          d = omega.shape[i] - alpha.shape[i] + 1;
          if (d <= 0) {
            return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
          }
          findShape.push(d);
        }
        stride = strideForShape(omega.shape);
        data = repeat([0], prod(omega.shape));
        p = omega.offset;
        q = 0;
        indices = repeat([0], findShape.length);
        while (true) {
          data[q] = +match(alpha, new APLArray(omega.data, alpha.shape, omega.stride, p));
          a = findShape.length - 1;
          while (a >= 0 && indices[a] + 1 === findShape[a]) {
            p -= indices[a] * omega.stride[a];
            q -= indices[a] * stride[a];
            indices[a--] = 0;
          }
          if (a < 0) {
            break;
          }
          p += omega.stride[a];
          q += stride[a];
          indices[a]++;
        }
        return new APLArray(data, omega.shape);
      } else {
        return nonceError();
      }
    }
  });
  addVocabulary({
    '⌊': withIdentity(Infinity, pervasive({
      monad: Complex.floor,
      dyad: real(function(y, x) {
        return Math.min(y, x);
      })
    })),
    '⌈': withIdentity(-Infinity, pervasive({
      monad: Complex.ceil,
      dyad: real(function(y, x) {
        return Math.max(y, x);
      })
    }))
  });
  addVocabulary({
    _fork1: function(h, g) {
      if (!(typeof h === 'function')) {
        throw Error("\"assert typeof h is 'function'\" at src/vocabulary/fork.coffee:20");
      }
      if (!(typeof g === 'function')) {
        throw Error("\"assert typeof g is 'function'\" at src/vocabulary/fork.coffee:21");
      }
      return [h, g];
    },
    _fork2: function(_arg, f) {
      var g, h;
      h = _arg[0], g = _arg[1];
      if (!(typeof h === 'function')) {
        throw Error("\"assert typeof h is 'function'\" at src/vocabulary/fork.coffee:25");
      }
      return function(b, a) {
        return g(h(b, a), f(b, a));
      };
    }
  });
  addVocabulary({
    '⍕': function(omega, alpha) {
      var t;
      if (alpha) {
        return nonceError();
      } else {
        t = format(omega);
        return new APLArray(t.join(''), [t.length, t[0].length]);
      }
    }
  });
  format = function(a) {
    var bottom, box, c, cols, d, grid, i, j, k, left, nCols, nRows, r, result, right, rows, sa, step, t, x, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    if (typeof a === 'undefined') {
      return ['undefined'];
    } else if (a === null) {
      return ['null'];
    } else if (typeof a === 'string') {
      return [a];
    } else if (typeof a === 'number') {
      r = [('' + a).replace(/-|Infinity/g, '¯')];
      r.align = 'right';
      return r;
    } else if (typeof a === 'function') {
      return ['λ'];
    } else if (!(a instanceof APLArray)) {
      return ['' + a];
    } else if (prod(a.shape) === 0) {
      return [''];
    } else {
      sa = a.shape;
      a = a.toArray();
      if (!sa.length) {
        return format(a[0]);
      }
      nRows = prod(sa.slice(0, sa.length - 1));
      nCols = sa[sa.length - 1];
      rows = (function() {
        var _i, _results;
        _results = [];
        for (_i = 0; 0 <= nRows ? _i < nRows : _i > nRows; 0 <= nRows ? _i++ : _i--) {
          _results.push({
            height: 0,
            bottomMargin: 0
          });
        }
        return _results;
      })();
      cols = (function() {
        var _i, _results;
        _results = [];
        for (_i = 0; 0 <= nCols ? _i < nCols : _i > nCols; 0 <= nCols ? _i++ : _i--) {
          _results.push({
            type: 0,
            width: 0,
            leftMargin: 0,
            rightMargin: 0
          });
        }
        return _results;
      })();
      grid = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = rows.length; _i < _len; i = ++_i) {
          r = rows[i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (j = _j = 0, _len1 = cols.length; _j < _len1; j = ++_j) {
              c = cols[j];
              x = a[nCols * i + j];
              box = format(x);
              r.height = Math.max(r.height, box.length);
              c.width = Math.max(c.width, box[0].length);
              c.type = Math.max(c.type, typeof x === 'string' && x.length === 1 ? 0 : !(x instanceof APLArray) ? 1 : 2);
              _results1.push(box);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      step = 1;
      for (d = _i = _ref1 = sa.length - 2; _i >= 1; d = _i += -1) {
        step *= sa[d];
        for (i = _j = _ref2 = step - 1, _ref3 = nRows - 1; step > 0 ? _j < _ref3 : _j > _ref3; i = _j += step) {
          rows[i].bottomMargin++;
        }
      }
      for (j = _k = 0, _len = cols.length; _k < _len; j = ++_k) {
        c = cols[j];
        if (j !== nCols - 1 && !((c.type === (_ref4 = cols[j + 1].type) && _ref4 === 0))) {
          c.rightMargin++;
        }
        if (c.type === 2) {
          c.leftMargin++;
          c.rightMargin++;
        }
      }
      result = [];
      for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {
        r = rows[i];
        for (j = _m = 0, _len2 = cols.length; _m < _len2; j = ++_m) {
          c = cols[j];
          t = grid[i][j];
          if (t.align === 'right') {
            left = repeat(' ', c.leftMargin + c.width - t[0].length);
            right = repeat(' ', c.rightMargin);
          } else {
            left = repeat(' ', c.leftMargin);
            right = repeat(' ', c.rightMargin + c.width - t[0].length);
          }
          for (k = _n = 0, _ref5 = t.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; k = 0 <= _ref5 ? ++_n : --_n) {
            t[k] = left + t[k] + right;
          }
          bottom = repeat(' ', t[0].length);
          for (_o = _ref6 = t.length, _ref7 = r.height + r.bottomMargin; _ref6 <= _ref7 ? _o < _ref7 : _o > _ref7; _ref6 <= _ref7 ? _o++ : _o--) {
            t.push(bottom);
          }
        }
        for (k = _p = 0, _ref8 = r.height + r.bottomMargin; 0 <= _ref8 ? _p < _ref8 : _p > _ref8; k = 0 <= _ref8 ? ++_p : --_p) {
          result.push(((function() {
            var _q, _results;
            _results = [];
            for (j = _q = 0; 0 <= nCols ? _q < nCols : _q > nCols; j = 0 <= nCols ? ++_q : --_q) {
              _results.push(grid[i][j][k]);
            }
            return _results;
          })()).join(''));
        }
      }
      return result;
    }
  };
  addVocabulary({
    '⍋': function(omega, alpha) {
      return grade(omega, alpha, 1);
    },
    '⍒': function(omega, alpha) {
      return grade(omega, alpha, -1);
    }
  });
  grade = function(omega, alpha, direction) {
    var h, _i, _ref1, _results;
    h = {};
    if (alpha) {
      if (!alpha.shape.length) {
        rankError();
      }
      h = {};
      alpha.each(function(x, indices) {
        if (typeof x !== 'string') {
          domainError();
        }
        return h[x] = indices[indices.length - 1];
      });
    }
    if (!omega.shape.length) {
      rankError();
    }
    return new APLArray((function() {
      _results = [];
      for (var _i = 0, _ref1 = omega.shape[0]; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).sort(function(i, j) {
      var a, indices, p, tx, ty, x, y;
      p = omega.offset;
      indices = repeat([0], omega.shape.length);
      while (true) {
        x = omega.data[p + i * omega.stride[0]];
        y = omega.data[p + j * omega.stride[0]];
        tx = typeof x;
        ty = typeof y;
        if (tx < ty) {
          return -direction;
        }
        if (tx > ty) {
          return direction;
        }
        if (h[x] != null) {
          x = h[x];
        }
        if (h[y] != null) {
          y = h[y];
        }
        if (x < y) {
          return -direction;
        }
        if (x > y) {
          return direction;
        }
        a = indices.length - 1;
        while (a > 0 && indices[a] + 1 === omega.shape[a]) {
          p -= omega.stride[a] * indices[a];
          indices[a--] = 0;
        }
        if (a <= 0) {
          break;
        }
        p += omega.stride[a];
        indices[a]++;
      }
      return 0;
    }));
  };
  addVocabulary({
    '⍁': conjunction(function(f, x) {
      var _ref1;
      if (f instanceof APLArray) {
        _ref1 = [x, f], f = _ref1[0], x = _ref1[1];
      }
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/identity.coffee:13");
      }
      if (!(x instanceof APLArray)) {
        throw Error("\"assert x instanceof APLArray\" at src/vocabulary/identity.coffee:14");
      }
      if (!x.isSingleton()) {
        rankError();
      }
      if (x.shape.length) {
        x = APLArray.scalar(x.unwrap());
      }
      return withIdentity(x, function(omega, alpha, axis) {
        return f(omega, alpha, axis);
      });
    })
  });
  addVocabulary({
    '⍳': function(omega, alpha) {
      var a, axis, d, data, indices, tmp21, _i, _j, _len, _ref1, _results;
      if (alpha) {
        if (alpha.shape.length !== 1) {
          rankError();
        }
        return omega.map(function(x) {
          var e, r;
          try {
            r = alpha.shape;
            alpha.each(function(y, indices) {
              if (match(x, y)) {
                r = indices;
                throw 'break';
              }
            });
          } catch (_error) {
            e = _error;
            if (e !== 'break') {
              throw e;
            }
          }
          if (r.length === 1) {
            return r[0];
          } else {
            return new APLArray(r);
          }
        });
      } else {
        if (omega.shape.length > 1) {
          rankError();
        }
        a = omega.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          d = a[_i];
          if (!((tmp21 = (d)) === ~~tmp21 && (0) <= tmp21)) {
            domainError();
          }
        }
        data = [];
        if (prod(a)) {
          if (a.length === 1) {
            data = (function() {
              _results = [];
              for (var _j = 0, _ref1 = a[0]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--){ _results.push(_j); }
              return _results;
            }).apply(this);
          } else {
            indices = repeat([0], a.length);
            while (true) {
              data.push(new APLArray(indices.slice(0)));
              axis = a.length - 1;
              while (axis >= 0 && indices[axis] + 1 === a[axis]) {
                indices[axis--] = 0;
              }
              if (axis < 0) {
                break;
              }
              indices[axis]++;
            }
          }
        }
        return new APLArray(data, a);
      }
    }
  });
  addVocabulary({
    '⊂': function(omega, alpha, axes) {
      var a, axis, data, indices, p, resultAxes, shape, stride, unitShape, unitStride, _i, _ref1, _results;
      if (alpha) {
        return nonceError();
      } else {
        axes = axes != null ? getAxisList(axes, omega.shape.length) : (function() {
          _results = [];
          for (var _i = 0, _ref1 = omega.shape.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        if (omega.isSimple()) {
          return omega;
        }
        unitShape = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = axes.length; _j < _len; _j++) {
            axis = axes[_j];
            _results1.push(omega.shape[axis]);
          }
          return _results1;
        })();
        unitStride = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = axes.length; _j < _len; _j++) {
            axis = axes[_j];
            _results1.push(omega.stride[axis]);
          }
          return _results1;
        })();
        resultAxes = (function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (axis = _j = 0, _ref2 = omega.shape.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; axis = 0 <= _ref2 ? ++_j : --_j) {
            if (__indexOf.call(axes, axis) < 0) {
              _results1.push(axis);
            }
          }
          return _results1;
        })();
        shape = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
            axis = resultAxes[_j];
            _results1.push(omega.shape[axis]);
          }
          return _results1;
        })();
        stride = (function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
            axis = resultAxes[_j];
            _results1.push(omega.stride[axis]);
          }
          return _results1;
        })();
        data = [];
        p = omega.offset;
        indices = repeat([0], shape.length);
        while (true) {
          data.push(new APLArray(omega.data, unitShape, unitStride, p));
          a = indices.length - 1;
          while (a >= 0 && indices[a] + 1 === shape[a]) {
            p -= indices[a] * stride[a];
            indices[a--] = 0;
          }
          if (a < 0) {
            break;
          }
          p += stride[a];
          indices[a]++;
        }
        return new APLArray(data, shape);
      }
    }
  });
  addVocabulary({
    '~': pervasive({
      monad: function(x) {
        return +(!bool(x));
      }
    }),
    '∨': withIdentity(0, pervasive({
      dyad: function(y, x) {
        if (!(Complex.isint(x)) || !(Complex.isint(y))) {
          domainError('∨ is implemented only for Gaussian integers');
        }
        return Complex.gcd(x, y);
      }
    })),
    '∧': aka('^', withIdentity(1, pervasive({
      dyad: function(y, x) {
        if (!(Complex.isint(x)) || !(Complex.isint(y))) {
          domainError('∧ is implemented only for Gaussian integers');
        }
        return Complex.lcm(x, y);
      }
    }))),
    '⍱': pervasive({
      dyad: real(function(y, x) {
        return +(!(bool(x) | bool(y)));
      })
    }),
    '⍲': pervasive({
      dyad: real(function(y, x) {
        return +(!(bool(x) & bool(y)));
      })
    })
  });
  addVocabulary({
    '⍣': conjunction(function(g, f) {
      var h, n;
      if (f instanceof APLArray && typeof g === 'function') {
        h = f;
        f = g;
        g = h;
      } else {
        if (!(typeof f === 'function')) {
          throw Error("\"assert typeof f is 'function'\" at src/vocabulary/poweroperator.coffee:15");
        }
      }
      if (typeof g === 'function') {
        return function(omega, alpha) {
          var omega1;
          while (true) {
            omega1 = f(omega, alpha);
            if (g(omega, omega1).toBool()) {
              return omega;
            }
            omega = omega1;
          }
        };
      } else {
        n = g.toInt(0);
        return function(omega, alpha) {
          var _i;
          for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
            omega = f(omega, alpha);
          }
          return omega;
        };
      }
    })
  });
  addVocabulary({
    'get_⎕': function() {
      if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
        return new APLArray(prompt('⎕:') || '');
      } else {
        return nonceError('Reading from ⎕ is not implemented.');
      }
    },
    'set_⎕': function(x) {
      var s;
      s = format(x).join('\n') + '\n';
      if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
        window.alert(s);
      } else {
        process.stdout.write(s);
      }
      return x;
    },
    'get_⍞': function() {
      if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
        return prompt('') || '';
      } else {
        return nonceError('Reading from ⍞ is not implemented.');
      }
    },
    'set_⍞': function(x) {
      var s;
      s = format(x).join('\n');
      if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
        window.alert(s);
      } else {
        process.stdout.write(s);
      }
      return x;
    },
    'get_⎕IO': function() {
      return APLArray.zero;
    },
    'set_⎕IO': function(x) {
      if (match(x, APLArray.zero)) {
        return x;
      } else {
        return domainError('The index origin (⎕IO) is fixed at 0');
      }
    },
    '⎕DL': cps(function(omega, alpha, _, callback) {
      var t0;
      t0 = +(new Date);
      setTimeout((function() {
        return callback(new APLArray([new Date - t0]));
      }), omega.unwrap());
    }),
    '⎕RE': function(omega, alpha) {
      var e, m, r, re, u, x, y, _i, _len;
      x = alpha.toSimpleString();
      y = omega.toSimpleString();
      try {
        re = new RegExp(x);
      } catch (_error) {
        e = _error;
        domainError(e.toString());
      }
      if (m = re.exec(y)) {
        r = [m.index];
        for (_i = 0, _len = m.length; _i < _len; _i++) {
          u = m[_i];
          r.push(new APLArray(u || ''));
        }
        return new APLArray(r);
      } else {
        return APLArray.zilde;
      }
    }
  });
  addVocabulary({
    '?': function(omega, alpha) {
      if (alpha) {
        return deal(omega, alpha);
      } else {
        return roll(omega);
      }
    }
  });
  roll = pervasive({
    monad: real(function(x) {
      return Math.floor(Math.random() * x);
    })
  });
  deal = function(omega, alpha) {
    var available, x, y, _i, _results;
    y = omega.unwrap();
    x = alpha.unwrap();
    if (x > y) {
      domainError();
    }
    available = (function() {
      _results = [];
      for (var _i = 0; 0 <= y ? _i < y : _i > y; 0 <= y ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    return new APLArray((function() {
      var _j, _results1;
      _results1 = [];
      for (_j = 0; 0 <= x ? _j < x : _j > x; 0 <= x ? _j++ : _j--) {
        _results1.push(available.splice(Math.floor(available.length * Math.random()), 1)[0]);
      }
      return _results1;
    })());
  };
  addVocabulary({
    '↗': function(omega) {
      return aplError(omega.toString());
    }
  });
  addVocabulary({
    '⍴': function(omega, alpha) {
      var a, d, n, shape, tmp22, _i, _len;
      if (alpha) {
        if (alpha.shape.length > 1) {
          rankError();
        }
        shape = alpha.toArray();
        for (_i = 0, _len = shape.length; _i < _len; _i++) {
          d = shape[_i];
          if (!((tmp22 = (d)) === ~~tmp22 && (0) <= tmp22)) {
            domainError();
          }
        }
        n = prod(shape);
        a = omega.toArray(n);
        if (!(a.length <= n)) {
          throw Error("\"assert a.length <= n\" at src/vocabulary/rho.coffee:20");
        }
        if (a.length) {
          while (2 * a.length < n) {
            a = a.concat(a);
          }
          if (a.length !== n) {
            a = a.concat(a.slice(0, n - a.length));
          }
        } else {
          a = repeat([omega.getPrototype()], n);
        }
        return new APLArray(a, shape);
      } else {
        return new APLArray(omega.shape);
      }
    }
  });
  addVocabulary({
    '⌽': rotate = function(omega, alpha, axis) {
      var a, data, indices, n, offset, p, shape, step, stride, tmp23, tmp24, tmp25;
      if (!(typeof axis === 'undefined' || axis instanceof APLArray)) {
        throw Error("\"assert typeof axis is 'undefined' or axis instanceof APLArray\" at src/vocabulary/rotate.coffee:4");
      }
      if (alpha) {
        axis = !axis ? omega.shape.length - 1 : axis.unwrap();
        if (!((tmp23 = (axis)) === ~~tmp23)) {
          domainError();
        }
        if (omega.shape.length && !((0 <= axis && axis < omega.shape.length))) {
          indexError();
        }
        step = alpha.unwrap();
        if (!((tmp24 = (step)) === ~~tmp24)) {
          domainError();
        }
        if (!step) {
          return omega;
        }
        n = omega.shape[axis];
        step = (n + (step % n)) % n;
        if (omega.empty() || step === 0) {
          return omega;
        }
        data = [];
        shape = omega.shape, stride = omega.stride;
        p = omega.offset;
        indices = repeat([0], shape.length);
        while (true) {
          data.push(omega.data[p + ((indices[axis] + step) % shape[axis] - indices[axis]) * stride[axis]]);
          a = shape.length - 1;
          while (a >= 0 && indices[a] + 1 === shape[a]) {
            p -= indices[a] * stride[a];
            indices[a--] = 0;
          }
          if (a < 0) {
            break;
          }
          indices[a]++;
          p += stride[a];
        }
        return new APLArray(data, shape);
      } else {
        if (axis) {
          if (!axis.isSingleton()) {
            lengthError();
          }
          axis = axis.unwrap();
          if (!((tmp25 = (axis)) === ~~tmp25)) {
            domainError();
          }
          if (!((0 <= axis && axis < omega.shape.length))) {
            indexError();
          }
        } else {
          axis = [omega.shape.length - 1];
        }
        if (omega.shape.length === 0) {
          return omega;
        }
        stride = omega.stride.slice(0);
        stride[axis] = -stride[axis];
        offset = omega.offset + (omega.shape[axis] - 1) * omega.stride[axis];
        return new APLArray(omega.data, omega.shape, stride, offset);
      }
    },
    '⊖': function(omega, alpha, axis) {
      if (axis == null) {
        axis = APLArray.zero;
      }
      return rotate(omega, alpha, axis);
    }
  });
  addVocabulary({
    '/': adverb(function(omega, alpha, axis) {
      if (typeof omega === 'function') {
        return reduce(omega, alpha, axis);
      } else {
        return compressOrReplicate(omega, alpha, axis);
      }
    }),
    '⌿': adverb(function(omega, alpha, axis) {
      if (axis == null) {
        axis = APLArray.zero;
      }
      if (typeof omega === 'function') {
        return reduce(omega, alpha, axis);
      } else {
        return compressOrReplicate(omega, alpha, axis);
      }
    })
  });
  reduce = this.reduce = function(f, g, axis0) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/slash.coffee:36");
    }
    if (!(typeof g === 'undefined')) {
      throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/slash.coffee:37");
    }
    if (!((typeof axis0 === 'undefined') || (axis0 instanceof APLArray))) {
      throw Error("\"assert((typeof axis0 is 'undefined') or (axis0 instanceof APLArray))\" at src/vocabulary/slash.coffee:38");
    }
    return function(omega, alpha) {
      var a, axis, data, i, indices, isBackwards, isMonadic, isNWise, n, p, rShape, shape, x, y, z, _i, _j, _ref1;
      if (omega.shape.length === 0) {
        omega = new APLArray([omega.unwrap()]);
      }
      axis = axis0 != null ? axis0.toInt() : omega.shape.length - 1;
      if (!((0 <= axis && axis < omega.shape.length))) {
        rankError();
      }
      if (alpha) {
        isNWise = true;
        n = alpha.toInt();
        if (n < 0) {
          isBackwards = true;
          n = -n;
        }
      } else {
        n = omega.shape[axis];
        isMonadic = true;
      }
      shape = omega.shape.slice(0);
      shape[axis] = omega.shape[axis] - n + 1;
      rShape = shape;
      if (isNWise) {
        if (shape[axis] === 0) {
          return new APLArray([], rShape);
        }
        if (shape[axis] < 0) {
          lengthError();
        }
      } else {
        rShape = rShape.slice(0);
        rShape.splice(axis, 1);
      }
      if (omega.empty()) {
        if ((z = f.identity) != null) {
          if (!(z.shape.length === 0)) {
            throw Error("\"assert z.shape.length is 0\" at src/vocabulary/slash.coffee:66");
          }
          return new APLArray(z.data, rShape, repeat([0], rShape.length), z.offset);
        } else {
          domainError();
        }
      }
      data = [];
      indices = repeat([0], shape.length);
      p = omega.offset;
      while (true) {
        if (isBackwards) {
          x = omega.data[p];
          x = x instanceof APLArray ? x : APLArray.scalar(x);
          for (i = _i = 1; _i < n; i = _i += 1) {
            y = omega.data[p + i * omega.stride[axis]];
            y = y instanceof APLArray ? y : APLArray.scalar(y);
            x = f(x, y);
          }
        } else {
          x = omega.data[p + (n - 1) * omega.stride[axis]];
          x = x instanceof APLArray ? x : APLArray.scalar(x);
          for (i = _j = _ref1 = n - 2; _j >= 0; i = _j += -1) {
            y = omega.data[p + i * omega.stride[axis]];
            y = y instanceof APLArray ? y : APLArray.scalar(y);
            x = f(x, y);
          }
        }
        if (x.shape.length === 0) {
          x = x.unwrap();
        }
        data.push(x);
        a = indices.length - 1;
        while (a >= 0 && indices[a] + 1 === shape[a]) {
          p -= indices[a] * omega.stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += omega.stride[a];
        indices[a]++;
      }
      return new APLArray(data, rShape);
    };
  };
  compressOrReplicate = function(omega, alpha, axis) {
    var a, b, data, filler, i, indices, n, p, shape, tmp26, x, _i, _j, _len, _ref1;
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
    if (alpha.shape.length > 1) {
      rankError();
    }
    a = alpha.toArray();
    n = omega.shape[axis];
    if (a.length === 1) {
      a = repeat(a, n);
    }
    if (n !== 1 && n !== a.length) {
      lengthError();
    }
    shape = omega.shape.slice(0);
    shape[axis] = 0;
    b = [];
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      x = a[i];
      if (!((tmp26 = (x)) === ~~tmp26)) {
        domainError();
      }
      shape[axis] += Math.abs(x);
      for (_j = 0, _ref1 = Math.abs(x); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--) {
        b.push(x > 0 ? i : null);
      }
    }
    if (n === 1) {
      b = (function() {
        var _k, _len1, _results;
        _results = [];
        for (_k = 0, _len1 = b.length; _k < _len1; _k++) {
          x = b[_k];
          _results.push(x != null ? 0 : x);
        }
        return _results;
      })();
    }
    data = [];
    if (shape[axis] !== 0 && !omega.empty()) {
      filler = omega.getPrototype();
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
        data.push(x);
        i = shape.length - 1;
        while (i >= 0 && indices[i] + 1 === shape[i]) {
          if (i !== axis) {
            p -= omega.stride[i] * indices[i];
          }
          indices[i--] = 0;
        }
        if (i < 0) {
          break;
        }
        if (i !== axis) {
          p += omega.stride[i];
        }
        indices[i]++;
      }
    }
    return new APLArray(data, shape);
  };
  addVocabulary({
    '⌷': squish = function(omega, alpha, axes) {
      var a, data, p, subscriptShapes, subscripts, u, x, _i, _ref1, _ref2, _ref3;
      if (typeof omega === 'function') {
        return function(x, y) {
          return omega(x, y, alpha);
        };
      }
      if (!alpha) {
        nonceError();
      }
      _ref1 = prepareForIndexing(omega, alpha, axes), subscripts = _ref1[0], subscriptShapes = _ref1[1];
      data = [];
      if (all((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = subscripts.length; _i < _len; _i++) {
          x = subscripts[_i];
          _results.push(x.length);
        }
        return _results;
      })())) {
        u = repeat([0], subscripts.length);
        p = omega.offset;
        for (a = _i = 0, _ref2 = subscripts.length; _i < _ref2; a = _i += 1) {
          p += subscripts[a][0] * omega.stride[a];
        }
        while (true) {
          data.push(omega.data[p]);
          a = subscripts.length - 1;
          while (a >= 0 && u[a] + 1 === subscripts[a].length) {
            p += (subscripts[a][0] - subscripts[a][u[a]]) * omega.stride[a];
            u[a--] = 0;
          }
          if (a < 0) {
            break;
          }
          p += (subscripts[a][u[a] + 1] - subscripts[a][u[a]]) * omega.stride[a];
          u[a]++;
        }
      }
      return new APLArray(data, (_ref3 = []).concat.apply(_ref3, subscriptShapes));
    },
    _index: function(alphaAndAxes, omega) {
      var alpha, axes, _ref1;
      _ref1 = alphaAndAxes.toArray(), alpha = _ref1[0], axes = _ref1[1];
      return squish(omega, alpha, axes);
    },
    _substitute: function(args) {
      var a, alpha, axes, i, indexShape, n, omega, p, q, r, subscriptShapes, subscripts, u, value, x, _i, _j, _len, _ref1, _ref2, _ref3, _ref4;
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = args.toArray();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          x = _ref1[_i];
          if (x instanceof APLArray) {
            _results.push(x);
          } else {
            _results.push(new APLArray([x], []));
          }
        }
        return _results;
      })(), value = _ref1[0], alpha = _ref1[1], omega = _ref1[2], axes = _ref1[3];
      _ref2 = prepareForIndexing(omega, alpha, axes), subscripts = _ref2[0], subscriptShapes = _ref2[1];
      indexShape = (_ref3 = []).concat.apply(_ref3, subscriptShapes);
      if (value.isSingleton()) {
        value = new APLArray([value.unwrap()], indexShape, repeat([0], indexShape.length));
      } else {
        if (value.shape.length !== indexShape.length) {
          rankError();
        } else {
          for (i = _i = 0, _len = indexShape.length; _i < _len; i = ++_i) {
            n = indexShape[i];
            if (value.shape[i] !== n) {
              lengthError();
            }
          }
        }
      }
      r = new APLArray(omega.toArray(), omega.shape);
      p = 0;
      for (a = _j = 0, _ref4 = subscripts.length; _j < _ref4; a = _j += 1) {
        if (subscripts[a].length === 0) {
          return r;
        }
        p += subscripts[a][0] * r.stride[a];
      }
      q = value.offset;
      u = repeat([0], subscripts.length);
      while (true) {
        r.data[p] = value.data[q];
        a = subscripts.length - 1;
        while (a >= 0 && u[a] + 1 === subscripts[a].length) {
          p += (subscripts[a][0] - subscripts[a][u[a]]) * r.stride[a];
          q -= u[a] * value.stride[a];
          u[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += (subscripts[a][u[a] + 1] - subscripts[a][u[a]]) * r.stride[a];
        q += value.stride[a];
        u[a]++;
      }
      return r;
    }
  });
  prepareForIndexing = function(omega, alpha, axes) {
    var alphaItems, axis, d, i, subscriptShapes, subscripts, tmp27, tmp28, x, _i, _j, _k, _l, _len, _len1, _m, _ref1, _ref2, _ref3, _ref4, _results, _results1;
    if (!(alpha instanceof APLArray)) {
      throw Error("\"assert alpha instanceof APLArray\" at src/vocabulary/squish.coffee:123");
    }
    if (!(omega instanceof APLArray)) {
      throw Error("\"assert omega instanceof APLArray\" at src/vocabulary/squish.coffee:124");
    }
    if (!((axes == null) || axes instanceof APLArray)) {
      throw Error("\"assert (not axes?) or axes instanceof APLArray\" at src/vocabulary/squish.coffee:125");
    }
    if (alpha.shape.length > 1) {
      rankError();
    }
    alphaItems = alpha.toArray();
    if (alphaItems.length > omega.shape.length) {
      lengthError();
    }
    axes = axes ? axes.toArray() : (function() {
      _results = [];
      for (var _i = 0, _ref1 = alphaItems.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    if (alphaItems.length !== axes.length) {
      lengthError();
    }
    subscripts = Array(omega.shape.length);
    subscriptShapes = Array(omega.shape.length);
    for (i = _j = 0, _len = axes.length; _j < _len; i = ++_j) {
      axis = axes[i];
      if (!((tmp27 = (axis)) === ~~tmp27)) {
        domainError();
      }
      if (!((0 <= axis && axis < omega.shape.length))) {
        rankError();
      }
      if (typeof subscripts[axis] !== 'undefined') {
        rankError('Duplicate axis');
      }
      d = alphaItems[i];
      subscripts[axis] = d instanceof APLArray ? d.toArray() : [d];
      subscriptShapes[axis] = d instanceof APLArray ? d.shape : [];
      _ref2 = subscripts[axis];
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        x = _ref2[_k];
        if (!((tmp28 = (x)) === ~~tmp28)) {
          domainError();
        }
        if (!((0 <= x && x < omega.shape[axis]))) {
          indexError();
        }
      }
    }
    for (i = _l = 0, _ref3 = subscripts.length; _l < _ref3; i = _l += 1) {
      if (!(typeof subscripts[i] === 'undefined')) {
        continue;
      }
      subscripts[i] = (function() {
        _results1 = [];
        for (var _m = 0, _ref4 = omega.shape[i]; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; 0 <= _ref4 ? _m++ : _m--){ _results1.push(_m); }
        return _results1;
      }).apply(this);
      subscriptShapes[i] = [omega.shape[i]];
    }
    return [subscripts, subscriptShapes];
  };
  addVocabulary({
    '↑': function(omega, alpha) {
      if (alpha) {
        return take(omega, alpha);
      } else {
        return first(omega);
      }
    }
  });
  take = function(omega, alpha) {
    var a, axis, copyIndices, copyShape, data, i, mustCopy, offset, p, q, shape, stride, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref1;
    if (alpha.shape.length > 1) {
      rankError();
    }
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()], (alpha.shape.length === 0 ? [1] : repeat([1], alpha.shape[0])));
    }
    a = alpha.toArray();
    if (a.length > omega.shape.length) {
      rankError();
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      if (typeof x !== 'number' || x !== Math.floor(x)) {
        domainError();
      }
    }
    mustCopy = false;
    shape = omega.shape.slice(0);
    for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
      x = a[i];
      shape[i] = Math.abs(x);
      if (shape[i] > omega.shape[i]) {
        mustCopy = true;
      }
    }
    if (mustCopy) {
      stride = Array(shape.length);
      stride[stride.length - 1] = 1;
      for (i = _k = _ref1 = stride.length - 2; _k >= 0; i = _k += -1) {
        stride[i] = stride[i + 1] * shape[i + 1];
      }
      data = repeat([omega.getPrototype()], prod(shape));
      copyShape = shape.slice(0);
      p = omega.offset;
      q = 0;
      for (i = _l = 0, _len2 = a.length; _l < _len2; i = ++_l) {
        x = a[i];
        copyShape[i] = Math.min(omega.shape[i], Math.abs(x));
        if (x < 0) {
          if (x < -omega.shape[i]) {
            q -= (x + omega.shape[i]) * stride[i];
          } else {
            p += (x + omega.shape[i]) * omega.stride[i];
          }
        }
      }
      if (prod(copyShape)) {
        copyIndices = repeat([0], copyShape.length);
        while (true) {
          data[q] = omega.data[p];
          axis = copyShape.length - 1;
          while (axis >= 0 && copyIndices[axis] + 1 === copyShape[axis]) {
            p -= copyIndices[axis] * omega.stride[axis];
            q -= copyIndices[axis] * stride[axis];
            copyIndices[axis--] = 0;
          }
          if (axis < 0) {
            break;
          }
          p += omega.stride[axis];
          q += stride[axis];
          copyIndices[axis]++;
        }
      }
      return new APLArray(data, shape, stride);
    } else {
      offset = omega.offset;
      for (i = _m = 0, _len3 = a.length; _m < _len3; i = ++_m) {
        x = a[i];
        if (x < 0) {
          offset += (omega.shape[i] + x) * omega.stride[i];
        }
      }
      return new APLArray(omega.data, shape, omega.stride, offset);
    }
  };
  first = function(omega) {
    var x;
    x = omega.empty() ? omega.getPrototype() : omega.data[omega.offset];
    if (x instanceof APLArray) {
      return x;
    } else {
      return new APLArray([x], []);
    }
  };
  addVocabulary({
    '⍉': function(omega, alpha) {
      var i, n, shape, stride, tmp29, u, x, _i, _j, _len, _len1, _ref1;
      if (alpha) {
        if (alpha.shape.length > 1) {
          rankError();
        }
        if (alpha.shape.length === 0) {
          alpha = new APLArray([alpha.unwrap()]);
        }
        n = omega.shape.length;
        if (alpha.shape[0] !== n) {
          lengthError();
        }
        shape = [];
        stride = [];
        _ref1 = alpha.toArray();
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          x = _ref1[i];
          if (!((tmp29 = (x)) === ~~tmp29 && (0) <= tmp29)) {
            domainError();
          }
          if (x >= n) {
            rankError();
          }
          if (shape[x] != null) {
            shape[x] = Math.min(shape[x], omega.shape[i]);
            stride[x] += omega.stride[i];
          } else {
            shape[x] = omega.shape[i];
            stride[x] = omega.stride[i];
          }
        }
        for (_j = 0, _len1 = shape.length; _j < _len1; _j++) {
          u = shape[_j];
          if (u == null) {
            rankError();
          }
        }
        return new APLArray(omega.data, shape, stride, omega.offset);
      } else {
        return new APLArray(omega.data, omega.shape.slice(0).reverse(), omega.stride.slice(0).reverse(), omega.offset);
      }
    }
  });
  addVocabulary({
    '⍠': conjunction(function(f, g) {
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/variant.coffee:8");
      }
      if (!(typeof g === 'function')) {
        throw Error("\"assert typeof g is 'function'\" at src/vocabulary/variant.coffee:9");
      }
      return function(omega, alpha, axis) {
        return (alpha != null ? f : g)(omega, alpha, axis);
      };
    })
  });
  exec = function(aplCode, opts) {
    if (opts == null) {
      opts = {};
    }
    return execInternal(aplCode, opts).result;
  };
  execInternal = function(aplCode, opts) {
    var ast, code, env, frame, k, result, v, _ref1, _ref2;
    if (opts == null) {
      opts = {};
    }
    ast = parse(aplCode, opts);
    code = compileAST(ast, opts);
    env = prelude ? (function() {
      var _i, _len, _ref1, _results;
      _ref1 = prelude.env;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        frame = _ref1[_i];
        _results.push(frame.slice(0));
      }
      return _results;
    })() : [[]];
    _ref1 = ast.vars;
    for (k in _ref1) {
      v = _ref1[k];
      env[0][v.slot] = opts.ctx[k];
    }
    result = vm({
      code: code,
      env: env
    });
    _ref2 = ast.vars;
    for (k in _ref2) {
      v = _ref2[k];
      opts.ctx[k] = env[0][v.slot];
    }
    return {
      ast: ast,
      code: code,
      env: env,
      result: result
    };
  };
  compile = function(aplCode, opts) {
    if (opts == null) {
      opts = {};
    }
    opts.aplCode = aplCode;
    return compileAST(parse(aplCode, opts), opts);
  };
  compileAST = function(ast, opts) {
    var categorizeLambdas, err, i, queue, render, renderLHS, scopeNode, vars, visit, visitLHS, _i, _ref1;
    if (opts == null) {
      opts = {};
    }
    ast.scopeDepth = 0;
    ast.nSlots = prelude ? prelude.ast.nSlots : 0;
    ast.vars = prelude ? Object.create(prelude.ast.vars) : {};
    (function() {
      var k, v, varInfo, _ref1, _results;
      if (opts.ctx == null) {
        opts.ctx = Object.create(vocabulary);
      }
      _ref1 = opts.ctx;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        if (!(!ast.vars[k])) {
          continue;
        }
        ast.vars[k] = varInfo = {
          category: 1,
          slot: ast.nSlots++,
          scopeDepth: ast.scopeDepth
        };
        if (typeof v === 'function' || v instanceof λ) {
          varInfo.category = v.isAdverb ? 3 : v.isConjunction ? 4 : 2;
          if (/^[gs]et_.*/.test(k)) {
            _results.push(ast.vars[k.slice(4)] = {
              category: 1
            });
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    })();
    err = function(node, message) {
      return syntaxError(message, {
        file: opts.file,
        line: node.startLine,
        col: node.startCol,
        aplCode: opts.aplCode
      });
    };
    if (!((2 < 3 && 3 < 4))) {
      throw Error("\"assert VERB < ADVERB < CONJUNCTION # we are relying on this ordering below\" at src/compiler.coffee:39");
    }
    (categorizeLambdas = function(node) {
      var i, r, _i, _ref1;
      switch (node[0]) {
        case 'body':
        case 'guard':
        case 'assign':
        case 'index':
        case 'lambda':
        case 'expr':
          r = 2;
          for (i = _i = 1, _ref1 = node.length; _i < _ref1; i = _i += 1) {
            if (node[i]) {
              r = Math.max(r, categorizeLambdas(node[i]));
            }
          }
          if (node[0] === 'lambda') {
            node.category = r;
            return 2;
          } else {
            return r;
          }
          break;
        case 'string':
        case 'number':
        case 'embedded':
          return 0;
        case 'symbol':
          switch (node[1]) {
            case '⍺⍺':
            case '⍶':
            case '∇∇':
              return 3;
            case '⍵⍵':
            case '⍹':
              return 4;
            default:
              return 2;
          }
          break;
        default:
          if (!(0)) {
            throw Error("\"else assert 0\" at src/compiler.coffee:52");
          }
      }
    })(ast);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      visit = function(node) {
        var a, body, d, h, i, j, name, r, v, x, _i, _j, _k, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        node.scopeNode = scopeNode;
        switch (node[0]) {
          case 'guard':
            r = visit(node[1]);
            visit(node[2]);
            return r;
          case 'assign':
            return visitLHS(node[1], visit(node[2]));
          case 'symbol':
            name = node[1];
            if (((_ref1 = (v = vars["get_" + name])) != null ? _ref1.category : void 0) === 2) {
              return 1;
            } else {
              return ((_ref2 = vars[name]) != null ? _ref2.category : void 0) || err(node, "Symbol '" + name + "' is referenced before assignment.");
            }
            break;
          case 'lambda':
            for (i = _i = 1, _ref3 = node.length; 1 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 1 <= _ref3 ? ++_i : --_i) {
              queue.push(extend((body = node[i]), {
                scopeNode: scopeNode,
                scopeDepth: d = scopeNode.scopeDepth + 1 + (node.category !== 2),
                nSlots: 3,
                vars: v = extend(Object.create(vars), {
                  '⍵': {
                    slot: 0,
                    scopeDepth: d,
                    category: 1
                  },
                  '∇': {
                    slot: 1,
                    scopeDepth: d,
                    category: 2
                  },
                  '⍺': {
                    slot: 2,
                    scopeDepth: d,
                    category: 1
                  }
                })
              }));
              if (node.category === 4) {
                v['⍵⍵'] = v['⍹'] = {
                  slot: 0,
                  scopeDepth: d - 1,
                  category: 2
                };
                v['∇∇'] = {
                  slot: 1,
                  scopeDepth: d - 1,
                  category: 4
                };
                v['⍺⍺'] = v['⍶'] = {
                  slot: 2,
                  scopeDepth: d - 1,
                  category: 2
                };
              } else if (node.category === 3) {
                v['⍺⍺'] = v['⍶'] = {
                  slot: 0,
                  scopeDepth: d - 1,
                  category: 2
                };
                v['∇∇'] = {
                  slot: 1,
                  scopeDepth: d - 1,
                  category: 3
                };
              }
            }
            return (_ref4 = node.category) != null ? _ref4 : 2;
          case 'string':
          case 'number':
          case 'embedded':
            return 1;
          case 'index':
            for (i = _j = 2, _ref5 = node.length; _j < _ref5; i = _j += 1) {
              if (node[i] && visit(node[i]) !== 1) {
                err(node, 'Indices must be nouns.');
              }
            }
            return visit(node[1]);
          case 'expr':
            a = node.slice(1);
            h = Array(a.length);
            for (i = _k = _ref6 = a.length - 1; _k >= 0; i = _k += -1) {
              h[i] = visit(a[i]);
            }
            i = 0;
            while (i < a.length - 1) {
              if ((h[i] === (_ref7 = h[i + 1]) && _ref7 === 1)) {
                j = i + 2;
                while (j < a.length && h[j] === 1) {
                  j++;
                }
                [].splice.apply(a, [i, j - i].concat(_ref8 = [['vector'].concat(a.slice(i, j))])), _ref8;
                [].splice.apply(h, [i, j - i].concat(1)), 1;
              } else {
                i++;
              }
            }
            i = a.length - 2;
            while (--i >= 0) {
              if (h[i + 1] === 4 && (h[i] !== 1 || h[i + 2] !== 1)) {
                [].splice.apply(a, [i, (i + 3) - i].concat(_ref9 = [['conjunction'].concat(a.slice(i, i + 3))])), _ref9;
                [].splice.apply(h, [i, (i + 3) - i].concat(2)), 2;
                i--;
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if (h[i] !== 1 && h[i + 1] === 3) {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref10 = [['adverb'].concat(a.slice(i, i + 2))])), _ref10;
                [].splice.apply(h, [i, (i + 2) - i].concat(2)), 2;
              } else {
                i++;
              }
            }
            if (h.length === 2 && h[0] !== 1 && h[1] !== 1) {
              a = [['hook'].concat(a)];
              h = [2];
            }
            if (h.length >= 3 && h.length % 2 === 1 && all((function() {
              var _l, _len, _results;
              _results = [];
              for (_l = 0, _len = h.length; _l < _len; _l++) {
                x = h[_l];
                _results.push(x !== 1);
              }
              return _results;
            })())) {
              a = [['fork'].concat(a)];
              h = [2];
            }
            if (h[h.length - 1] !== 1) {
              if (h.length > 1) {
                err(a[h.length - 1], 'Trailing function in expression');
              }
            } else {
              while (h.length > 1) {
                if (h.length === 2 || h[h.length - 3] !== 1) {
                  [].splice.apply(a, [-2, 9e9].concat(_ref11 = [['monadic'].concat(a.slice(-2))])), _ref11;
                  [].splice.apply(h, [-2, 9e9].concat(1)), 1;
                } else {
                  [].splice.apply(a, [-3, 9e9].concat(_ref12 = [['dyadic'].concat(a.slice(-3))])), _ref12;
                  [].splice.apply(h, [-3, 9e9].concat(1)), 1;
                }
              }
            }
            [].splice.apply(node, [0, 9e9].concat(_ref13 = a[0])), _ref13;
            extend(node, a[0]);
            return h[0];
          default:
            if (!(0)) {
              throw Error("\"assert 0\" at src/compiler.coffee:146");
            }
        }
      };
      visitLHS = function(node, rhsCategory) {
        var c, i, name, _i, _j, _ref1, _ref2;
        node.scopeNode = scopeNode;
        switch (node[0]) {
          case 'symbol':
            name = node[1];
            if (name === '∇') {
              err(node, 'Assignment to ∇ is not allowed.');
            }
            if (vars[name]) {
              if (vars[name].category !== rhsCategory) {
                err(node, "Inconsistent usage of symbol '" + name + "', it is assigned both nouns and verbs.");
              }
            } else {
              vars[name] = {
                scopeDepth: scopeNode.scopeDepth,
                slot: scopeNode.nSlots++,
                category: rhsCategory
              };
            }
            break;
          case 'expr':
            rhsCategory === 1 || err(node, 'Strand assignment can be used only for nouns.');
            for (i = _i = 1, _ref1 = node.length; _i < _ref1; i = _i += 1) {
              visitLHS(node[i], rhsCategory);
            }
            break;
          case 'index':
            rhsCategory === 1 || err(node, 'Index assignment can be used only for nouns.');
            visitLHS(node[1], rhsCategory);
            for (i = _j = 2, _ref2 = node.length; _j < _ref2; i = _j += 1) {
              if (c = node[i]) {
                visit(c);
              }
            }
            break;
          default:
            err(node, "Invalid LHS node type: " + (JSON.stringify(node[0])));
        }
        return rhsCategory;
      };
      for (i = _i = 1, _ref1 = scopeNode.length; _i < _ref1; i = _i += 1) {
        visit(scopeNode[i]);
      }
    }
    render = function(node) {
      var a, axes, c, d, f, fragments, lx, ly, name, r, s, u, v, w, x, y, _j, _k, _ref2, _ref3, _ref4, _ref5;
      switch (node[0]) {
        case 'body':
          if (node.length === 1) {
            return [LDC, APLArray.zilde, RET];
          } else {
            a = [];
            for (i = _j = 1, _ref2 = node.length; _j < _ref2; i = _j += 1) {
              a.push.apply(a, render(node[i]));
              a.push(POP);
            }
            a[a.length - 1] = RET;
            return a;
          }
          break;
        case 'guard':
          x = render(node[1]);
          y = render(node[2]);
          return x.concat(JEQ, y.length + 2, POP, y, RET);
        case 'assign':
          return render(node[2]).concat(renderLHS(node[1]));
        case 'symbol':
          name = node[1];
          vars = node.scopeNode.vars;
          if (((_ref3 = (v = vars["get_" + name])) != null ? _ref3.category : void 0) === 2) {
            return [LDC, APLArray.zero, GET, v.scopeDepth, v.slot, MON];
          } else {
            v = vars[name];
            return [GET, v.scopeDepth, v.slot];
          }
          break;
        case 'lambda':
          x = render(node[1]);
          lx = [LAM, x.length].concat(x);
          f = (function() {
            switch (node.length) {
              case 2:
                return lx;
              case 3:
                y = render(node[2]);
                ly = [LAM, y.length].concat(y);
                v = node.scopeNode.vars['⍠'];
                return ly.concat(GET, v.scopeDepth, v.slot, lx, DYA);
              default:
                return err(node);
            }
          })();
          if (node.category !== 2) {
            return [LAM, f.length + 1].concat(f, RET);
          } else {
            return f;
          }
          break;
        case 'string':
          d = node[1][0];
          s = Function("return " + d + (node[1].slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d)) + d + ";")();
          v = s.length === 1 ? new APLArray(s, []) : new APLArray(s);
          return [LDC, v];
        case 'number':
          a = (function() {
            var _k, _len, _ref4, _results;
            _ref4 = node[1].replace(/¯/g, '-').split(/j/i);
            _results = [];
            for (_k = 0, _len = _ref4.length; _k < _len; _k++) {
              x = _ref4[_k];
              if (x === '-') {
                _results.push(Infinity);
              } else if (x === '--') {
                _results.push(-Infinity);
              } else if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          v = a[1] ? new Complex(a[0], a[1]) : a[0];
          return [LDC, new APLArray([v], [])];
        case 'embedded':
          f = Function("return function(_w,_a){return(" + (node[1].replace(/^«|»$/g, '')) + ")};")();
          return [
            EMB, function(_w, _a) {
              return aplify(f(_w, _a));
            }
          ];
        case 'index':
          v = node.scopeNode.vars._index;
          axes = [];
          a = [];
          for (i = _k = 2, _ref4 = node.length; _k < _ref4; i = _k += 1) {
            if (!(c = node[i])) {
              continue;
            }
            axes.push(i - 2);
            a.push.apply(a, render(c));
          }
          a.push(VEC, axes.length, LDC, new APLArray(axes), VEC, 2, GET, v.scopeDepth, v.slot);
          a.push.apply(a, render(node[1]));
          a.push(DYA);
          return a;
        case 'vector':
          fragments = (function() {
            var _l, _ref5, _results;
            _results = [];
            for (i = _l = 1, _ref5 = node.length; _l < _ref5; i = _l += 1) {
              _results.push(render(node[i]));
            }
            return _results;
          })();
          if (all((function() {
            var _l, _len, _results;
            _results = [];
            for (_l = 0, _len = fragments.length; _l < _len; _l++) {
              f = fragments[_l];
              _results.push(f.length === 2 && f[0] === LDC);
            }
            return _results;
          })())) {
            return [
              LDC, new APLArray((function() {
                var _l, _len, _results;
                _results = [];
                for (_l = 0, _len = fragments.length; _l < _len; _l++) {
                  f = fragments[_l];
                  _results.push((x = f[1]).isSimple() ? x.unwrap() : x);
                }
                return _results;
              })())
            ];
          } else {
            return (_ref5 = []).concat.apply(_ref5, __slice.call(fragments).concat([VEC], [node.length - 1]));
          }
          break;
        case 'monadic':
          return render(node[2]).concat(render(node[1]), MON);
        case 'adverb':
          return render(node[1]).concat(render(node[2]), MON);
        case 'dyadic':
        case 'conjunction':
          return render(node[3]).concat(render(node[2]), render(node[1]), DYA);
        case 'hook':
          v = node.scopeNode.vars._hook;
          return render(node[2]).concat(GET, v.scopeDepth, v.slot, render(node[1]), DYA);
        case 'fork':
          u = node.scopeNode.vars._hook;
          v = node.scopeNode.vars._fork1;
          w = node.scopeNode.vars._fork2;
          i = node.length - 1;
          r = render(node[i--]);
          while (i >= 2) {
            r = r.concat(GET, v.scopeDepth, v.slot, render(node[i--]), DYA, GET, w.scopeDepth, w.slot, render(node[i--]), DYA);
          }
          if (i) {
            return r.concat(render(node[1]), GET, u.scopeDepth, u.slot, DYA);
          } else {
            return r;
          }
          break;
        default:
          if (!(0)) {
            throw Error("\"else assert 0\" at src/compiler.coffee:293");
          }
      }
    };
    renderLHS = function(node) {
      var a, axes, c, n, name, v, _j, _k, _ref2, _ref3, _ref4;
      switch (node[0]) {
        case 'symbol':
          name = node[1];
          vars = node.scopeNode.vars;
          if (((_ref2 = (v = vars["set_" + name])) != null ? _ref2.category : void 0) === 2) {
            return [GET, v.scopeDepth, v.slot, MON];
          } else {
            v = vars[name];
            return [SET, v.scopeDepth, v.slot];
          }
          break;
        case 'expr':
          n = node.length - 1;
          a = [SPL, n];
          for (i = _j = 1, _ref3 = node.length; _j < _ref3; i = _j += 1) {
            a.push.apply(a, renderLHS(node[i]));
            a.push(POP);
          }
          return a;
        case 'index':
          v = node.scopeNode.vars._substitute;
          axes = [];
          a = [];
          for (i = _k = 2, _ref4 = node.length; _k < _ref4; i = _k += 1) {
            if (!(c = node[i])) {
              continue;
            }
            axes.push(i - 2);
            a.push.apply(a, render(c));
          }
          a.push(VEC, axes.length);
          a.push.apply(a, render(node[1]));
          a.push(LDC, new APLArray(axes), VEC, 4, GET, v.scopeDepth, v.slot, MON);
          a.push.apply(a, renderLHS(node[1]));
          return a;
        default:
          if (!(0)) {
            throw Error("\"assert 0\" at src/compiler.coffee:328");
          }
      }
    };
    return render(ast);
  };
  prelude = execInternal("⍬←0⍴0\n⍝ ⍬     <=> 0⍴0\n⍝ ⍴⍬    <=> ,0\n⍝# ⍬←5   !!!\n⍝ ⍳0    <=> ⍬\n⍝ ⍴0    <=> ⍬\n⍝ ⍬     <=> ⍬\n⍝ ⍬⍬    <=> ⍬ ⍬\n⍝ 1⍬2⍬3 <=> 1 ⍬ 2 ⍬ 3\n\n~←~⍠{(~⍺∊⍵)/⍺}\n⍝ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"~\"AEIOU\" <=> 'BCDFGHJKLMNPQRSTVWXYZ'\n⍝ 1 2 3 4 5 6~2 4 6                    <=> 1 3 5\n⍝ \"THIS IS TEXT\"~\" \"                   <=> 'THISISTEXT'\n⍝ \"THIS\" \"AND\" \"THAT\"~\"T\"              <=> 'THIS' 'AND' 'THAT'\n⍝ \"THIS\" \"AND\" \"THAT\"~\"AND\"            <=> 'THIS' 'AND' 'THAT'\n⍝ \"THIS\" \"AND\" \"THAT\"~⊂\"AND\"           <=> 'THIS' 'THAT'\n⍝ \"THIS\" \"AND\" \"THAT\"~\"TH\" \"AND\"       <=> 'THIS' 'THAT'\n⍝ 11 12 13 14 15 16~2 3⍴1 2 3 14 5 6   <=> 11 12 13 15 16\n⍝ (2 2⍴⍳4)~2 !!! RANK ERROR\n\n_hook←{⍵⍶⍹⍵;⍺⍶⍹⍵}\n⍝ (+÷)\\3 7 16 ¯294 <=> (3 3.142857142857143 3.1415929203539825 3.141592653921421)\n⍝ (=⌊)123 <=> 1\n⍝ (=⌊)123.4 <=> 0\n⍝ (÷⍟)1000 <=> 144.76482730108395\n\n⊃←{\n  0=⍴⍴⍵:↑⍵\n  0=×/⍴⍵:⍵\n  shape←⍴⍵ ⋄ ⍵←,⍵\n  r←⌈/≢¨shapes←⍴¨⍵ ⍝ maximum rank of all shapes\n  max←↑⌈/shapes←(⍴ ↓ (r⍴1)∘,)¨shapes ⍝ maximum shape of rank adjusted shapes\n  (shape,max)⍴↑⍪/shapes{max↑⍺⍴⍵}¨⍵\n  ;\n  1<⍴⍴⍺:↗'RANK ERROR'\n  x←⍵\n  {\n    1<⍴⍴⍵:↗'RANK ERROR'\n    ⍵←,⍵\n    (⍴⍵)≠⍴⍴x:↗'RANK ERROR'\n    ∨/⍵≥⍴x:↗'INDEX ERROR'\n    x←⊃⍵⌷x\n  }¨⍺\n  x\n}\n⍝ ⊃3            <=> 3\n⍝ ⊃(1 2)(3 4)   <=> 2 2⍴1 2 3 4\n⍝ ⊃(1 2)(3 4 5) <=> 2 3⍴1 2 0 3 4 5\n⍝ ⊃1 2          <=> 1 2\n⍝ ⊃(1 2)3       <=> 2 2⍴1 2 3 0\n⍝ ⊃1(2 3)       <=> 2 2⍴1 0 2 3\n⍝ ⊃2 2⍴1(1 1 2⍴3 4)(5 6)(2 0⍴0) <=> 2 2 1 2 2⍴1 0 0 0 3 4 0 0 5 6 0 0 0 0 0 0\n⍝ ⊃⍬            <=> ⍬\n⍝ ⊃2 3 0⍴0      <=> 2 3 0⍴0\n⍝ ⍬⊃3               <=> 3\n⍝ 2⊃'PICK'          <=> 'C'\n⍝ (⊂1 0)⊃2 2⍴'ABCD' <=> 'C'\n⍝ 1⊃'foo' 'bar'     <=> 'bar'\n⍝ 1 2⊃'foo' 'bar'   <=> 'r'\n⍝ (2 2⍴0)⊃1 2       !!! RANK ERROR\n⍝ (⊂2 1⍴0)⊃2 2⍴0    !!! RANK ERROR\n⍝ (⊂2 2⍴0)⊃1 2      !!! RANK ERROR\n⍝ (⊂2 2)⊃1 2        !!! RANK ERROR\n⍝ (⊂0 2)⊃2 2⍴'ABCD' !!! INDEX ERROR\n\n⍪←{(≢⍵)(×/1↓⍴⍵)⍴⍵; ⍺,[0]⍵}\n⍝ ⍪2 3 4 <=> 3 1⍴2 3 4\n⍝ ⍪0 <=> 1 1⍴0\n⍝ ⍪2 2⍴2 3 4 5 <=> 2 2⍴2 3 4 5\n⍝ ⍴⍪2 3⍴⍳6 <=> 2 3\n⍝ ⍴⍪2 3 4⍴⍳24 <=> 2 12\n⍝ (2 3⍴⍳6)⍪9 <=> 3 3⍴(0 1 2 3 4 5 9 9 9)\n⍝ 1⍪2 <=> 1 2\n\n⊢←{⍵}\n⍝ 123⊢456 <=> 456\n⍝ ⊢456 <=> 456\n\n⊣←{;⍺}\n⍝ 123⊣456 <=> 123\n⍝ ⊣456 <=> ⍬\n\n≢←{⍬⍴(⍴⍵),1; ~⍺≡⍵}\n⍝ ≢0 <=> 1\n⍝ ≢0 0 0 <=> 3\n⍝ ≢⍬ <=> 0\n⍝ ≢2 3⍴⍳6 <=> 2\n⍝ 3≢3 <=> 0\n\n⌹←{\n  norm←{(⍵+.×+⍵)*0.5}\n\n  QR←{ ⍝ QR decomposition\n    n←(⍴⍵)[1]\n    1≥n:{t←norm,⍵ ⋄ (⍵÷t)(⍪t)}⍵\n    m←⌈n÷2\n    a0←((1↑⍴⍵),m)↑⍵\n    a1←(0,m)↓⍵\n    (q0 r0)←∇a0\n    c←(+⍉q0)+.×a1\n    (q1 r1)←∇a1-q0+.×c\n    (q0,q1)((r0,c)⍪((⌊n÷2),-n)↑r1)\n  }\n\n  Rinv←{ ⍝ Inverse of an upper triangular matrix\n    1=n←1↑⍴⍵:÷⍵\n    m←⌈n÷2\n    ai←∇(m,m)↑⍵\n    di←∇(m,m)↓⍵\n    b←(m,m-n)↑⍵\n    bx←-ai+.×b+.×di\n    (ai,bx)⍪((⌊n÷2),-n)↑di\n  }\n\n  0=⍴⍴⍵:÷⍵\n  1=⍴⍴⍵:,∇⍪⍵\n  2≠⍴⍴⍵:↗'ASSERTION ERROR'\n  0∊≥/⍴⍵:↗'ASSERTION ERROR'\n  (Q R)←QR ⍵\n  (Rinv R)+.×+⍉Q\n  ;\n  (⌹⍵)+.×⍺\n}\n⍝ ⌹2 <=> .5\n⍝ ⌹2 2⍴4 3 3 2 <=> 2 2⍴¯2 3 3 ¯4\n⍝ (4 4⍴12 1 4 10 ¯6 ¯5 4 7 ¯4 9 3 4 ¯2 ¯6 7 7)⌹93 81 93.5 120.5 <=>\n⍝ ... .0003898888816687221 ¯.005029566573526544 .04730651764247189 .0705568912859835\n\n⍨←{⍵⍶⍵;⍵⍶⍺}\n⍝ 17-⍨23 <=> 6\n⍝ 7⍴⍨2 3 <=> 2 3⍴7\n⍝ +⍨2    <=> 4\n⍝ -⍨123  <=> 0\n", {
    ctx: vocabulary
  });
  aplify = function(x) {
    var y;
    if (typeof x === 'string') {
      if (x.length === 1) {
        return APLArray.scalar(x);
      } else {
        return new APLArray(x);
      }
    } else if (typeof x === 'number') {
      return APLArray.scalar(x);
    } else if (x instanceof Array) {
      return new APLArray((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          y = x[_i];
          _results.push((y = aplify(y), !y.shape.length ? y.unwrap() : y));
        }
        return _results;
      })());
    } else if (x instanceof APLArray) {
      return x;
    } else {
      return aplError('Cannot aplify object ' + x);
    }
  };
  this.apl = apl = function(aplCode) {
    return exec(aplCode);
  };
  apl.approx = approx;
  if (typeof module !== "undefined" && module !== null) {
    module.exports = apl;
    if (module === (typeof require !== "undefined" && require !== null ? require.main : void 0)) {
      return (function() {
        var arg, b, ctx, file, k, rl, usage, _i, _len, _ref1;
        usage = 'Usage: apl.js filename.apl\n';
        file = null;
        _ref1 = process.argv.slice(2);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arg = _ref1[_i];
          if (arg === '-h' || arg === '--help') {
            process.stderr.write(usage);
            process.exit(0);
          } else if (/^-/.test(arg)) {
            process.stderr.write("unrecognized option: " + arg + "\n" + usage);
            process.exit(1);
          } else if (file != null) {
            process.stderr.write(usage);
            process.exit(1);
          } else {
            file = arg;
          }
        }
        if (file != null) {
          exec(require('fs').readFileSync(file, 'utf8'));
        } else if (!require('tty').isatty()) {
          exec(Buffer.concat((function() {
            var _results;
            _results = [];
            while (true) {
              b = new Buffer(1024);
              if (!(k = require('fs').readSync(0, b, 0, b.length, null))) {
                break;
              }
              _results.push(b.slice(0, k));
            }
            return _results;
          })()).toString('utf8'));
        } else {
          process.stdout.write("ngn apl 2013-11-16\n");
          rl = require('readline').createInterface(process.stdin, process.stdout);
          rl.setPrompt('      ');
          ctx = Object.create(vocabulary);
          rl.on('line', function(line) {
            var e, result;
            try {
              if (!line.match(/^[\ \t\f\r\n]*$/)) {
                result = exec(line, {
                  ctx: ctx
                });
                process.stdout.write(format(result).join('\n') + '\n');
              }
            } catch (_error) {
              e = _error;
              process.stdout.write(e.toString() + '\n');
            }
            rl.prompt();
          });
          rl.on('close', function() {
            process.stdout.write('\n');
            return process.exit(0);
          });
          rl.prompt();
        }
      })();
    }
  }
})();
