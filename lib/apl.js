//usr/bin/env node "$0" $@ ; exit $?
// Generated by CoffeeScript 1.6.3
var APLArray, APLError, Beta, Complex, DYA, DomainError, EMB, GET, IndexError, JEQ, LAM, LDC, LengthError, MON, NonceError, POP, RET, RankError, SET, SPL, SyntaxError, VEC, addVocabulary, adverb, aka, all, apl, aplify, approx, arrayEquals, bool, catenate, compile, compileAST, complexify, compressOrReplicate, conjunction, contains, deal, depthOf, enlist, eps, eq, exec, execInternal, exp, expand, extend, format, getAxisList, grade, innerProduct, lnΓ, match, meta, mix, multiplicitySymbol, negInt, negate, numApprox, numeric, outerProduct, parse, pervasive, prelude, prepareForIndexing, prod, real, reduce, repeat, roll, rotate, scan, simplify, smallFactorials, squish, strideForShape, take, tokenDefs, tokenize, vm, vocabulary, withIdentity, Γ, λ, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;



prod = function(xs) {
  var r, x, _i, _len;
  r = 1;
  for (_i = 0, _len = xs.length; _i < _len; _i++) {
    x = xs[_i];
    r *= x;
  }
  return r;
};
all = function(xs) {
  var x, _i, _len;
  for (_i = 0, _len = xs.length; _i < _len; _i++) {
    x = xs[_i];
    if (!x) {
      return false;
    }
  }
  return true;
};
repeat = function(a, n) {
  var m, tmp0;
  if (!(typeof a === 'string' || a instanceof Array)) {
    throw Error("\"assert typeof a is 'string' or a instanceof Array\" at src/helpers.coffee:6");
  }
  if (!((tmp0 = (n)) === ~~tmp0 && (0) <= tmp0)) {
    throw Error("\"assert isInt n, 0\" at src/helpers.coffee:7");
  }
  if (!n) {
    return a.slice(0, 0);
  }
  m = n * a.length;
  while (a.length * 2 < m) {
    a = a.concat(a);
  }
  return a.concat(a.slice(0, m - a.length));
};
extend = function(x, y) {
  var k;
  for (k in y) {
    x[k] = y[k];
  }
  return x;
};

APLError = function(name, message, opts) {
  var e, k, v, _ref;
  if (message == null) {
    message = '';
  }
  if (!(typeof name === 'string')) {
    throw Error("\"assert typeof name is 'string'\" at src/errors.coffee:2");
  }
  if (!(typeof message === 'string')) {
    throw Error("\"assert typeof message is 'string'\" at src/errors.coffee:3");
  }
  if (opts != null) {
    if (!(typeof opts === 'object')) {
      throw Error("\"assert typeof opts is 'object'\" at src/errors.coffee:5");
    }
    if ((opts.aplCode != null) && (opts.line != null) && (opts.col != null)) {
      if (!(typeof opts.aplCode === 'string')) {
        throw Error("\"assert typeof opts.aplCode is 'string'\" at src/errors.coffee:7");
      }
      if (!(typeof opts.line === 'number')) {
        throw Error("\"assert typeof opts.line is 'number'\" at src/errors.coffee:8");
      }
      if (!(typeof opts.col === 'number')) {
        throw Error("\"assert typeof opts.col is 'number'\" at src/errors.coffee:9");
      }
      if (!((_ref = typeof opts.file) === 'string' || _ref === 'undefined')) {
        throw Error("\"assert typeof opts.file in ['string', 'undefined']\" at src/errors.coffee:10");
      }
      message += "\n" + (opts.file || '-') + ":#" + opts.line + ":" + opts.col + "\n" + (opts.aplCode.split('\n')[opts.line - 1]) + "\n" + (repeat('_', opts.col - 1)) + "^";
    }
  }
  e = Error(message);
  e.name = name;
  for (k in opts) {
    v = opts[k];
    e[k] = v;
  }
  return e;
};
SyntaxError = function(message, opts) {
  return APLError('SYNTAX ERROR', message, opts);
};
DomainError = function(message, opts) {
  return APLError('DOMAIN ERROR', message, opts);
};
LengthError = function(message, opts) {
  return APLError('LENGTH ERROR', message, opts);
};
RankError = function(message, opts) {
  return APLError('RANK ERROR', message, opts);
};
IndexError = function(message, opts) {
  return APLError('INDEX ERROR', message, opts);
};
NonceError = function(message, opts) {
  return APLError('NONCE ERROR', message, opts);
};

APLArray = (function() {
  function APLArray(data, shape, stride, offset) {
    var i, tmp1, tmp2, tmp3, x, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    this.data = data;
    this.shape = shape;
    this.stride = stride;
    this.offset = offset != null ? offset : 0;
    if (this.shape == null) {
      this.shape = [this.data.length];
    }
    if (this.stride == null) {
      this.stride = strideForShape(this.shape);
    }
    if (!(this.data instanceof Array || typeof this.data === 'string')) {
      throw Error("\"assert @data instanceof Array or typeof @data is 'string'\" at src/array.coffee:6");
    }
    if (!(this.shape instanceof Array)) {
      throw Error("\"assert @shape instanceof Array\" at src/array.coffee:7");
    }
    if (!(this.stride instanceof Array)) {
      throw Error("\"assert @stride instanceof Array\" at src/array.coffee:8");
    }
    if (!(this.data.length === 0 || ((tmp1 = this.offset) === ~~tmp1 && ((0) <= (_ref = tmp1) && _ref < this.data.length)))) {
      throw Error("\"assert @data.length is 0 or isInt @offset, 0, @data.length\" at src/array.coffee:9");
    }
    if (!(this.shape.length === this.stride.length)) {
      throw Error("\"assert @shape.length is @stride.length\" at src/array.coffee:10");
    }
    _ref1 = this.shape;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      x = _ref1[_i];
      if (!((tmp2 = (x)) === ~~tmp2 && (0) <= tmp2)) {
        throw Error("\"for x in @shape then assert isInt x, 0\" at src/array.coffee:11");
      }
    }
    if (this.data.length) {
      _ref2 = this.stride;
      for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
        x = _ref2[i];
        if (!((tmp3 = (x)) === ~~tmp3 && ((-this.data.length) <= (_ref3 = tmp3) && _ref3 < (this.data.length + 1)))) {
          throw Error("\"for x, i in @stride then assert isInt x, -@data.length, @data.length + 1\" at src/array.coffee:13");
        }
      }
    } else {
      if (!(prod(this.shape) === 0)) {
        throw Error("\"assert prod(@shape) is 0\" at src/array.coffee:15");
      }
    }
  }

  APLArray.prototype.get = function(indices) {
    var axis, index, p, _i, _len;
    p = this.offset;
    for (axis = _i = 0, _len = indices.length; _i < _len; axis = ++_i) {
      index = indices[axis];
      p += index * this.stride[axis];
    }
    return this.data[p];
  };

  APLArray.prototype.empty = function() {
    var d, _i, _len, _ref;
    _ref = this.shape;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      d = _ref[_i];
      if (!d) {
        return true;
      }
    }
    return false;
  };

  APLArray.prototype.each = function(f) {
    var axis, indices, p;
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:28");
    }
    if (this.empty()) {
      return;
    }
    p = this.offset;
    indices = (function() {
      var _i, _len, _ref, _results;
      _ref = this.shape;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        axis = _ref[_i];
        _results.push(0);
      }
      return _results;
    }).call(this);
    while (true) {
      f(this.data[p], indices);
      axis = this.shape.length - 1;
      while (axis >= 0 && indices[axis] + 1 === this.shape[axis]) {
        p -= indices[axis] * this.stride[axis];
        indices[axis--] = 0;
      }
      if (axis < 0) {
        break;
      }
      indices[axis]++;
      p += this.stride[axis];
    }
  };

  APLArray.prototype.each2 = function(a, f) {
    var axis, indices, p, q, _i, _ref;
    if (!(a instanceof APLArray)) {
      throw Error("\"assert a instanceof APLArray\" at src/array.coffee:44");
    }
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:45");
    }
    if (!(this.shape.length === a.shape.length)) {
      throw Error("\"assert @shape.length is a.shape.length\" at src/array.coffee:46");
    }
    for (axis = _i = 0, _ref = this.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; axis = 0 <= _ref ? ++_i : --_i) {
      if (!(this.shape[axis] === a.shape[axis])) {
        throw Error("\"assert @shape[axis] is a.shape[axis]\" at src/array.coffee:48");
      }
    }
    if (this.empty()) {
      return;
    }
    p = this.offset;
    q = a.offset;
    indices = (function() {
      var _j, _len, _ref1, _results;
      _ref1 = this.shape;
      _results = [];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        axis = _ref1[_j];
        _results.push(0);
      }
      return _results;
    }).call(this);
    while (true) {
      f(this.data[p], a.data[q], indices);
      axis = this.shape.length - 1;
      while (axis >= 0 && indices[axis] + 1 === this.shape[axis]) {
        p -= indices[axis] * this.stride[axis];
        q -= indices[axis] * a.stride[axis];
        indices[axis--] = 0;
      }
      if (axis < 0) {
        break;
      }
      indices[axis]++;
      p += this.stride[axis];
      q += a.stride[axis];
    }
  };

  APLArray.prototype.map = function(f) {
    var data;
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:67");
    }
    data = [];
    this.each(function(x, indices) {
      return data.push(f(x, indices));
    });
    return new APLArray(data, this.shape);
  };

  APLArray.prototype.map2 = function(a, f) {
    var data;
    if (!(a instanceof APLArray)) {
      throw Error("\"assert a instanceof APLArray\" at src/array.coffee:73");
    }
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/array.coffee:74");
    }
    data = [];
    this.each2(a, function(x, y, indices) {
      return data.push(f(x, y, indices));
    });
    return new APLArray(data, this.shape);
  };

  APLArray.prototype.toArray = function(limit) {
    var e, r;
    if (limit == null) {
      limit = Infinity;
    }
    r = [];
    try {
      this.each(function(x) {
        if (r.length >= limit) {
          throw 'break';
        }
        r.push(x);
      });
    } catch (_error) {
      e = _error;
      if (e !== 'break') {
        throw e;
      }
    }
    return r;
  };

  APLArray.prototype.toInt = function(start, end) {
    var r;
    if (start == null) {
      start = -Infinity;
    }
    if (end == null) {
      end = Infinity;
    }
    r = this.unwrap();
    if (typeof r !== 'number' || r !== ~~r || !((start <= r && r < end))) {
      throw DomainError();
    }
    return r;
  };

  APLArray.prototype.toBool = function() {
    return this.toInt(0, 2);
  };

  APLArray.prototype.isSingleton = function() {
    var n, _i, _len, _ref;
    _ref = this.shape;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n !== 1) {
        return false;
      }
    }
    return true;
  };

  APLArray.prototype.isSimple = function() {
    return this.shape.length === 0 && !(this.data[this.offset] instanceof APLArray);
  };

  APLArray.prototype.unwrap = function() {
    if (prod(this.shape) !== 1) {
      throw LengthError();
    }
    return this.data[this.offset];
  };

  APLArray.prototype.getPrototype = function() {
    if (this.empty() || typeof this.data[this.offset] !== 'string') {
      return 0;
    } else {
      return ' ';
    }
  };

  APLArray.prototype.toString = function() {
    return format(this).join('\n');
  };

  return APLArray;

})();
strideForShape = function(shape) {
  var i, r, tmp4, _i, _ref;
  if (!(shape instanceof Array)) {
    throw Error("\"assert shape instanceof Array\" at src/array.coffee:118");
  }
  if (shape.length === 0) {
    return [];
  }
  r = Array(shape.length);
  r[r.length - 1] = 1;
  for (i = _i = _ref = r.length - 2; _i >= 0; i = _i += -1) {
    if (!((tmp4 = shape[i]) === ~~tmp4 && (0) <= tmp4)) {
      throw Error("\"assert isInt shape[i], 0\" at src/array.coffee:123");
    }
    r[i] = r[i + 1] * shape[i + 1];
  }
  return r;
};
APLArray.zero = new APLArray([0], []);
APLArray.one = new APLArray([1], []);
APLArray.zilde = new APLArray([], [0]);
APLArray.scalar = function(x) {
  return new APLArray([x], []);
};
APLArray.bool = [APLArray.zero, APLArray.one];

complexify = function(x) {
  if (typeof x === 'number') {
    return new Complex(x, 0);
  } else if (x instanceof Complex) {
    return x;
  } else {
    throw DomainError();
  }
};
simplify = function(re, im) {
  if (im !== 0) {
    return new Complex(re, im);
  } else {
    return re;
  }
};
Complex = (function() {
  var acos, add, asin, atan, cosh, direction, divide, exp, firstquadrant, floor, gcd, iszero, itimes, log, multiply, negate, negitimes, pow, residue, sinh, sqrt, subtract, tanh;

  function Complex(re, im) {
    this.re = re;
    this.im = im != null ? im : 0;
    if (!(typeof this.re === 'number')) {
      throw Error("\"assert typeof @re is 'number'\" at src/complex.coffee:20");
    }
    if (!(typeof this.im === 'number')) {
      throw Error("\"assert typeof @im is 'number'\" at src/complex.coffee:21");
    }
    if (isNaN(this.re) || isNaN(this.im)) {
      throw DomainError('NaN');
    }
  }

  Complex.prototype.toString = function() {
    return ("" + this.re + "J" + this.im).replace(/-|Infinity/g, '¯');
  };

  Complex.exp = exp = function(x) {
    var r;
    x = complexify(x);
    r = Math.exp(x.re);
    return simplify(r * Math.cos(x.im), r * Math.sin(x.im));
  };

  Complex.log = log = function(x) {
    if (typeof x === 'number' && x > 0) {
      return Math.log(x);
    } else {
      x = complexify(x);
      return simplify(Math.log(Math.sqrt(x.re * x.re + x.im * x.im)), direction(x));
    }
  };

  Complex.conjugate = function(x) {
    return new Complex(x.re, -x.im);
  };

  Complex.negate = negate = function(x) {
    return new Complex(-x.re, -x.im);
  };

  Complex.itimes = itimes = function(x) {
    x = complexify(x);
    return simplify(-x.im, x.re);
  };

  Complex.negitimes = negitimes = function(x) {
    x = complexify(x);
    return simplify(x.im, -x.re);
  };

  Complex.add = add = function(x, y) {
    x = complexify(x);
    y = complexify(y);
    return simplify(x.re + y.re, x.im + y.im);
  };

  Complex.subtract = subtract = function(x, y) {
    x = complexify(x);
    y = complexify(y);
    return simplify(x.re - y.re, x.im - y.im);
  };

  Complex.multiply = multiply = function(x, y) {
    x = complexify(x);
    y = complexify(y);
    return simplify(x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re);
  };

  Complex.divide = divide = function(x, y) {
    var d;
    x = complexify(x);
    y = complexify(y);
    d = y.re * y.re + y.im * y.im;
    return simplify((x.re * y.re + x.im * y.im) / d, (y.re * x.im - y.im * x.re) / d);
  };

  Complex.pow = pow = function(x, y) {
    var _ref;
    if ((typeof x === (_ref = typeof y) && _ref === 'number') && x >= 0) {
      return Math.pow(x, y);
    } else {
      return exp(multiply(y, log(x)));
    }
  };

  Complex.sqrt = sqrt = function(x) {
    if (typeof x === 'number' && x >= 0) {
      return Math.sqrt(x);
    } else {
      return pow(x, 0.5);
    }
  };

  Complex.magnitude = function(x) {
    return Math.sqrt(x.re * x.re + x.im * x.im);
  };

  Complex.direction = direction = function(x) {
    return Math.atan2(x.im, x.re);
  };

  Complex.sin = function(x) {
    return negitimes(sinh(itimes(x)));
  };

  Complex.cos = function(x) {
    return cosh(itimes(x));
  };

  Complex.tan = function(x) {
    return negitimes(tanh(itimes(x)));
  };

  Complex.asin = asin = function(x) {
    x = complexify(x);
    return negitimes(log(add(itimes(x), sqrt(subtract(1, pow(x, 2))))));
  };

  Complex.acos = acos = function(x) {
    var r;
    x = complexify(x);
    r = negitimes(log(add(x, sqrt(subtract(pow(x, 2), 1)))));
    if (r instanceof Complex && (r.re < 0 || (r.re === 0 && r.im < 0))) {
      return negate(r);
    } else {
      return r;
    }
  };

  Complex.atan = atan = function(x) {
    var ix;
    x = complexify(x);
    ix = itimes(x);
    return multiply(new Complex(0, .5), subtract(log(subtract(1, ix)), log(add(1, ix))));
  };

  Complex.sinh = sinh = function(x) {
    var a;
    a = exp(x);
    return multiply(0.5, subtract(a, divide(1, a)));
  };

  Complex.cosh = cosh = function(x) {
    var a;
    a = exp(x);
    return multiply(0.5, add(a, divide(1, a)));
  };

  Complex.tanh = tanh = function(x) {
    var a, b;
    a = exp(x);
    b = divide(1, a);
    return divide(subtract(a, b), add(a, b));
  };

  Complex.asinh = function(x) {
    return itimes(asin(negitimes(x)));
  };

  Complex.acosh = function(x) {
    var sign;
    x = complexify(x);
    sign = x.im > 0 || (x.im === 0 && x.re <= 1) ? 1 : -1;
    return multiply(new Complex(0, sign), acos(x));
  };

  Complex.atanh = function(x) {
    return itimes(atan(negitimes(x)));
  };

  Complex.floor = floor = function(x) {
    var i, im, r, re, _ref, _ref1;
    if (typeof x === 'number') {
      return Math.floor(x);
    } else {
      x = complexify(x);
      _ref = [Math.floor(x.re), Math.floor(x.im)], re = _ref[0], im = _ref[1];
      _ref1 = [x.re - re, x.im - im], r = _ref1[0], i = _ref1[1];
      if (r + i >= 1) {
        if (r >= i) {
          re++;
        } else {
          im++;
        }
      }
      return simplify(re, im);
    }
  };

  Complex.ceil = function(x) {
    var i, im, r, re, _ref, _ref1;
    if (typeof x === 'number') {
      return Math.ceil(x);
    } else {
      x = complexify(x);
      _ref = [Math.ceil(x.re), Math.ceil(x.im)], re = _ref[0], im = _ref[1];
      _ref1 = [re - x.re, im - x.im], r = _ref1[0], i = _ref1[1];
      if (r + i >= 1) {
        if (r >= i) {
          re--;
        } else {
          im--;
        }
      }
      return simplify(re, im);
    }
  };

  iszero = function(x) {
    return x === 0 || (x instanceof Complex && x.re === 0 && x.im === 0);
  };

  Complex.residue = residue = function(x, y) {
    var _ref;
    if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
      if (x === 0) {
        return y;
      } else {
        return y - x * Math.floor(y / x);
      }
    } else {
      if (iszero(x)) {
        return y;
      } else {
        return subtract(y, multiply(x, floor(divide(y, x))));
      }
    }
  };

  Complex.isint = function(x) {
    if (typeof x === 'number') {
      return x === Math.floor(x);
    } else {
      return (x.re === Math.floor(x.re)) && (x.im === Math.floor(x.im));
    }
  };

  firstquadrant = function(x) {
    if (typeof x === 'number') {
      return Math.abs(x);
    } else {
      if (x.re < 0) {
        x = negate(x);
      }
      if (x.im < 0) {
        x = itimes(x);
      }
      if (x.re === 0) {
        x = x.im;
      }
      return x;
    }
  };

  Complex.gcd = gcd = function(x, y) {
    var _ref, _ref1, _ref2;
    if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
      while (y) {
        _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];
      }
      return Math.abs(x);
    } else {
      while (!iszero(y)) {
        _ref2 = [y, residue(y, x)], x = _ref2[0], y = _ref2[1];
      }
      return firstquadrant(x);
    }
  };

  Complex.lcm = function(x, y) {
    var p;
    p = multiply(x, y);
    if (iszero(p)) {
      return p;
    } else {
      return divide(p, gcd(x, y));
    }
  };

  return Complex;

})();

LDC = 'LDC';
VEC = 'VEC';
GET = 'GET';
SET = 'SET';
MON = 'MON';
DYA = 'DYA';
LAM = 'LAM';
RET = 'RET';
POP = 'POP';
SPL = 'SPL';
JEQ = 'JEQ';
EMB = 'EMB';
λ = (function() {
  function λ(code, addr, env) {
    this.code = code;
    this.addr = addr;
    this.env = env;
  }

  λ.prototype.toFunction = function() {
    var _this = this;
    return function(x, y) {
      return vm({
        code: _this.code,
        env: _this.env.concat([[x, _this, y]]),
        pc: _this.addr
      });
    };
  };

  return λ;

})();
vm = function(_arg) {
  var a, code, env, f, frame, n, pc, size, stack, w, x, _i, _len, _ref, _ref1, _ref2;
  code = _arg.code, env = _arg.env, stack = _arg.stack, pc = _arg.pc;
  if (!(code instanceof Array)) {
    throw Error("\"assert code instanceof Array\" at src/vm.coffee:19");
  }
  if (!(env instanceof Array)) {
    throw Error("\"assert env instanceof Array\" at src/vm.coffee:20");
  }
  for (_i = 0, _len = env.length; _i < _len; _i++) {
    frame = env[_i];
    if (!(frame instanceof Array)) {
      throw Error("\"for frame in env then assert frame instanceof Array\" at src/vm.coffee:21");
    }
  }
  if (stack == null) {
    stack = [];
  }
  if (pc == null) {
    pc = 0;
  }
  while (true) {
    switch (code[pc++]) {
      case LDC:
        stack.push(code[pc++]);
        break;
      case VEC:
        stack.push(new APLArray((function() {
          var _j, _len1, _ref, _results;
          _ref = stack.splice(stack.length - code[pc++]);
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            x = _ref[_j];
            if (x.isSimple()) {
              _results.push(x.unwrap());
            } else {
              _results.push(x);
            }
          }
          return _results;
        })()));
        break;
      case GET:
        stack.push(env[code[pc++]][code[pc++]]);
        break;
      case SET:
        env[code[pc++]][code[pc++]] = stack[stack.length - 1];
        break;
      case MON:
        _ref = stack.splice(-2), w = _ref[0], f = _ref[1];
        if (typeof f === 'function') {
          if (w instanceof λ) {
            w = w.toFunction();
          }
          stack.push(f(w));
        } else {
          stack.push(code, pc, env);
          code = f.code;
          pc = f.addr;
          env = f.env.concat([[w, f, null]]);
        }
        break;
      case DYA:
        _ref1 = stack.splice(-3), w = _ref1[0], f = _ref1[1], a = _ref1[2];
        if (typeof f === 'function') {
          if (w instanceof λ) {
            w = w.toFunction();
          }
          if (a instanceof λ) {
            a = a.toFunction();
          }
          stack.push(f(w, a));
        } else {
          stack.push(code, pc, env);
          code = f.code;
          pc = f.addr;
          env = f.env.concat([[w, f, a]]);
        }
        break;
      case LAM:
        size = code[pc++];
        stack.push(new λ(code, pc, env));
        pc += size;
        break;
      case RET:
        if (stack.length === 1) {
          return stack[0];
        }
        _ref2 = stack.splice(-4, 3), code = _ref2[0], pc = _ref2[1], env = _ref2[2];
        break;
      case POP:
        stack.pop();
        break;
      case SPL:
        n = code[pc++];
        a = stack[stack.length - 1].toArray().reverse();
        a = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
            x = a[_j];
            _results.push(x instanceof APLArray ? x : new APLArray([x], []));
          }
          return _results;
        })();
        if (a.length === 1) {
          a = repeat(a, n);
        } else if (a.length !== n) {
          throw LengthError();
        }
        stack.push.apply(stack, a);
        break;
      case JEQ:
        n = code[pc++];
        if (!stack[stack.length - 1].toBool()) {
          pc += n;
        }
        break;
      case EMB:
        frame = env[env.length - 1];
        stack.push(code[pc++](frame[0], frame[2]));
        break;
      default:
        throw Error('Unrecognized instruction: ' + code[pc - 1] + ', pc:' + pc);
    }
  }
};

tokenDefs = [['-', /^(?:[ \t]+|[⍝\#].*)+/], ['newline', /^[\n\r]+/], ['separator', /^[◇⋄]/], ['number', /^¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯)(?:j¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯))?/i], ['string', /^(?:'(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*")+/], ['', /^[\(\)\[\]\{\}:;←]/], ['embedded', /^«[^»]*»/], ['symbol', /^(?:⎕?[a-z_][0-9a-z_]*|⍺⍺|⍵⍵|∇∇|[^¯'":«»])/i]];
tokenize = function(s, opts) {
  var a, col, line, m, re, stack, startCol, startLine, t, tokens, type, _i, _len, _ref;
  if (opts == null) {
    opts = {};
  }
  line = col = 1;
  stack = ['{'];
  tokens = [];
  while (s) {
    startLine = line;
    startCol = col;
    type = null;
    for (_i = 0, _len = tokenDefs.length; _i < _len; _i++) {
      _ref = tokenDefs[_i], t = _ref[0], re = _ref[1];
      if (!(m = s.match(re))) {
        continue;
      }
      type = t || m[0];
      break;
    }
    if (!type) {
      throw SyntaxError('Unrecognized token', {
        file: opts.file,
        line: line,
        col: col,
        s: opts.s
      });
    }
    a = m[0].split('\n');
    line += a.length - 1;
    col = (a.length === 1 ? col : 1) + a[a.length - 1].length;
    s = s.slice(m[0].length);
    if (type !== '-') {
      if (type === '(' || type === '[' || type === '{') {
        stack.push(type);
      } else if (type === ')' || type === ']' || type === '}') {
        stack.pop();
      }
      if (type !== 'newline' || stack[stack.length - 1] === '{') {
        tokens.push({
          type: type,
          startLine: startLine,
          startCol: startCol,
          value: m[0],
          endLine: line,
          endCol: col
        });
      }
    }
  }
  tokens.push({
    type: 'eof',
    value: '',
    startLine: line,
    startCol: col,
    endLine: line,
    endCol: col
  });
  return tokens;
};

parse = function(aplCode, opts) {
  var i, parseBody, parseExpr, parserError, result, token, tokens;
  if (opts == null) {
    opts = {};
  }
  tokens = tokenize(aplCode);
  i = 0;
  token = tokens[i++];
  parserError = function(message) {
    throw SyntaxError(message, {
      file: opts.file,
      line: token.startLine,
      col: token.startCol,
      aplCode: aplCode
    });
  };
  parseBody = function() {
    var body, expr, _ref, _ref1, _ref2, _ref3;
    body = ['body'];
    while (true) {
      if ((_ref = token.type) === 'eof' || _ref === '}') {
        return body;
      }
      while (((_ref1 = token.type) === "separator" || _ref1 === "newline" ? token = tokens[i++] : void 0)) {}
      if ((_ref2 = token.type) === 'eof' || _ref2 === '}') {
        return body;
      }
      expr = parseExpr();
      if (((_ref3 = token.type) === ":" ? token = tokens[i++] : void 0)) {
        expr = ['guard', expr, parseExpr()];
      }
      body.push(expr);
    }
  };
  parseExpr = function() {
    var b, expr, item, t, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    expr = ['expr'];
    while (true) {
      t = token;
      if (((_ref = token.type) === "number" || _ref === "string" || _ref === "symbol" || _ref === "embedded" ? token = tokens[i++] : void 0)) {
        item = [t.type, t.value];
      } else if (((_ref1 = token.type) === "(" ? token = tokens[i++] : void 0)) {
        item = parseExpr();
        if (token.type === ')') {
          token = tokens[i++];
        } else {
          parserError("Expected token of type '" + ')' + "' but got '" + token.type + "'");
        }
      } else if (((_ref2 = token.type) === "{" ? token = tokens[i++] : void 0)) {
        b = parseBody();
        if (token.type === '}') {
          token = tokens[i++];
        } else {
          parserError("Expected token of type '" + '}' + "' but got '" + token.type + "'");
        }
        item = ['lambda', b];
      } else {
        parserError("Encountered unexpected token of type '" + token.type + "'");
      }
      if (((_ref3 = token.type) === "[" ? token = tokens[i++] : void 0)) {
        item = ['index', item];
        while (true) {
          if (((_ref4 = token.type) === ";" ? token = tokens[i++] : void 0)) {
            item.push(null);
          } else if (token.type === ']') {
            item.push(null);
            break;
          } else {
            item.push(parseExpr());
            if (token.type === ']') {
              break;
            } else {
              if (token.type === ';') {
                token = tokens[i++];
              } else {
                parserError("Expected token of type '" + ';' + "' but got '" + token.type + "'");
              }
            }
          }
        }
        if (token.type === ']') {
          token = tokens[i++];
        } else {
          parserError("Expected token of type '" + ']' + "' but got '" + token.type + "'");
        }
      }
      if (((_ref5 = token.type) === "←" ? token = tokens[i++] : void 0)) {
        return expr.concat([['assign', item, parseExpr()]]);
      }
      expr.push(item);
      if (_ref6 = token.type, __indexOf.call(') ] } : ; separator newline eof'.split(' '), _ref6) >= 0) {
        return expr;
      }
    }
  };
  result = parseBody();
  if (token.type === 'eof') {
    token = tokens[i++];
  } else {
    parserError("Expected token of type '" + 'eof' + "' but got '" + token.type + "'");
  }
  return result;
};

vocabulary = {};
addVocabulary = function(h) {
  var alias, k, v, _results;
  _results = [];
  for (k in h) {
    v = h[k];
    vocabulary[k] = v;
    _results.push((function() {
      var _i, _len, _ref, _ref1, _ref2, _results1;
      _ref2 = (_ref = v != null ? (_ref1 = v.aplMetaInfo) != null ? _ref1.aliases : void 0 : void 0) != null ? _ref : [];
      _results1 = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        alias = _ref2[_i];
        _results1.push(vocabulary[alias] = v);
      }
      return _results1;
    })());
  }
  return _results;
};

multiplicitySymbol = function(z) {
  if (z instanceof APLArray) {
    if (z.isSingleton()) {
      return '1';
    } else {
      return '*';
    }
  } else {
    return '.';
  }
};
pervasive = function(_arg) {
  var F, dyad, monad, pervadeDyadic, pervadeMonadic;
  monad = _arg.monad, dyad = _arg.dyad;
  pervadeMonadic = monad ? function(x) {
    var r;
    if (x instanceof APLArray) {
      return x.map(pervadeMonadic);
    } else {
      r = monad(x);
      if (typeof r === 'number' && isNaN(r)) {
        throw DomainError('NaN');
      }
      return r;
    }
  } : function() {
    throw Error('Not implemented');
  };
  pervadeDyadic = dyad ? function(x, y) {
    var axis, r, tx, ty, xi, yi, _i, _ref;
    tx = multiplicitySymbol(x);
    ty = multiplicitySymbol(y);
    switch (tx + ty) {
      case '..':
        r = dyad(x, y);
        if (typeof r === 'number' && isNaN(r)) {
          throw DomainError('NaN');
        }
        return r;
      case '.1':
        return y.map(function(yi) {
          return pervadeDyadic(x, yi);
        });
      case '.*':
        return y.map(function(yi) {
          return pervadeDyadic(x, yi);
        });
      case '1.':
        return x.map(function(xi) {
          return pervadeDyadic(xi, y);
        });
      case '*.':
        return x.map(function(xi) {
          return pervadeDyadic(xi, y);
        });
      case '1*':
        xi = x.unwrap();
        return y.map(function(yi) {
          return pervadeDyadic(xi, yi);
        });
      case '*1':
        yi = y.unwrap();
        return x.map(function(xi) {
          return pervadeDyadic(xi, yi);
        });
      case '11':
        yi = y.unwrap();
        return x.map(function(xi) {
          return pervadeDyadic(xi, yi);
        });
      case '**':
        if (x.shape.length !== y.shape.length) {
          throw RankError();
        }
        for (axis = _i = 0, _ref = x.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; axis = 0 <= _ref ? ++_i : --_i) {
          if (x.shape[axis] !== y.shape[axis]) {
            throw LengthError();
          }
        }
        return x.map2(y, pervadeDyadic);
    }
  } : function() {
    throw Error('Not implemented');
  };
  return F = function(omega, alpha) {
    if (!(omega instanceof APLArray)) {
      throw Error("\"assert omega instanceof APLArray\" at src/vocabulary/vhelpers.coffee:48");
    }
    if (!(alpha instanceof APLArray || typeof alpha === 'undefined')) {
      throw Error("\"assert alpha instanceof APLArray or typeof alpha is 'undefined'\" at src/vocabulary/vhelpers.coffee:49");
    }
    return (alpha ? pervadeDyadic : pervadeMonadic)(omega, alpha);
  };
};
real = function(f) {
  return function(x, y, axis) {
    if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
      return f(x, y, axis);
    } else {
      throw DomainError();
    }
  };
};
numeric = function(f, g) {
  return function(x, y, axis) {
    if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
      return f(x, y, axis);
    } else {
      x = complexify(x);
      if (y != null) {
        y = complexify(y);
      }
      return g(x, y, axis);
    }
  };
};
match = match = function(x, y) {
  var axis, r, _i, _ref;
  if (x instanceof APLArray) {
    if (!(y instanceof APLArray)) {
      return false;
    } else {
      if (x.shape.length !== y.shape.length) {
        return false;
      }
      for (axis = _i = 0, _ref = x.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; axis = 0 <= _ref ? ++_i : --_i) {
        if (x.shape[axis] !== y.shape[axis]) {
          return false;
        }
      }
      r = true;
      x.each2(y, function(xi, yi) {
        if (!match(xi, yi)) {
          return r = false;
        }
      });
      return r;
    }
  } else {
    if (y instanceof APLArray) {
      return false;
    } else {
      if (x instanceof Complex && y instanceof Complex) {
        return x.re === y.re && x.im === y.im;
      } else {
        return x === y;
      }
    }
  }
};
eps = 1e-13;
numApprox = function(x, y) {
  return x === y || Math.abs(x - y) < eps;
};
approx = approx = function(x, y) {
  var axis, r, _i, _ref, _ref1, _ref2;
  if (x instanceof APLArray) {
    if (!(y instanceof APLArray)) {
      return false;
    } else {
      if (x.shape.length !== y.shape.length) {
        return false;
      }
      for (axis = _i = 0, _ref = x.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; axis = 0 <= _ref ? ++_i : --_i) {
        if (x.shape[axis] !== y.shape[axis]) {
          return false;
        }
      }
      r = true;
      x.each2(y, function(xi, yi) {
        if (!approx(xi, yi)) {
          return r = false;
        }
      });
      return r;
    }
  } else {
    if (y instanceof APLArray) {
      return false;
    } else if (!((x != null) && (y != null))) {
      return false;
    } else {
      if (typeof x === 'number') {
        x = new Complex(x);
      }
      if (typeof y === 'number') {
        y = new Complex(y);
      }
      if (x instanceof Complex) {
        return y instanceof Complex && numApprox(x.re, y.re) && numApprox(x.im, y.im);
      } else {
        return (_ref1 = (_ref2 = typeof x['≡'] === "function" ? x['≡'](y) : void 0) != null ? _ref2 : typeof y['≡'] === "function" ? y['≡'](x) : void 0) != null ? _ref1 : x === y;
      }
    }
  }
};
bool = function(x) {
  if (x !== 0 && x !== 1) {
    throw DomainError();
  }
  return x;
};
getAxisList = function(axes, rank) {
  var a, i, tmp5, tmp6, tmp7, x, _i, _len, _ref, _ref1;
  if (!((tmp5 = (rank)) === ~~tmp5 && (0) <= tmp5)) {
    throw Error("\"assert isInt rank, 0\" at src/vocabulary/vhelpers.coffee:119");
  }
  if (typeof axes === 'undefined') {
    return [];
  }
  if (!(axes instanceof APLArray)) {
    throw Error("\"assert axes instanceof APLArray\" at src/vocabulary/vhelpers.coffee:121");
  }
  if (axes.shape.length !== 1 || axes.shape[0] !== 1) {
    throw SyntaxError();
  }
  a = axes.unwrap();
  if (a instanceof APLArray) {
    a = a.toArray();
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      x = a[i];
      if (!((tmp6 = (x)) === ~~tmp6 && ((0) <= (_ref = tmp6) && _ref < (rank)))) {
        throw DomainError();
      }
      if (__indexOf.call(a.slice(0, i), x) >= 0) {
        throw Error('Non-unique axes');
      }
    }
    return a;
  } else if ((tmp7 = (a)) === ~~tmp7 && ((0) <= (_ref1 = tmp7) && _ref1 < (rank))) {
    return [a];
  } else {
    throw DomainError();
  }
};
meta = function(f, name, value) {
  if (!(typeof f === 'function')) {
    throw Error("\"assert typeof f is 'function'\" at src/vocabulary/vhelpers.coffee:139");
  }
  if (!(typeof name === 'string')) {
    throw Error("\"assert typeof name is 'string'\" at src/vocabulary/vhelpers.coffee:140");
  }
  (f.aplMetaInfo != null ? f.aplMetaInfo : f.aplMetaInfo = {})[name] = value;
  return f;
};
withIdentity = function(x, f) {
  if (!(x instanceof APLArray)) {
    x = APLArray.scalar(x);
  }
  return meta(f, 'identity', x);
};
adverb = function(f) {
  return meta(f, 'isAdverb', true);
};
conjunction = function(f) {
  return meta(f, 'isConjunction', true);
};
aka = function(aliases, f) {
  if (typeof aliases === 'string') {
    aliases = [aliases];
  } else {
    if (!(aliases instanceof Array)) {
      throw Error("\"assert aliases instanceof Array\" at src/vocabulary/vhelpers.coffee:155");
    }
  }
  return meta(f, 'aliases', aliases);
};

addVocabulary({
  '+': withIdentity(0, pervasive({
    monad: numeric((function(x) {
      return x;
    }), Complex.conjugate),
    dyad: numeric((function(y, x) {
      return x + y;
    }), function(y, x) {
      return Complex.add(x, y);
    })
  })),
  '-': aka('−', withIdentity(0, pervasive({
    monad: numeric((function(x) {
      return -x;
    }), Complex.negate),
    dyad: numeric((function(y, x) {
      return x - y;
    }), function(y, x) {
      return Complex.subtract(x, y);
    })
  }))),
  '×': withIdentity(1, pervasive({
    monad: numeric((function(x) {
      return (x > 0) - (x < 0);
    }), function(x) {
      var d;
      d = Math.sqrt(x.re * x.re + x.im * x.im);
      return simplify(x.re / d, x.im / d);
    }),
    dyad: numeric((function(y, x) {
      return x * y;
    }), function(y, x) {
      return Complex.multiply(x, y);
    })
  })),
  '÷': withIdentity(1, pervasive({
    monad: numeric((function(x) {
      return 1 / x;
    }), function(x) {
      var d;
      d = x.re * x.re + x.im * x.im;
      return simplify(x.re / d, -x.im / d);
    }),
    dyad: numeric((function(y, x) {
      return x / y;
    }), function(y, x) {
      return Complex.divide(x, y);
    })
  })),
  '*': aka('⋆', withIdentity(1, pervasive({
    monad: exp = numeric(Math.exp, Complex.exp),
    dyad: function(y, x) {
      return Complex.pow(x, y);
    }
  }))),
  '⍟': pervasive({
    monad: Complex.log,
    dyad: function(y, x) {
      var _ref;
      if ((typeof x === (_ref = typeof y) && _ref === 'number') && x > 0 && y > 0) {
        return Math.log(y) / Math.log(x);
      } else {
        return Complex.divide(Complex.log(y), Complex.log(x));
      }
    }
  }),
  '|': aka('∣', withIdentity(0, pervasive({
    monad: numeric((function(x) {
      return Math.abs(x);
    }), Complex.magnitude),
    dyad: function(y, x) {
      return Complex.residue(x, y);
    }
  })))
});

addVocabulary({
  '\\': adverb(function(omega, alpha, axis) {
    if (typeof omega === 'function') {
      return scan(omega, void 0, axis);
    } else {
      return expand(omega, alpha, axis);
    }
  }),
  '⍀': adverb(function(omega, alpha, axis) {
    if (axis == null) {
      axis = APLArray.zero;
    }
    if (typeof omega === 'function') {
      return scan(omega, void 0, axis);
    } else {
      return expand(omega, alpha, axis);
    }
  })
});
scan = function(f, g, axis) {
  if (!(typeof g === 'undefined')) {
    throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/backslash.coffee:44");
  }
  return function(omega, alpha) {
    if (!(alpha == null)) {
      throw Error("\"assert not alpha?\" at src/vocabulary/backslash.coffee:46");
    }
    if (omega.shape.length === 0) {
      return omega;
    }
    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
    return omega.map(function(x, indices) {
      var a, index, j, p, y, _i, _j, _len, _ref;
      p = omega.offset;
      for (a = _i = 0, _len = indices.length; _i < _len; a = ++_i) {
        index = indices[a];
        p += index * omega.stride[a];
      }
      if (!(x instanceof APLArray)) {
        x = APLArray.scalar(x);
      }
      for (j = _j = 0, _ref = indices[axis]; _j < _ref; j = _j += 1) {
        p -= omega.stride[axis];
        y = omega.data[p];
        if (!(y instanceof APLArray)) {
          y = APLArray.scalar(y);
        }
        x = f(x, y);
      }
      if (x.shape.length === 0) {
        x = x.unwrap();
      }
      return x;
    });
  };
};
expand = function(omega, alpha, axis) {
  var a, b, data, filler, i, indices, p, shape, tmp8, x, _i, _len, _ref;
  if (omega.shape.length === 0) {
    throw NonceError('Expand of scalar not implemented');
  }
  axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  a = alpha.toArray();
  shape = omega.shape.slice(0);
  shape[axis] = a.length;
  b = [];
  i = 0;
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    x = a[_i];
    if (!((tmp8 = (x)) === ~~tmp8 && ((0) <= (_ref = tmp8) && _ref < (2)))) {
      throw DomainError();
    }
    b.push(x > 0 ? i++ : null);
  }
  if (i !== omega.shape[axis]) {
    throw LengthError();
  }
  data = [];
  if (shape[axis] !== 0 && !omega.empty()) {
    filler = omega.getPrototype();
    p = omega.offset;
    indices = repeat([0], shape.length);
    while (true) {
      x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
      data.push(x);
      i = shape.length - 1;
      while (i >= 0 && indices[i] + 1 === shape[i]) {
        if (i !== axis) {
          p -= omega.stride[i] * indices[i];
        }
        indices[i--] = 0;
      }
      if (i < 0) {
        break;
      }
      if (i !== axis) {
        p += omega.stride[i];
      }
      indices[i]++;
    }
  }
  return new APLArray(data, shape);
};

addVocabulary({
  '○': pervasive({
    monad: numeric((function(x) {
      return Math.PI * x;
    }), function(x) {
      return new Complex(Math.PI * x.re, Math.PI * x.im);
    }),
    dyad: function(x, i) {
      var a, b, t;
      if (typeof x === 'number') {
        switch (i) {
          case -12:
            return Complex.exp(simplify(0, x));
          case -11:
            return simplify(0, x);
          case -10:
            return x;
          case -9:
            return x;
          case -8:
            return simplify(0, -Math.sqrt(1 + x * x));
          case -7:
            return Complex.atanh(x);
          case -6:
            return Complex.acosh(x);
          case -5:
            return Complex.asinh(x);
          case -4:
            t = Complex.sqrt(x * x - 1);
            if (x < -1) {
              return -t;
            } else {
              return t;
            }
            break;
          case -3:
            return Complex.atan(x);
          case -2:
            return Complex.acos(x);
          case -1:
            return Complex.asin(x);
          case 0:
            return Complex.sqrt(1 - x * x);
          case 1:
            return Math.sin(x);
          case 2:
            return Math.cos(x);
          case 3:
            return Math.tan(x);
          case 4:
            return Math.sqrt(1 + x * x);
          case 5:
            a = Math.exp(x);
            b = 1 / a;
            return 0.5 * (a - b);
          case 6:
            a = Math.exp(x);
            b = 1 / a;
            return 0.5 * (a + b);
          case 7:
            a = Math.exp(x);
            b = 1 / a;
            return (a - b) / (a + b);
          case 8:
            return Complex.sqrt(-1 - x * x);
          case 9:
            return x;
          case 10:
            return Math.abs(x);
          case 11:
            return 0;
          case 12:
            return 0;
          default:
            throw DomainError('Unknown circular or hyperbolic function ' + i);
        }
      } else if (x instanceof Complex) {
        switch (i) {
          case -12:
            return Complex.exp(simplify(-x.im, x.re));
          case -11:
            return Complex.itimes(x);
          case -10:
            return Complex.conjugate(x);
          case -9:
            return x;
          case -8:
            t = Complex.subtract(-1, Complex.multiply(x, x));
            return Complex.negate(Complex.sqrt(t));
          case -7:
            return Complex.atanh(x);
          case -6:
            return Complex.acosh(x);
          case -5:
            return Complex.asinh(x);
          case -4:
            if (x.re === -1 && x.im === 0) {
              return 0;
            } else {
              a = Complex.add(x, 1);
              b = Complex.subtract(x, 1);
              return Complex.multiply(a, Complex.sqrt(Complex.divide(b, a)));
            }
            break;
          case -3:
            return Complex.atan(x);
          case -2:
            return Complex.acos(x);
          case -1:
            return Complex.asin(x);
          case 0:
            return Complex.sqrt(Complex.subtract(1, Complex.multiply(x, x)));
          case 1:
            return Complex.sin(x);
          case 2:
            return Complex.cos(x);
          case 3:
            return Complex.tan(x);
          case 4:
            return Complex.sqrt(Complex.add(1, Complex.multiply(x, x)));
          case 5:
            return Complex.sinh(x);
          case 6:
            return Complex.cosh(x);
          case 7:
            return Complex.tanh(x);
          case 8:
            return Complex.sqrt(Complex.subtract(-1, Complex.multiply(x, x)));
          case 9:
            return x.re;
          case 10:
            return Complex.magnitude(x);
          case 11:
            return x.im;
          case 12:
            return Complex.direction(x);
          default:
            throw DomainError('Unknown circular or hyperbolic function ' + i);
        }
      } else {
        throw DomainError();
      }
    }
  })
});

addVocabulary({
  ',': function(omega, alpha, axis) {
    var data;
    if (alpha) {
      return catenate(omega, alpha, axis);
    } else {
      data = [];
      omega.each(function(x) {
        return data.push(x);
      });
      return new APLArray(data);
    }
  },
  '⍪': function(omega, alpha, axis) {
    var data, n, _ref;
    if (axis == null) {
      axis = APLArray.zero;
    }
    if (alpha) {
      return catenate(omega, alpha, axis);
    } else {
      data = omega.toArray();
      n = (_ref = omega.shape[0]) != null ? _ref : 1;
      return new APLArray(data, [n, data.length / n]);
    }
  }
});
catenate = function(omega, alpha, axis) {
  var a, data, i, nAxes, p, pIndices, q, r, rStride, s, shape, stride, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp9, _i, _j, _ref, _ref1;
  if (!(alpha)) {
    throw Error("\"assert alpha\" at src/vocabulary/comma.coffee:62");
  }
  if (!(typeof axis === 'undefined' || axis instanceof APLArray)) {
    throw Error("\"assert typeof axis is 'undefined' or axis instanceof APLArray\" at src/vocabulary/comma.coffee:63");
  }
  nAxes = Math.max(alpha.shape.length, omega.shape.length);
  if (axis) {
    axis = axis.unwrap();
    if (typeof axis !== 'number') {
      throw DomainError();
    }
    if (!((-1 < axis && axis < nAxes))) {
      throw RankError();
    }
  } else {
    axis = nAxes - 1;
  }
  if (alpha.shape.length === 0 && omega.shape.length === 0) {
    return new APLArray([alpha.unwrap(), omega.unwrap()]);
  } else if (alpha.shape.length === 0) {
    s = omega.shape.slice(0);
    if ((tmp9 = (axis)) === ~~tmp9) {
      s[axis] = 1;
    }
    alpha = new APLArray([alpha.unwrap()], s, repeat([0], omega.shape.length));
  } else if (omega.shape.length === 0) {
    s = alpha.shape.slice(0);
    if ((tmp10 = (axis)) === ~~tmp10) {
      s[axis] = 1;
    }
    omega = new APLArray([omega.unwrap()], s, repeat([0], alpha.shape.length));
  } else if (alpha.shape.length + 1 === omega.shape.length) {
    if (!((tmp11 = (axis)) === ~~tmp11)) {
      throw RankError();
    }
    shape = alpha.shape.slice(0);
    shape.splice(axis, 0, 1);
    stride = alpha.stride.slice(0);
    stride.splice(axis, 0, 0);
    alpha = new APLArray(alpha.data, shape, stride, alpha.offset);
  } else if (alpha.shape.length === omega.shape.length + 1) {
    if (!((tmp12 = (axis)) === ~~tmp12)) {
      throw RankError();
    }
    shape = omega.shape.slice(0);
    shape.splice(axis, 0, 1);
    stride = omega.stride.slice(0);
    stride.splice(axis, 0, 0);
    omega = new APLArray(omega.data, shape, stride, omega.offset);
  } else if (alpha.shape.length !== omega.shape.length) {
    throw RankError();
  }
  if (!(alpha.shape.length === omega.shape.length)) {
    throw Error("\"assert alpha.shape.length is omega.shape.length\" at src/vocabulary/comma.coffee:100");
  }
  for (i = _i = 0, _ref = alpha.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (i !== axis && alpha.shape[i] !== omega.shape[i]) {
      throw LengthError();
    }
  }
  shape = alpha.shape.slice(0);
  if ((tmp13 = (axis)) === ~~tmp13) {
    shape[axis] += omega.shape[axis];
  } else {
    shape.splice(Math.ceil(axis), 0, 2);
  }
  data = Array(prod(shape));
  stride = Array(shape.length);
  stride[shape.length - 1] = 1;
  for (i = _j = _ref1 = shape.length - 2; _j >= 0; i = _j += -1) {
    stride[i] = stride[i + 1] * shape[i + 1];
  }
  if ((tmp14 = (axis)) === ~~tmp14) {
    rStride = stride;
  } else {
    rStride = stride.slice(0);
    rStride.splice(Math.ceil(axis), 1);
  }
  if (!alpha.empty()) {
    r = 0;
    p = alpha.offset;
    pIndices = repeat([0], alpha.shape.length);
    while (true) {
      data[r] = alpha.data[p];
      a = pIndices.length - 1;
      while (a >= 0 && pIndices[a] + 1 === alpha.shape[a]) {
        p -= pIndices[a] * alpha.stride[a];
        r -= pIndices[a] * rStride[a];
        pIndices[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += alpha.stride[a];
      r += rStride[a];
      pIndices[a]++;
    }
  }
  if (!omega.empty()) {
    r = (tmp15 = (axis)) === ~~tmp15 ? stride[axis] * alpha.shape[axis] : stride[Math.ceil(axis)];
    q = omega.offset;
    pIndices = repeat([0], omega.shape.length);
    while (true) {
      data[r] = omega.data[q];
      a = pIndices.length - 1;
      while (a >= 0 && pIndices[a] + 1 === omega.shape[a]) {
        q -= pIndices[a] * omega.stride[a];
        r -= pIndices[a] * rStride[a];
        pIndices[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      q += omega.stride[a];
      r += rStride[a];
      pIndices[a]++;
    }
  }
  return new APLArray(data, shape, stride);
};

addVocabulary({
  '⍨': adverb(function(f, g) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/commute.coffee:14");
    }
    if (!(g == null)) {
      throw Error("\"assert not g?\" at src/vocabulary/commute.coffee:15");
    }
    return function(omega, alpha, axis) {
      if (alpha) {
        return f(alpha, omega, axis);
      } else {
        return f(omega, omega, axis);
      }
    };
  })
});

addVocabulary({
  '=': withIdentity(1, pervasive({
    dyad: eq = function(y, x) {
      if (x instanceof Complex && y instanceof Complex) {
        return +(x.re === y.re && x.im === y.im);
      } else {
        return +(x === y);
      }
    }
  })),
  '≠': withIdentity(0, pervasive({
    dyad: function(y, x) {
      return 1 - eq(y, x);
    }
  })),
  '<': withIdentity(0, pervasive({
    dyad: real(function(y, x) {
      return +(x < y);
    })
  })),
  '>': withIdentity(0, pervasive({
    dyad: real(function(y, x) {
      return +(x > y);
    })
  })),
  '≤': withIdentity(1, pervasive({
    dyad: real(function(y, x) {
      return +(x <= y);
    })
  })),
  '≥': withIdentity(1, pervasive({
    dyad: real(function(y, x) {
      return +(x >= y);
    })
  })),
  '≡': function(omega, alpha) {
    if (alpha) {
      return APLArray.bool[+match(omega, alpha)];
    } else {
      return new APLArray([depthOf(omega)], []);
    }
  },
  '≢': function(omega, alpha) {
    if (alpha) {
      return APLArray.bool[+(!match(omega, alpha))];
    } else {
      if (omega.shape.length) {
        return new APLArray([omega.shape[0]], []);
      } else {
        return APLArray.one;
      }
    }
  }
});
depthOf = function(x) {
  var r;
  if (x instanceof APLArray) {
    if (x.shape.length === 0 && !(x.data[0] instanceof APLArray)) {
      return 0;
    }
    r = 0;
    x.each(function(y) {
      return r = Math.max(r, depthOf(y));
    });
    return r + 1;
  } else {
    return 0;
  }
};

addVocabulary({
  '∘': conjunction(function(g, f) {
    if (typeof f === 'function') {
      if (typeof g === 'function') {
        return function(omega, alpha) {
          return f(g(omega), alpha);
        };
      } else {
        return function(omega, alpha) {
          if (!(alpha == null)) {
            throw Error("\"assert not alpha?\" at src/vocabulary/compose.coffee:20");
          }
          return f(g, omega);
        };
      }
    } else {
      if (!(typeof g === 'function')) {
        throw Error("\"assert typeof g is 'function'\" at src/vocabulary/compose.coffee:23");
      }
      return function(omega, alpha) {
        if (!(alpha == null)) {
          throw Error("\"assert not alpha?\" at src/vocabulary/compose.coffee:25");
        }
        return g(omega, f);
      };
    }
  })
});

addVocabulary({
  '∪': function(omega, alpha) {
    var a, data, _i, _len, _ref;
    if (alpha) {
      data = [];
      _ref = [alpha, omega];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        if (a.shape.length > 1) {
          throw RankError();
        }
        a.each(function(x) {
          if (!contains(data, x)) {
            return data.push(x);
          }
        });
      }
      return new APLArray(data);
    } else {
      data = [];
      omega.each(function(x) {
        if (!contains(data, x)) {
          return data.push(x);
        }
      });
      return new APLArray(data);
    }
  },
  '∩': function(omega, alpha) {
    var b, data, x, _i, _len, _ref;
    if (alpha) {
      data = [];
      b = omega.toArray();
      _ref = alpha.toArray();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        if (contains(b, x)) {
          data.push(x);
        }
      }
      return new APLArray(data);
    } else {
      throw Error('Not implemented');
    }
  }
});
contains = function(a, x) {
  var y, _i, _len;
  if (!(a instanceof Array)) {
    throw Error("\"assert a instanceof Array\" at src/vocabulary/cupcap.coffee:57");
  }
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    y = a[_i];
    if (match(x, y)) {
      return true;
    }
  }
  return false;
};

addVocabulary({
  '⊥': function(omega, alpha) {
    var a, b, data, firstDimB, i, j, k, lastDimA, x, y, z, _i, _j, _k, _ref, _ref1, _ref2;
    if (!(alpha)) {
      throw Error("\"assert alpha\" at src/vocabulary/decode.coffee:53");
    }
    if (alpha.shape.length === 0) {
      alpha = new APLArray([alpha.unwrap()]);
    }
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    lastDimA = alpha.shape[alpha.shape.length - 1];
    firstDimB = omega.shape[0];
    if (lastDimA !== 1 && firstDimB !== 1 && lastDimA !== firstDimB) {
      throw LengthError();
    }
    a = alpha.toArray();
    b = omega.toArray();
    data = [];
    for (i = _i = 0, _ref = a.length / lastDimA; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = b.length / firstDimB; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        x = a.slice(i * lastDimA, (i + 1) * lastDimA);
        y = (function() {
          var _k, _results;
          _results = [];
          for (k = _k = 0; 0 <= firstDimB ? _k < firstDimB : _k > firstDimB; k = 0 <= firstDimB ? ++_k : --_k) {
            _results.push(b[j + k * (b.length / firstDimB)]);
          }
          return _results;
        })();
        if (x.length === 1) {
          x = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (_k = 0, _ref2 = y.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
              _results.push(x[0]);
            }
            return _results;
          })();
        }
        if (y.length === 1) {
          y = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (_k = 0, _ref2 = x.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
              _results.push(y[0]);
            }
            return _results;
          })();
        }
        z = y[0];
        for (k = _k = 1, _ref2 = y.length; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 1 <= _ref2 ? ++_k : --_k) {
          z = z * x[k] + y[k];
        }
        data.push(z);
      }
    }
    return new APLArray(data, alpha.shape.slice(0, -1).concat(omega.shape.slice(1)));
  }
});

addVocabulary({
  '⊃': function(omega, alpha) {
    var i, path, pick, x, _i, _j, _len, _ref;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      x = omega;
      path = alpha.toArray();
      for (_i = 0, _len = path.length; _i < _len; _i++) {
        pick = path[_i];
        if (pick instanceof APLArray) {
          if (pick.shape.length > 1) {
            throw RankError();
          }
          pick = pick.toArray();
        } else {
          pick = [pick];
        }
        if (pick.length !== x.shape.length) {
          throw RankError();
        }
        for (i = _j = 0, _ref = pick.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
          if (pick[i] >= x.shape[i]) {
            throw IndexError();
          }
        }
        x = x.get(pick);
        if (!(x instanceof APLArray)) {
          x = APLArray.scalar(x);
        }
      }
      return x;
    } else {
      if (omega.empty()) {
        return APLArray.zero;
      }
      x = omega.get([]);
      if (x instanceof APLArray) {
        return x;
      } else {
        return APLArray.scalar(x);
      }
    }
  }
});

addVocabulary({
  '.': conjunction(function(g, f) {
    if (f === vocabulary['∘']) {
      return outerProduct(g);
    } else {
      return innerProduct(g, f);
    }
  })
});
outerProduct = function(f) {
  if (!(typeof f === 'function')) {
    throw Error("\"assert typeof f is 'function'\" at src/vocabulary/dot.coffee:39");
  }
  return function(omega, alpha) {
    var a, b, data, x, y, z, _i, _j, _len, _len1;
    if (!alpha) {
      throw Error('Adverb ∘. (Outer product) can be applied to dyadic verbs only');
    }
    a = alpha.toArray();
    b = omega.toArray();
    data = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
        y = b[_j];
        if (!(x instanceof APLArray)) {
          x = APLArray.scalar(x);
        }
        if (!(y instanceof APLArray)) {
          y = APLArray.scalar(y);
        }
        z = f(y, x);
        if (z.shape.length === 0) {
          z = z.unwrap();
        }
        data.push(z);
      }
    }
    return new APLArray(data, alpha.shape.concat(omega.shape));
  };
};
innerProduct = function(g, f) {
  var F, G, each, enclose;
  each = vocabulary['¨'];
  enclose = vocabulary['⊂'];
  F = each(reduce(f));
  G = outerProduct(g);
  return function(omega, alpha) {
    if (alpha.shape.length === 0) {
      alpha = new APLArray([alpha.unwrap()]);
    }
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    return F(G(enclose(omega, void 0, new APLArray([0])), enclose(alpha, void 0, new APLArray([alpha.shape.length - 1]))));
  };
};

addVocabulary({
  '↓': function(omega, alpha, axis) {
    var a, array, data, i, ishape, obound, offset, oshape, shape, tmp16, x, _i, _j, _k, _len, _len1;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      a = alpha.toArray();
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        if (!((tmp16 = (x)) === ~~tmp16)) {
          throw DomainError();
        }
      }
      if (omega.shape.length === 0) {
        omega = new APLArray(omega.data, repeat([1], a.length), omega.stride, omega.offset);
      } else {
        if (a.length > omega.shape.length) {
          throw RankError();
        }
      }
      shape = omega.shape.slice(0);
      offset = omega.offset;
      for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
        x = a[i];
        shape[i] = Math.max(0, omega.shape[i] - Math.abs(x));
        if (x > 0) {
          offset += x * omega.stride[i];
        }
      }
      if (prod(shape) === 0) {
        return new APLArray([], shape);
      } else {
        return new APLArray(omega.data, shape, omega.stride, offset);
      }
    } else {
      if (omega.shape.length === 0) {
        throw NonceError('Split of scalar not implemented');
      }
      oshape = omega.shape.slice(0, omega.shape.length - 1);
      obound = oshape.reduce((function(a, b) {
        return a * b;
      }), 1);
      ishape = omega.shape[omega.shape.length - 1];
      array = omega.toArray();
      data = [];
      for (i = _k = 0; 0 <= obound ? _k < obound : _k > obound; i = 0 <= obound ? ++_k : --_k) {
        offset = i * ishape;
        data.push(new APLArray(array.slice(offset, offset + ishape)));
      }
      return new APLArray(data, oshape);
    }
  }
});

addVocabulary({
  '¨': adverb(function(f, g) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/each.coffee:18");
    }
    if (!(typeof g === 'undefined')) {
      throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/each.coffee:19");
    }
    return function(omega, alpha) {
      var x, y;
      if (!alpha) {
        return omega.map(function(x) {
          var r;
          if (!(x instanceof APLArray)) {
            x = new APLArray([x], []);
          }
          r = f(x);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:25");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else if (arrayEquals(alpha.shape, omega.shape)) {
        return omega.map2(alpha, function(x, y) {
          var r;
          if (!(x instanceof APLArray)) {
            x = new APLArray([x], []);
          }
          if (!(y instanceof APLArray)) {
            y = new APLArray([y], []);
          }
          r = f(x, y);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:32");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else if (alpha.isSingleton()) {
        y = alpha.data[0] instanceof APLArray ? alpha.unwrap() : alpha;
        return omega.map(function(x) {
          var r;
          if (!(x instanceof APLArray)) {
            x = new APLArray([x], []);
          }
          r = f(x, y);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:39");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else if (omega.isSingleton()) {
        x = omega.data[0] instanceof APLArray ? omega.unwrap() : omega;
        return alpha.map(function(y) {
          var r;
          if (!(y instanceof APLArray)) {
            y = new APLArray([y], []);
          }
          r = f(x, y);
          if (!(r instanceof APLArray)) {
            throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:46");
          }
          if (r.shape.length === 0) {
            return r.unwrap();
          } else {
            return r;
          }
        });
      } else {
        throw LengthError();
      }
    };
  })
});
arrayEquals = function(a, b) {
  var i, x, _i, _len;
  if (!(a instanceof Array)) {
    throw Error("\"assert a instanceof Array\" at src/vocabulary/each.coffee:52");
  }
  if (!(b instanceof Array)) {
    throw Error("\"assert b instanceof Array\" at src/vocabulary/each.coffee:53");
  }
  if (a.length !== b.length) {
    return false;
  }
  for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
    x = a[i];
    if (x !== b[i]) {
      return false;
    }
  }
  return true;
};

addVocabulary({
  '⊂': function(omega, alpha, axes) {
    var a, axis, data, indices, p, resultAxes, shape, stride, unitShape, unitStride, _i, _ref, _results;
    if (alpha) {
      throw Error('Not implemented');
    } else {
      axes = axes != null ? getAxisList(axes, omega.shape.length) : (function() {
        _results = [];
        for (var _i = 0, _ref = omega.shape.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      if (omega.isSimple()) {
        return omega;
      }
      unitShape = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = axes.length; _j < _len; _j++) {
          axis = axes[_j];
          _results1.push(omega.shape[axis]);
        }
        return _results1;
      })();
      unitStride = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = axes.length; _j < _len; _j++) {
          axis = axes[_j];
          _results1.push(omega.stride[axis]);
        }
        return _results1;
      })();
      resultAxes = (function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (axis = _j = 0, _ref1 = omega.shape.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; axis = 0 <= _ref1 ? ++_j : --_j) {
          if (__indexOf.call(axes, axis) < 0) {
            _results1.push(axis);
          }
        }
        return _results1;
      })();
      shape = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
          axis = resultAxes[_j];
          _results1.push(omega.shape[axis]);
        }
        return _results1;
      })();
      stride = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
          axis = resultAxes[_j];
          _results1.push(omega.stride[axis]);
        }
        return _results1;
      })();
      data = [];
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        data.push(new APLArray(omega.data, unitShape, unitStride, p));
        a = indices.length - 1;
        while (a >= 0 && indices[a] + 1 === shape[a]) {
          p -= indices[a] * stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += stride[a];
        indices[a]++;
      }
      return new APLArray(data, shape);
    }
  }
});

addVocabulary({
  '⊤': function(omega, alpha) {
    var a, b, data, i, isNeg, j, k, m, n, shape, x, y, _i, _j, _k, _len, _ref;
    if (!(alpha)) {
      throw Error("\"assert alpha\" at src/vocabulary/encode.coffee:40");
    }
    a = alpha.toArray();
    b = omega.toArray();
    shape = alpha.shape.concat(omega.shape);
    data = Array(prod(shape));
    n = alpha.shape.length ? alpha.shape[0] : 1;
    m = a.length / n;
    for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
      for (j = _j = 0, _len = b.length; _j < _len; j = ++_j) {
        y = b[j];
        if (isNeg = y < 0) {
          y = -y;
        }
        for (k = _k = _ref = n - 1; _k >= 0; k = _k += -1) {
          x = a[k * m + i];
          if (x === 0) {
            data[(k * m + i) * b.length + j] = y;
            y = 0;
          } else {
            data[(k * m + i) * b.length + j] = y % x;
            y = Math.round((y - (y % x)) / x);
          }
        }
      }
    }
    return new APLArray(data, shape);
  }
});

addVocabulary({
  '∊': aka('∈', function(omega, alpha) {
    var a, data;
    if (alpha) {
      a = omega.toArray();
      return alpha.map(function(x) {
        var y, _i, _len;
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          y = a[_i];
          if (match(x, y)) {
            return 1;
          }
        }
        return 0;
      });
    } else {
      data = [];
      enlist(omega, data);
      return new APLArray(data);
    }
  })
});
enlist = function(x, r) {
  if (x instanceof APLArray) {
    return x.each(function(y) {
      return enlist(y, r);
    });
  } else {
    return r.push(x);
  }
};

addVocabulary({
  '!': withIdentity(1, pervasive({
    monad: real(function(x) {
      var tmp17;
      if (!((tmp17 = (x)) === ~~tmp17)) {
        return Γ(x + 1);
      } else if (x < 0) {
        throw DomainError();
      } else if (x < smallFactorials.length) {
        return smallFactorials[x];
      } else {
        return Math.round(Γ(x + 1));
      }
    }),
    dyad: Beta = real(function(n, k) {
      var r, tmp18, tmp19;
      r = (function() {
        switch (4 * negInt(k) + 2 * negInt(n) + negInt(n - k)) {
          case 0x0:
            return Math.exp(lnΓ(n + 1) - lnΓ(k + 1) - lnΓ(n - k + 1));
          case 0x1:
            return 0;
          case 0x2:
            throw DomainError();
            break;
          case 0x3:
            return Math.pow(-1, k) * Beta(k - n - 1, k);
          case 0x4:
            return 0;
          case 0x5:
            break;
          case 0x6:
            return Math.pow(-1, n - k) * Beta(Math.abs(k + 1), Math.abs(n + 1));
          case 0x7:
            return 0;
        }
      })();
      if (((tmp18 = (n)) === ~~tmp18) && ((tmp19 = (k)) === ~~tmp19)) {
        return Math.round(r);
      } else {
        return r;
      }
    })
  }))
});
negInt = function(x) {
  var tmp20;
  return ((tmp20 = (x)) === ~~tmp20) && x < 0;
};
smallFactorials = (function() {
  var i, x;
  return [x = 1].concat((function() {
    var _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 25; i = ++_i) {
      _results.push(x *= i);
    }
    return _results;
  })());
})();
_ref = (function() {
  var g, g_ln, p, p_ln;
  g = 7;
  p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
  g_ln = 607 / 128;
  p_ln = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];
  return {
    lnΓ: function(z) {
      var i, t, x, _i, _ref;
      if (z < 0) {
        return NaN;
      }
      x = p_ln[0];
      for (i = _i = _ref = p_ln.length - 1; _i > 0; i = _i += -1) {
        x += p_ln[i] / (z + i);
      }
      t = z + g_ln + .5;
      return .5 * Math.log(2 * Math.PI) + (z + .5) * Math.log(t) - t + Math.log(x) - Math.log(z);
    },
    Γ: function(z) {
      var i, t, x, _i, _ref;
      if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * Γ(1 - z));
      } else if (z > 100) {
        return Math.exp(lnΓ(z));
      } else {
        z--;
        x = p[0];
        for (i = _i = 1, _ref = g + 2; _i < _ref; i = _i += 1) {
          x += p[i] / (z + i);
        }
        t = z + g + .5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
      }
    }
  };
})(), Γ = _ref.Γ, lnΓ = _ref.lnΓ;

addVocabulary({
  '⍎': function(omega, alpha) {
    var s;
    if (alpha) {
      throw Error('Not implemented');
    } else {
      s = '';
      omega.each(function(c) {
        if (typeof c !== 'string') {
          throw DomainError();
        }
        return s += c;
      });
      return exec(s);
    }
  }
});

addVocabulary({
  '⍷': function(omega, alpha) {
    var a, d, data, findShape, i, indices, p, q, stride, _i, _ref1;
    if (alpha) {
      if (alpha.shape.length > omega.shape.length) {
        return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
      }
      if (alpha.shape.length < omega.shape.length) {
        alpha = new APLArray(alpha.data, repeat([1], omega.shape.length - alpha.shape.length).concat(alpha.shape), repeat([0], omega.shape.length - alpha.shape.length).concat(alpha.stride), alpha.offset);
      }
      if (prod(alpha.shape) === 0) {
        return new APLArray([1], omega.shape, repeat([0], omega.shape.length));
      }
      findShape = [];
      for (i = _i = 0, _ref1 = omega.shape.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        d = omega.shape[i] - alpha.shape[i] + 1;
        if (d <= 0) {
          return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
        }
        findShape.push(d);
      }
      stride = strideForShape(omega.shape);
      data = repeat([0], prod(omega.shape));
      p = omega.offset;
      q = 0;
      indices = repeat([0], findShape.length);
      while (true) {
        data[q] = +match(alpha, new APLArray(omega.data, alpha.shape, omega.stride, p));
        a = findShape.length - 1;
        while (a >= 0 && indices[a] + 1 === findShape[a]) {
          p -= indices[a] * omega.stride[a];
          q -= indices[a] * stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += omega.stride[a];
        q += stride[a];
        indices[a]++;
      }
      return new APLArray(data, omega.shape);
    } else {
      throw Error('Not implemented');
    }
  }
});

addVocabulary({
  '⌊': withIdentity(Infinity, pervasive({
    monad: Complex.floor,
    dyad: real(function(y, x) {
      return Math.min(y, x);
    })
  })),
  '⌈': withIdentity(-Infinity, pervasive({
    monad: Complex.ceil,
    dyad: real(function(y, x) {
      return Math.max(y, x);
    })
  }))
});

addVocabulary({
  _hook: function(g, f) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/forkhook.coffee:21");
    }
    if (!(typeof g === 'function')) {
      throw Error("\"assert typeof g is 'function'\" at src/vocabulary/forkhook.coffee:22");
    }
    return function(b, a) {
      return f(g(b), a != null ? a : b);
    };
  },
  _fork1: function(h, g) {
    if (!(typeof h === 'function')) {
      throw Error("\"assert typeof h is 'function'\" at src/vocabulary/forkhook.coffee:40");
    }
    if (!(typeof g === 'function')) {
      throw Error("\"assert typeof g is 'function'\" at src/vocabulary/forkhook.coffee:41");
    }
    return [h, g];
  },
  _fork2: function(_arg, f) {
    var g, h;
    h = _arg[0], g = _arg[1];
    if (!(typeof h === 'function')) {
      throw Error("\"assert typeof h is 'function'\" at src/vocabulary/forkhook.coffee:45");
    }
    return function(b, a) {
      return g(h(b, a), f(b, a));
    };
  }
});

addVocabulary({
  '⍕': function(omega, alpha) {
    var t;
    if (alpha) {
      throw Error('Not implemented');
    } else {
      t = format(omega);
      return new APLArray(t.join(''), [t.length, t[0].length]);
    }
  }
});
format = function(a) {
  var bottom, box, c, cols, d, grid, i, j, k, left, nCols, nRows, r, result, right, rows, sa, step, t, x, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
  if (typeof a === 'undefined') {
    return ['undefined'];
  } else if (a === null) {
    return ['null'];
  } else if (typeof a === 'string') {
    return [a];
  } else if (typeof a === 'number') {
    r = [('' + a).replace(/-|Infinity/g, '¯')];
    r.align = 'right';
    return r;
  } else if (typeof a === 'function') {
    return ['function'];
  } else if (!(a instanceof APLArray)) {
    return ['' + a];
  } else if (prod(a.shape) === 0) {
    return [''];
  } else {
    sa = a.shape;
    a = a.toArray();
    if (!sa.length) {
      return format(a[0]);
    }
    nRows = prod(sa.slice(0, sa.length - 1));
    nCols = sa[sa.length - 1];
    rows = (function() {
      var _i, _results;
      _results = [];
      for (_i = 0; 0 <= nRows ? _i < nRows : _i > nRows; 0 <= nRows ? _i++ : _i--) {
        _results.push({
          height: 0,
          bottomMargin: 0
        });
      }
      return _results;
    })();
    cols = (function() {
      var _i, _results;
      _results = [];
      for (_i = 0; 0 <= nCols ? _i < nCols : _i > nCols; 0 <= nCols ? _i++ : _i--) {
        _results.push({
          type: 0,
          width: 0,
          leftMargin: 0,
          rightMargin: 0
        });
      }
      return _results;
    })();
    grid = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = rows.length; _i < _len; i = ++_i) {
        r = rows[i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (j = _j = 0, _len1 = cols.length; _j < _len1; j = ++_j) {
            c = cols[j];
            x = a[nCols * i + j];
            box = format(x);
            r.height = Math.max(r.height, box.length);
            c.width = Math.max(c.width, box[0].length);
            c.type = Math.max(c.type, typeof x === 'string' && x.length === 1 ? 0 : !(x instanceof APLArray) ? 1 : 2);
            _results1.push(box);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    step = 1;
    for (d = _i = _ref1 = sa.length - 2; _i >= 1; d = _i += -1) {
      step *= sa[d];
      for (i = _j = _ref2 = step - 1, _ref3 = nRows - 1; step > 0 ? _j < _ref3 : _j > _ref3; i = _j += step) {
        rows[i].bottomMargin++;
      }
    }
    for (j = _k = 0, _len = cols.length; _k < _len; j = ++_k) {
      c = cols[j];
      if (j !== nCols - 1 && !((c.type === (_ref4 = cols[j + 1].type) && _ref4 === 0))) {
        c.rightMargin++;
      }
      if (c.type === 2) {
        c.leftMargin++;
        c.rightMargin++;
      }
    }
    result = [];
    for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {
      r = rows[i];
      for (j = _m = 0, _len2 = cols.length; _m < _len2; j = ++_m) {
        c = cols[j];
        t = grid[i][j];
        if (t.align === 'right') {
          left = repeat(' ', c.leftMargin + c.width - t[0].length);
          right = repeat(' ', c.rightMargin);
        } else {
          left = repeat(' ', c.leftMargin);
          right = repeat(' ', c.rightMargin + c.width - t[0].length);
        }
        for (k = _n = 0, _ref5 = t.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; k = 0 <= _ref5 ? ++_n : --_n) {
          t[k] = left + t[k] + right;
        }
        bottom = repeat(' ', t[0].length);
        for (_o = _ref6 = t.length, _ref7 = r.height + r.bottomMargin; _ref6 <= _ref7 ? _o < _ref7 : _o > _ref7; _ref6 <= _ref7 ? _o++ : _o--) {
          t.push(bottom);
        }
      }
      for (k = _p = 0, _ref8 = r.height + r.bottomMargin; 0 <= _ref8 ? _p < _ref8 : _p > _ref8; k = 0 <= _ref8 ? ++_p : --_p) {
        result.push(((function() {
          var _q, _results;
          _results = [];
          for (j = _q = 0; 0 <= nCols ? _q < nCols : _q > nCols; j = 0 <= nCols ? ++_q : --_q) {
            _results.push(grid[i][j][k]);
          }
          return _results;
        })()).join(''));
      }
    }
    return result;
  }
};

addVocabulary({
  '⍋': function(omega, alpha) {
    return grade(omega, alpha, 1);
  },
  '⍒': function(omega, alpha) {
    return grade(omega, alpha, -1);
  }
});
grade = function(omega, alpha, direction) {
  var h, _i, _ref1, _results;
  h = {};
  if (alpha) {
    if (!alpha.shape.length) {
      throw RankError();
    }
    h = {};
    alpha.each(function(x, indices) {
      if (typeof x !== 'string') {
        throw DomainError();
      }
      return h[x] = indices[indices.length - 1];
    });
  }
  if (!omega.shape.length) {
    throw RankError();
  }
  return new APLArray((function() {
    _results = [];
    for (var _i = 0, _ref1 = omega.shape[0]; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).sort(function(i, j) {
    var a, indices, p, tx, ty, x, y;
    p = omega.offset;
    indices = repeat([0], omega.shape.length);
    while (true) {
      x = omega.data[p + i * omega.stride[0]];
      y = omega.data[p + j * omega.stride[0]];
      tx = typeof x;
      ty = typeof y;
      if (tx < ty) {
        return -direction;
      }
      if (tx > ty) {
        return direction;
      }
      if (h[x] != null) {
        x = h[x];
      }
      if (h[y] != null) {
        y = h[y];
      }
      if (x < y) {
        return -direction;
      }
      if (x > y) {
        return direction;
      }
      a = indices.length - 1;
      while (a > 0 && indices[a] + 1 === omega.shape[a]) {
        p -= omega.stride[a] * indices[a];
        indices[a--] = 0;
      }
      if (a <= 0) {
        break;
      }
      p += omega.stride[a];
      indices[a]++;
    }
    return 0;
  }));
};

addVocabulary({
  '⍁': conjunction(function(f, x) {
    var _ref1;
    if (f instanceof APLArray) {
      _ref1 = [x, f], f = _ref1[0], x = _ref1[1];
    }
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/identity.coffee:13");
    }
    if (!(x instanceof APLArray)) {
      throw Error("\"assert x instanceof APLArray\" at src/vocabulary/identity.coffee:14");
    }
    if (!x.isSingleton()) {
      throw RankError();
    }
    if (x.shape.length) {
      x = APLArray.scalar(x.unwrap());
    }
    return withIdentity(x, function(omega, alpha, axis) {
      return f(omega, alpha, axis);
    });
  })
});

addVocabulary({
  '⍳': function(omega, alpha) {
    var a, axis, d, data, indices, tmp21, _i, _j, _len, _ref1, _results;
    if (alpha) {
      if (alpha.shape.length !== 1) {
        throw RankError();
      }
      return omega.map(function(x) {
        var e, r;
        try {
          r = alpha.shape;
          alpha.each(function(y, indices) {
            if (match(x, y)) {
              r = indices;
              throw 'break';
            }
          });
        } catch (_error) {
          e = _error;
          if (e !== 'break') {
            throw e;
          }
        }
        if (r.length === 1) {
          return r[0];
        } else {
          return new APLArray(r);
        }
      });
    } else {
      if (omega.shape.length > 1) {
        throw RankError();
      }
      a = omega.toArray();
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        d = a[_i];
        if (!((tmp21 = (d)) === ~~tmp21 && (0) <= tmp21)) {
          throw DomainError();
        }
      }
      data = [];
      if (prod(a)) {
        if (a.length === 1) {
          data = (function() {
            _results = [];
            for (var _j = 0, _ref1 = a[0]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--){ _results.push(_j); }
            return _results;
          }).apply(this);
        } else {
          indices = repeat([0], a.length);
          while (true) {
            data.push(new APLArray(indices.slice(0)));
            axis = a.length - 1;
            while (axis >= 0 && indices[axis] + 1 === a[axis]) {
              indices[axis--] = 0;
            }
            if (axis < 0) {
              break;
            }
            indices[axis]++;
          }
        }
      }
      return new APLArray(data, a);
    }
  }
});

addVocabulary({
  '~': function(omega, alpha) {
    var data;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      data = [];
      alpha.each(function(x) {
        var e;
        try {
          omega.each(function(y) {
            if (match(x, y)) {
              throw 'break';
            }
          });
          return data.push(x);
        } catch (_error) {
          e = _error;
          if (e !== 'break') {
            throw e;
          }
        }
      });
      return new APLArray(data);
    } else {
      return negate(omega);
    }
  },
  '∨': withIdentity(0, pervasive({
    dyad: function(y, x) {
      if (!(Complex.isint(x)) || !(Complex.isint(y))) {
        throw DomainError('∨ is implemented only for Gaussian integers');
      }
      return Complex.gcd(x, y);
    }
  })),
  '∧': aka('^', withIdentity(1, pervasive({
    dyad: function(y, x) {
      if (!(Complex.isint(x)) || !(Complex.isint(y))) {
        throw DomainError('∧ is implemented only for Gaussian integers');
      }
      return Complex.lcm(x, y);
    }
  }))),
  '⍱': pervasive({
    dyad: real(function(y, x) {
      return +(!(bool(x) | bool(y)));
    })
  }),
  '⍲': pervasive({
    dyad: real(function(y, x) {
      return +(!(bool(x) & bool(y)));
    })
  })
});
negate = pervasive({
  monad: function(x) {
    return +(!bool(x));
  }
});

addVocabulary({
  '⍣': conjunction(function(g, f) {
    var h, n;
    if (f instanceof APLArray && typeof g === 'function') {
      h = f;
      f = g;
      g = h;
    } else {
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/poweroperator.coffee:15");
      }
    }
    if (typeof g === 'function') {
      return function(omega, alpha) {
        var omega1;
        while (true) {
          omega1 = f(omega, alpha);
          if (g(omega, omega1).toBool()) {
            return omega;
          }
          omega = omega1;
        }
      };
    } else {
      n = g.toInt(0);
      return function(omega, alpha) {
        var _i;
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          omega = f(omega, alpha);
        }
        return omega;
      };
    }
  })
});

addVocabulary({
  'get_⎕': function() {
    if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
      return new APLArray(prompt('⎕:') || '');
    } else {
      throw Error('Reading from ⎕ is not implemented.');
    }
  },
  'set_⎕': function(x) {
    var s;
    s = format(x).join('\n') + '\n';
    if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
      window.alert(s);
    } else {
      process.stdout.write(s);
    }
    return x;
  },
  'get_⍞': function() {
    if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
      return prompt('') || '';
    } else {
      throw Error('Reading from ⍞ is not implemented.');
    }
  },
  'set_⍞': function(x) {
    var s;
    s = format(x).join('\n');
    if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
      window.alert(s);
    } else {
      process.stdout.write(s);
    }
    return x;
  }
});

addVocabulary({
  '?': function(omega, alpha) {
    if (alpha) {
      return deal(omega, alpha);
    } else {
      return roll(omega);
    }
  }
});
roll = pervasive({
  monad: real(function(x) {
    return Math.floor(Math.random() * x);
  })
});
deal = function(omega, alpha) {
  var available, x, y, _i, _results;
  y = omega.unwrap();
  x = alpha.unwrap();
  if (x > y) {
    throw DomainError();
  }
  available = (function() {
    _results = [];
    for (var _i = 0; 0 <= y ? _i < y : _i > y; 0 <= y ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
  return new APLArray((function() {
    var _j, _results1;
    _results1 = [];
    for (_j = 0; 0 <= x ? _j < x : _j > x; 0 <= x ? _j++ : _j--) {
      _results1.push(available.splice(Math.floor(available.length * Math.random()), 1)[0]);
    }
    return _results1;
  })());
};

addVocabulary({
  '↗': function(omega) {
    throw APLError(omega.toString());
  }
});

addVocabulary({
  '⍴': function(omega, alpha) {
    var a, d, n, shape, tmp22, _i, _len;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      shape = alpha.toArray();
      for (_i = 0, _len = shape.length; _i < _len; _i++) {
        d = shape[_i];
        if (!((tmp22 = (d)) === ~~tmp22 && (0) <= tmp22)) {
          throw DomainError();
        }
      }
      n = prod(shape);
      a = omega.toArray(n);
      if (!(a.length <= n)) {
        throw Error("\"assert a.length <= n\" at src/vocabulary/rho.coffee:20");
      }
      if (a.length) {
        while (2 * a.length < n) {
          a = a.concat(a);
        }
        if (a.length !== n) {
          a = a.concat(a.slice(0, n - a.length));
        }
      } else {
        a = repeat([omega.getPrototype()], n);
      }
      return new APLArray(a, shape);
    } else {
      return new APLArray(omega.shape);
    }
  }
});

addVocabulary({
  '⌽': rotate = function(omega, alpha, axis) {
    var a, data, indices, n, offset, p, shape, step, stride, tmp23, tmp24, tmp25;
    if (!(typeof axis === 'undefined' || axis instanceof APLArray)) {
      throw Error("\"assert typeof axis is 'undefined' or axis instanceof APLArray\" at src/vocabulary/rotate.coffee:4");
    }
    if (alpha) {
      axis = !axis ? omega.shape.length - 1 : axis.unwrap();
      if (!((tmp23 = (axis)) === ~~tmp23)) {
        throw DomainError();
      }
      if (omega.shape.length && !((0 <= axis && axis < omega.shape.length))) {
        throw IndexError();
      }
      step = alpha.unwrap();
      if (!((tmp24 = (step)) === ~~tmp24)) {
        throw DomainError();
      }
      if (!step) {
        return omega;
      }
      n = omega.shape[axis];
      step = (n + (step % n)) % n;
      if (omega.empty() || step === 0) {
        return omega;
      }
      data = [];
      shape = omega.shape, stride = omega.stride;
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        data.push(omega.data[p + ((indices[axis] + step) % shape[axis] - indices[axis]) * stride[axis]]);
        a = shape.length - 1;
        while (a >= 0 && indices[a] + 1 === shape[a]) {
          p -= indices[a] * stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        indices[a]++;
        p += stride[a];
      }
      return new APLArray(data, shape);
    } else {
      if (axis) {
        if (!axis.isSingleton()) {
          throw LengthError();
        }
        axis = axis.unwrap();
        if (!((tmp25 = (axis)) === ~~tmp25)) {
          throw DomainError();
        }
        if (!((0 <= axis && axis < omega.shape.length))) {
          throw IndexError();
        }
      } else {
        axis = [omega.shape.length - 1];
      }
      if (omega.shape.length === 0) {
        return omega;
      }
      stride = omega.stride.slice(0);
      stride[axis] = -stride[axis];
      offset = omega.offset + (omega.shape[axis] - 1) * omega.stride[axis];
      return new APLArray(omega.data, omega.shape, stride, offset);
    }
  },
  '⊖': function(omega, alpha, axis) {
    if (axis == null) {
      axis = APLArray.zero;
    }
    return rotate(omega, alpha, axis);
  }
});

addVocabulary({
  '/': adverb(function(omega, alpha, axis) {
    if (typeof omega === 'function') {
      return reduce(omega, alpha, axis);
    } else {
      return compressOrReplicate(omega, alpha, axis);
    }
  }),
  '⌿': adverb(function(omega, alpha, axis) {
    if (axis == null) {
      axis = APLArray.zero;
    }
    if (typeof omega === 'function') {
      return reduce(omega, alpha, axis);
    } else {
      return compressOrReplicate(omega, alpha, axis);
    }
  })
});
reduce = this.reduce = function(f, g, axis0) {
  if (!(typeof f === 'function')) {
    throw Error("\"assert typeof f is 'function'\" at src/vocabulary/slash.coffee:36");
  }
  if (!(typeof g === 'undefined')) {
    throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/slash.coffee:37");
  }
  if (!((typeof axis0 === 'undefined') || (axis0 instanceof APLArray))) {
    throw Error("\"assert((typeof axis0 is 'undefined') or (axis0 instanceof APLArray))\" at src/vocabulary/slash.coffee:38");
  }
  return function(omega, alpha) {
    var a, axis, data, i, indices, isBackwards, isMonadic, isNWise, n, p, rShape, shape, x, y, z, _i, _j, _ref1, _ref2;
    if (omega.shape.length === 0) {
      omega = new APLArray([omega.unwrap()]);
    }
    axis = axis0 != null ? axis0.toInt() : omega.shape.length - 1;
    if (!((0 <= axis && axis < omega.shape.length))) {
      throw RankError();
    }
    if (alpha) {
      isNWise = true;
      n = alpha.toInt();
      if (n < 0) {
        isBackwards = true;
        n = -n;
      }
    } else {
      n = omega.shape[axis];
      isMonadic = true;
    }
    shape = omega.shape.slice(0);
    shape[axis] = omega.shape[axis] - n + 1;
    rShape = shape;
    if (isNWise) {
      if (shape[axis] === 0) {
        return new APLArray([], rShape);
      }
      if (shape[axis] < 0) {
        throw LengthError();
      }
    } else {
      rShape = rShape.slice(0);
      rShape.splice(axis, 1);
    }
    if (omega.empty()) {
      if ((z = (_ref1 = f.aplMetaInfo) != null ? _ref1.identity : void 0) != null) {
        if (!(z.shape.length === 0)) {
          throw Error("\"assert z.shape.length is 0\" at src/vocabulary/slash.coffee:66");
        }
        return new APLArray(z.data, rShape, repeat([0], rShape.length), z.offset);
      } else {
        throw DomainError();
      }
    }
    data = [];
    indices = repeat([0], shape.length);
    p = omega.offset;
    while (true) {
      if (isBackwards) {
        x = omega.data[p];
        x = x instanceof APLArray ? x : APLArray.scalar(x);
        for (i = _i = 1; _i < n; i = _i += 1) {
          y = omega.data[p + i * omega.stride[axis]];
          y = y instanceof APLArray ? y : APLArray.scalar(y);
          x = f(x, y);
        }
      } else {
        x = omega.data[p + (n - 1) * omega.stride[axis]];
        x = x instanceof APLArray ? x : APLArray.scalar(x);
        for (i = _j = _ref2 = n - 2; _j >= 0; i = _j += -1) {
          y = omega.data[p + i * omega.stride[axis]];
          y = y instanceof APLArray ? y : APLArray.scalar(y);
          x = f(x, y);
        }
      }
      if (x.shape.length === 0) {
        x = x.unwrap();
      }
      data.push(x);
      a = indices.length - 1;
      while (a >= 0 && indices[a] + 1 === shape[a]) {
        p -= indices[a] * omega.stride[a];
        indices[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += omega.stride[a];
      indices[a]++;
    }
    return new APLArray(data, rShape);
  };
};
compressOrReplicate = function(omega, alpha, axis) {
  var a, b, data, filler, i, indices, n, p, shape, tmp26, x, _i, _j, _len, _ref1;
  if (omega.shape.length === 0) {
    omega = new APLArray([omega.unwrap()]);
  }
  axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  a = alpha.toArray();
  n = omega.shape[axis];
  if (a.length === 1) {
    a = repeat(a, n);
  }
  if (n !== 1 && n !== a.length) {
    throw LengthError();
  }
  shape = omega.shape.slice(0);
  shape[axis] = 0;
  b = [];
  for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
    x = a[i];
    if (!((tmp26 = (x)) === ~~tmp26)) {
      throw DomainError();
    }
    shape[axis] += Math.abs(x);
    for (_j = 0, _ref1 = Math.abs(x); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--) {
      b.push(x > 0 ? i : null);
    }
  }
  if (n === 1) {
    b = (function() {
      var _k, _len1, _results;
      _results = [];
      for (_k = 0, _len1 = b.length; _k < _len1; _k++) {
        x = b[_k];
        _results.push(x != null ? 0 : x);
      }
      return _results;
    })();
  }
  data = [];
  if (shape[axis] !== 0 && !omega.empty()) {
    filler = omega.getPrototype();
    p = omega.offset;
    indices = repeat([0], shape.length);
    while (true) {
      x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
      data.push(x);
      i = shape.length - 1;
      while (i >= 0 && indices[i] + 1 === shape[i]) {
        if (i !== axis) {
          p -= omega.stride[i] * indices[i];
        }
        indices[i--] = 0;
      }
      if (i < 0) {
        break;
      }
      if (i !== axis) {
        p += omega.stride[i];
      }
      indices[i]++;
    }
  }
  return new APLArray(data, shape);
};

addVocabulary({
  'get_⎕IO': function() {
    return APLArray.zero;
  },
  'set_⎕IO': function(x) {
    if (match(x, APLArray.zero)) {
      return x;
    } else {
      throw Error('The index origin (⎕IO) is fixed at 0');
    }
  }
});

addVocabulary({
  '⌷': squish = function(omega, alpha, axes) {
    var a, data, p, subscriptShapes, subscripts, u, x, _i, _ref1, _ref2, _ref3;
    if (typeof omega === 'function') {
      return function(x, y) {
        return omega(x, y, alpha);
      };
    }
    if (!alpha) {
      throw Error('Not implemented');
    }
    _ref1 = prepareForIndexing(omega, alpha, axes), subscripts = _ref1[0], subscriptShapes = _ref1[1];
    data = [];
    if (all((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = subscripts.length; _i < _len; _i++) {
        x = subscripts[_i];
        _results.push(x.length);
      }
      return _results;
    })())) {
      u = repeat([0], subscripts.length);
      p = omega.offset;
      for (a = _i = 0, _ref2 = subscripts.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; a = 0 <= _ref2 ? ++_i : --_i) {
        p += subscripts[a][0] * omega.stride[a];
      }
      while (true) {
        data.push(omega.data[p]);
        a = subscripts.length - 1;
        while (a >= 0 && u[a] + 1 === subscripts[a].length) {
          p += (subscripts[a][0] - subscripts[a][u[a]]) * omega.stride[a];
          u[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += (subscripts[a][u[a] + 1] - subscripts[a][u[a]]) * omega.stride[a];
        u[a]++;
      }
    }
    return new APLArray(data, (_ref3 = []).concat.apply(_ref3, subscriptShapes));
  },
  _index: function(alphaAndAxes, omega) {
    var alpha, axes, _ref1;
    _ref1 = alphaAndAxes.toArray(), alpha = _ref1[0], axes = _ref1[1];
    return squish(omega, alpha, axes);
  },
  _substitute: function(args) {
    var a, alpha, axes, i, indexShape, n, omega, p, q, r, subscriptShapes, subscripts, u, value, x, _i, _j, _len, _ref1, _ref2, _ref3, _ref4;
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = args.toArray();
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        if (x instanceof APLArray) {
          _results.push(x);
        } else {
          _results.push(new APLArray([x], []));
        }
      }
      return _results;
    })(), value = _ref1[0], alpha = _ref1[1], omega = _ref1[2], axes = _ref1[3];
    _ref2 = prepareForIndexing(omega, alpha, axes), subscripts = _ref2[0], subscriptShapes = _ref2[1];
    indexShape = (_ref3 = []).concat.apply(_ref3, subscriptShapes);
    if (value.isSingleton()) {
      value = new APLArray([value.unwrap()], indexShape, repeat([0], indexShape.length));
    } else {
      if (value.shape.length !== indexShape.length) {
        throw RankError();
      } else {
        for (i = _i = 0, _len = indexShape.length; _i < _len; i = ++_i) {
          n = indexShape[i];
          if (value.shape[i] !== n) {
            throw LengthError();
          }
        }
      }
    }
    r = new APLArray(omega.toArray(), omega.shape);
    p = 0;
    for (a = _j = 0, _ref4 = subscripts.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; a = 0 <= _ref4 ? ++_j : --_j) {
      p += subscripts[a][0] * r.stride[a];
    }
    q = value.offset;
    u = repeat([0], subscripts.length);
    while (true) {
      r.data[p] = value.data[q];
      a = subscripts.length - 1;
      while (a >= 0 && u[a] + 1 === subscripts[a].length) {
        p += (subscripts[a][0] - subscripts[a][u[a]]) * r.stride[a];
        q -= u[a] * value.stride[a];
        u[a--] = 0;
      }
      if (a < 0) {
        break;
      }
      p += (subscripts[a][u[a] + 1] - subscripts[a][u[a]]) * r.stride[a];
      q += value.stride[a];
      u[a]++;
    }
    return r;
  }
});
prepareForIndexing = function(omega, alpha, axes) {
  var alphaItems, axis, d, i, subscriptShapes, subscripts, tmp27, tmp28, x, _i, _j, _k, _l, _len, _len1, _m, _ref1, _ref2, _ref3, _ref4, _results, _results1;
  if (!(alpha instanceof APLArray)) {
    throw Error("\"assert alpha instanceof APLArray\" at src/vocabulary/squish.coffee:115");
  }
  if (!(omega instanceof APLArray)) {
    throw Error("\"assert omega instanceof APLArray\" at src/vocabulary/squish.coffee:116");
  }
  if (!((axes == null) || axes instanceof APLArray)) {
    throw Error("\"assert (not axes?) or axes instanceof APLArray\" at src/vocabulary/squish.coffee:117");
  }
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  alphaItems = alpha.toArray();
  if (alphaItems.length > omega.shape.length) {
    throw LengthError();
  }
  axes = axes ? axes.toArray() : (function() {
    _results = [];
    for (var _i = 0, _ref1 = alphaItems.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
  if (alphaItems.length !== axes.length) {
    throw LengthError();
  }
  subscripts = Array(omega.shape.length);
  subscriptShapes = Array(omega.shape.length);
  for (i = _j = 0, _len = axes.length; _j < _len; i = ++_j) {
    axis = axes[i];
    if (!((tmp27 = (axis)) === ~~tmp27)) {
      throw DomainError();
    }
    if (!((0 <= axis && axis < omega.shape.length))) {
      throw RankError();
    }
    if (typeof subscripts[axis] !== 'undefined') {
      throw RankError('Duplicate axis');
    }
    d = alphaItems[i];
    subscripts[axis] = d instanceof APLArray ? d.toArray() : [d];
    subscriptShapes[axis] = d instanceof APLArray ? d.shape : [];
    _ref2 = subscripts[axis];
    for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
      x = _ref2[_k];
      if (!((tmp28 = (x)) === ~~tmp28)) {
        throw DomainError();
      }
      if (!((0 <= x && x < omega.shape[axis]))) {
        throw IndexError();
      }
    }
  }
  for (i = _l = 0, _ref3 = subscripts.length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
    if (!(typeof subscripts[i] === 'undefined')) {
      continue;
    }
    subscripts[i] = (function() {
      _results1 = [];
      for (var _m = 0, _ref4 = omega.shape[i]; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; 0 <= _ref4 ? _m++ : _m--){ _results1.push(_m); }
      return _results1;
    }).apply(this);
    subscriptShapes[i] = [omega.shape[i]];
  }
  return [subscripts, subscriptShapes];
};

addVocabulary({
  '↑': function(omega, alpha) {
    if (alpha) {
      return take(omega, alpha);
    } else {
      return mix(omega);
    }
  }
});
take = function(omega, alpha) {
  var a, axis, copyIndices, copyShape, data, i, mustCopy, offset, p, q, shape, stride, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref1;
  if (alpha.shape.length > 1) {
    throw RankError();
  }
  if (omega.shape.length === 0) {
    omega = new APLArray([omega.unwrap()], (alpha.shape.length === 0 ? [1] : repeat([1], alpha.shape[0])));
  }
  a = alpha.toArray();
  if (a.length > omega.shape.length) {
    throw RankError();
  }
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    x = a[_i];
    if (typeof x !== 'number' || x !== Math.floor(x)) {
      throw DomainError();
    }
  }
  mustCopy = false;
  shape = omega.shape.slice(0);
  for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
    x = a[i];
    shape[i] = Math.abs(x);
    if (shape[i] > omega.shape[i]) {
      mustCopy = true;
    }
  }
  if (mustCopy) {
    stride = Array(shape.length);
    stride[stride.length - 1] = 1;
    for (i = _k = _ref1 = stride.length - 2; _k >= 0; i = _k += -1) {
      stride[i] = stride[i + 1] * shape[i + 1];
    }
    data = repeat([omega.getPrototype()], prod(shape));
    copyShape = shape.slice(0);
    p = omega.offset;
    q = 0;
    for (i = _l = 0, _len2 = a.length; _l < _len2; i = ++_l) {
      x = a[i];
      copyShape[i] = Math.min(omega.shape[i], Math.abs(x));
      if (x < 0) {
        if (x < -omega.shape[i]) {
          q -= (x + omega.shape[i]) * stride[i];
        } else {
          p += (x + omega.shape[i]) * omega.stride[i];
        }
      }
    }
    if (prod(copyShape)) {
      copyIndices = repeat([0], copyShape.length);
      while (true) {
        data[q] = omega.data[p];
        axis = copyShape.length - 1;
        while (axis >= 0 && copyIndices[axis] + 1 === copyShape[axis]) {
          p -= copyIndices[axis] * omega.stride[axis];
          q -= copyIndices[axis] * stride[axis];
          copyIndices[axis--] = 0;
        }
        if (axis < 0) {
          break;
        }
        p += omega.stride[axis];
        q += stride[axis];
        copyIndices[axis]++;
      }
    }
    return new APLArray(data, shape, stride);
  } else {
    offset = omega.offset;
    for (i = _m = 0, _len3 = a.length; _m < _len3; i = ++_m) {
      x = a[i];
      if (x < 0) {
        offset += (omega.shape[i] + x) * omega.stride[i];
      }
    }
    return new APLArray(omega.data, shape, omega.stride, offset);
  }
};
mix = function(omega) {
  var data, s, shape, shapes, x;
  if (omega.shape.length === 0) {
    x = omega.data[omega.offset];
    if (x instanceof APLArray) {
      return x;
    } else {
      return APLArray.scalar(x);
    }
  } else {
    shapes = [];
    omega.each(function(x) {
      return shapes.push(x.shape);
    });
    if (shapes.length === 0) {
      throw NonceError('Mix of empty array not implemented');
    }
    shape = shapes.reduce(function(a, b) {
      var i, _i, _ref1, _results;
      if (a.length !== b.length) {
        throw NonceError('Mix of different ranks not implemented');
      }
      _results = [];
      for (i = _i = 0, _ref1 = a.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push(Math.max(a[i], b[i]));
      }
      return _results;
    });
    s = new APLArray(shape);
    data = [];
    omega.each(function(x) {
      return data = data.concat((take(x, s)).toArray());
    });
    return new APLArray(data, omega.shape.concat(shape));
  }
};

addVocabulary({
  '⍉': function(omega, alpha) {
    var i, n, shape, stride, tmp29, u, x, _i, _j, _len, _len1, _ref1;
    if (alpha) {
      if (alpha.shape.length > 1) {
        throw RankError();
      }
      if (alpha.shape.length === 0) {
        alpha = new APLArray([alpha.unwrap()]);
      }
      n = omega.shape.length;
      if (alpha.shape[0] !== n) {
        throw LengthError();
      }
      shape = [];
      stride = [];
      _ref1 = alpha.toArray();
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        x = _ref1[i];
        if (!((tmp29 = (x)) === ~~tmp29 && (0) <= tmp29)) {
          throw DomainError();
        }
        if (x >= n) {
          throw RankError();
        }
        if (shape[x] != null) {
          shape[x] = Math.min(shape[x], omega.shape[i]);
          stride[x] += omega.stride[i];
        } else {
          shape[x] = omega.shape[i];
          stride[x] = omega.stride[i];
        }
      }
      for (_j = 0, _len1 = shape.length; _j < _len1; _j++) {
        u = shape[_j];
        if (u == null) {
          throw RankError();
        }
      }
      return new APLArray(omega.data, shape, stride, omega.offset);
    } else {
      return new APLArray(omega.data, omega.shape.slice(0).reverse(), omega.stride.slice(0).reverse(), omega.offset);
    }
  }
});

addVocabulary({
  '⍠': conjunction(function(f, g) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/variant.coffee:8");
    }
    if (!(typeof g === 'function')) {
      throw Error("\"assert typeof g is 'function'\" at src/vocabulary/variant.coffee:9");
    }
    return function(omega, alpha, axis) {
      return (alpha != null ? f : g)(omega, alpha, axis);
    };
  })
});

exec = function(aplCode, opts) {
  if (opts == null) {
    opts = {};
  }
  return execInternal(aplCode, opts).result;
};
execInternal = function(aplCode, opts) {
  var ast, code, env, frame, k, result, v, _ref1, _ref2;
  if (opts == null) {
    opts = {};
  }
  ast = parse(aplCode, opts);
  code = compileAST(ast, opts);
  env = prelude ? (function() {
    var _i, _len, _ref1, _results;
    _ref1 = prelude.env;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      frame = _ref1[_i];
      _results.push(frame.slice(0));
    }
    return _results;
  })() : [[]];
  _ref1 = ast.vars;
  for (k in _ref1) {
    v = _ref1[k];
    env[0][v.slot] = opts.ctx[k];
  }
  result = vm({
    code: code,
    env: env
  });
  _ref2 = ast.vars;
  for (k in _ref2) {
    v = _ref2[k];
    opts.ctx[k] = env[0][v.slot];
  }
  return {
    ast: ast,
    code: code,
    env: env,
    result: result
  };
};
compile = function(aplCode, opts) {
  if (opts == null) {
    opts = {};
  }
  opts.aplCode = aplCode;
  return compileAST(parse(aplCode, opts), opts);
};
compileAST = function(ast, opts) {
  var err, markOperators, node, queue, render, renderLHS, scopeNode, vars, visit, visitLHS, _i, _len, _ref1;
  if (opts == null) {
    opts = {};
  }
  ast.scopeDepth = 0;
  ast.nSlots = prelude ? prelude.ast.nSlots : 0;
  ast.vars = prelude ? ast.vars = Object.create(prelude.ast.vars) : {};
  (function() {
    var k, v, varInfo, _ref1, _ref2, _ref3, _results;
    if (opts.ctx == null) {
      opts.ctx = Object.create(vocabulary);
    }
    _ref1 = opts.ctx;
    _results = [];
    for (k in _ref1) {
      v = _ref1[k];
      if (!(!ast.vars[k])) {
        continue;
      }
      ast.vars[k] = varInfo = {
        type: 'X',
        slot: ast.nSlots++,
        scopeDepth: ast.scopeDepth
      };
      if (typeof v === 'function' || v instanceof λ) {
        varInfo.type = 'F';
        if ((_ref2 = v.aplMetaInfo) != null ? _ref2.isAdverb : void 0) {
          varInfo.isAdverb = true;
        }
        if ((_ref3 = v.aplMetaInfo) != null ? _ref3.isConjunction : void 0) {
          varInfo.isConjunction = true;
        }
        if (/^[gs]et_.*/.test(k)) {
          _results.push(ast.vars[k.slice(4)] = {
            type: 'X'
          });
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  })();
  err = function(node, message) {
    throw SyntaxError(message, {
      file: opts.file,
      line: node.startLine,
      col: node.startCol,
      aplCode: opts.aplCode
    });
  };
  (markOperators = function(node) {
    var i, r, _i, _ref1;
    switch (node[0]) {
      case 'body':
      case 'guard':
      case 'assign':
      case 'index':
      case 'lambda':
      case 'expr':
        r = 0;
        for (i = _i = 1, _ref1 = node.length; _i < _ref1; i = _i += 1) {
          if (node[i]) {
            r |= markOperators(node[i]);
          }
        }
        if (r && node[0] === 'lambda') {
          if (r & 1) {
            node.isAdverb = true;
          }
          if (r & 2) {
            node.isConjunction = true;
          }
          return 0;
        } else {
          return r;
        }
        break;
      case 'string':
      case 'number':
      case 'embedded':
        return 0;
      case 'symbol':
        switch (node[1]) {
          case '⍺⍺':
          case '⍶':
          case '∇∇':
            return 1;
          case '⍵⍵':
          case '⍹':
            return 3;
          default:
            return 0;
        }
        break;
      default:
        throw Error("Unrecognized node type, '" + node[0] + "'");
    }
  })(ast);
  queue = [ast];
  while (queue.length) {
    vars = (scopeNode = queue.shift()).vars;
    visit = function(node) {
      var a, body, c, d, h, i, j, name, r, v, x, _i, _j, _len, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      node.scopeNode = scopeNode;
      switch (node[0]) {
        case 'guard':
          r = visit(node[1]);
          visit(node[2]);
          return r;
        case 'assign':
          return visitLHS(node[1], visit(node[2]));
        case 'symbol':
          name = node[1];
          if (((_ref1 = (v = vars["get_" + name])) != null ? _ref1.type : void 0) === 'F') {
            return {
              type: 'X'
            };
          } else {
            return vars[name] || err(node, "Symbol '" + name + "' is referenced before assignment.");
          }
          break;
        case 'lambda':
          queue.push(extend((body = node[1]), {
            scopeNode: scopeNode,
            scopeDepth: (d = scopeNode.scopeDepth + 1 + !!(node.isAdverb || node.isConjunction)),
            nSlots: 3,
            vars: extend(Object.create(vars), {
              '⍵': {
                type: 'X',
                slot: 0,
                scopeDepth: d
              },
              '∇': {
                type: 'F',
                slot: 1,
                scopeDepth: d
              },
              '⍺': {
                type: 'X',
                slot: 2,
                scopeDepth: d
              }
            })
          }));
          if (node.isConjunction) {
            extend(body.vars, {
              '⍵⍵': {
                type: 'F',
                slot: 0,
                scopeDepth: d - 1
              },
              '⍹': {
                type: 'F',
                slot: 0,
                scopeDepth: d - 1
              },
              '∇∇': {
                type: 'F',
                slot: 1,
                scopeDepth: d - 1,
                isConjunction: true
              },
              '⍺⍺': {
                type: 'F',
                slot: 2,
                scopeDepth: d - 1
              },
              '⍶': {
                type: 'F',
                slot: 2,
                scopeDepth: d - 1
              }
            });
          } else if (node.isAdverb) {
            extend(body.vars, {
              '⍺⍺': {
                type: 'F',
                slot: 0,
                scopeDepth: d - 1
              },
              '⍶': {
                type: 'F',
                slot: 0,
                scopeDepth: d - 1
              },
              '∇∇': {
                type: 'F',
                slot: 1,
                scopeDepth: d - 1,
                isAdverb: true
              }
            });
          }
          return {
            type: 'F',
            isAdverb: node.isAdverb,
            isConjunction: node.isConjunction
          };
        case 'string':
        case 'number':
        case 'embedded':
          return {
            type: 'X'
          };
        case 'index':
          _ref2 = node.slice(2);
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            c = _ref2[_i];
            if (c) {
              visit(c).type === 'X' || err(node, 'Only expressions of type data can be used as an index.');
            }
          }
          return visit(node[1]);
        case 'expr':
          a = node.slice(1);
          h = Array(a.length);
          for (i = _j = _ref3 = a.length - 1; _ref3 <= 0 ? _j <= 0 : _j >= 0; i = _ref3 <= 0 ? ++_j : --_j) {
            h[i] = visit(a[i]);
          }
          i = 0;
          while (i < a.length - 1) {
            if ((h[i].type === (_ref4 = h[i + 1].type) && _ref4 === 'X')) {
              j = i + 2;
              while (j < a.length && h[j].type === 'X') {
                j++;
              }
              [].splice.apply(a, [i, j - i].concat(_ref5 = [['vector'].concat(a.slice(i, j))])), _ref5;
              [].splice.apply(h, [i, j - i].concat(_ref6 = [
                {
                  type: 'X'
                }
              ])), _ref6;
            } else {
              i++;
            }
          }
          i = a.length - 2;
          while (--i >= 0) {
            if (h[i + 1].isConjunction && (h[i].type === 'F' || h[i + 2].type === 'F')) {
              [].splice.apply(a, [i, (i + 3) - i].concat(_ref7 = [['conjunction'].concat(a.slice(i, i + 3))])), _ref7;
              [].splice.apply(h, [i, (i + 3) - i].concat(_ref8 = [
                {
                  type: 'F'
                }
              ])), _ref8;
              i--;
            }
          }
          i = 0;
          while (i < a.length - 1) {
            if (h[i].type === 'F' && h[i + 1].isAdverb) {
              [].splice.apply(a, [i, (i + 2) - i].concat(_ref9 = [['adverb'].concat(a.slice(i, i + 2))])), _ref9;
              [].splice.apply(h, [i, (i + 2) - i].concat(_ref10 = [
                {
                  type: 'F'
                }
              ])), _ref10;
            } else {
              i++;
            }
          }
          if (h.length === 2 && (h[0].type === (_ref11 = h[1].type) && _ref11 === 'F')) {
            a = [['hook'].concat(a)];
            h = [
              {
                type: 'F'
              }
            ];
          }
          if (h.length >= 3 && h.length % 2 === 1 && all((function() {
            var _k, _len1, _results;
            _results = [];
            for (_k = 0, _len1 = h.length; _k < _len1; _k++) {
              x = h[_k];
              _results.push(x.type === 'F');
            }
            return _results;
          })())) {
            a = [['fork'].concat(a)];
            h = [
              {
                type: 'F'
              }
            ];
          }
          if (h[h.length - 1].type === 'F') {
            if (h.length > 1) {
              err(a[h.length - 1], 'Trailing function in expression');
            }
          } else {
            while (h.length > 1) {
              if (h.length === 2 || h[h.length - 3].type === 'F') {
                [].splice.apply(a, [(_ref12 = h.length - 2), 9e9].concat(_ref13 = [['monadic'].concat(a.slice(h.length - 2))])), _ref13;
                [].splice.apply(h, [(_ref14 = h.length - 2), 9e9].concat(_ref15 = [
                  {
                    type: 'X'
                  }
                ])), _ref15;
              } else {
                [].splice.apply(a, [(_ref16 = h.length - 3), 9e9].concat(_ref17 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref17;
                [].splice.apply(h, [(_ref18 = h.length - 3), 9e9].concat(_ref19 = [
                  {
                    type: 'X'
                  }
                ])), _ref19;
              }
            }
          }
          [].splice.apply(node, [0, 9e9].concat(_ref20 = a[0])), _ref20;
          extend(node, a[0]);
          return h[0];
        default:
          throw Error("Unrecognized node type, '" + node[0] + "'");
      }
    };
    visitLHS = function(node, rhsInfo) {
      var c, child, name, _i, _j, _len, _len1, _ref1, _ref2;
      node.scopeNode = scopeNode;
      switch (node[0]) {
        case 'symbol':
          name = node[1];
          if (name === '∇') {
            err(node, 'Assignment to ∇ is not allowed.');
          }
          if (vars[name]) {
            if (vars[name].type !== rhsInfo.type) {
              err(node, "Inconsistent usage of symbol '" + name + "', it is assigned both nouns and verbs.");
            }
          } else {
            vars[name] = extend({
              scopeDepth: scopeNode.scopeDepth,
              slot: scopeNode.nSlots++
            }, rhsInfo);
          }
          break;
        case 'expr':
          rhsInfo.type === 'X' || err(node, 'Strand assignment can be used only for nouns.');
          _ref1 = node.slice(1);
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            child = _ref1[_i];
            visitLHS(child, rhsInfo);
          }
          break;
        case 'index':
          rhsInfo.type === 'X' || err(node, 'Index assignment can be used only for nouns.');
          visitLHS(node[1], rhsInfo);
          _ref2 = node.slice(2);
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            c = _ref2[_j];
            if (c) {
              visit(c);
            }
          }
          break;
        default:
          err(node, "Invalid LHS node type: " + (JSON.stringify(node[0])));
      }
      return rhsInfo;
    };
    _ref1 = scopeNode.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      visit(node);
    }
  }
  render = function(node) {
    var a, axes, c, child, code, d, f, fragments, i, name, r, s, u, v, w, x, y, _ref2, _ref3, _ref4, _ref5;
    switch (node[0]) {
      case 'body':
        if (node.length === 1) {
          return [LDC, APLArray.zilde, RET];
        } else {
          a = (function() {
            var _j, _len1, _ref2, _results;
            _ref2 = node.slice(1);
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              child = _ref2[_j];
              _results.push([POP].concat(render(child)));
            }
            return _results;
          })();
          return (_ref2 = []).concat.apply(_ref2, a).slice(1).concat(RET);
        }
        break;
      case 'guard':
        x = render(node[1]);
        y = render(node[2]);
        return x.concat(JEQ, y.length + 2, POP, y, RET);
      case 'assign':
        return render(node[2]).concat(renderLHS(node[1]));
      case 'symbol':
        name = node[1];
        vars = node.scopeNode.vars;
        if (((_ref3 = (v = vars["get_" + name])) != null ? _ref3.type : void 0) === 'F') {
          return [LDC, APLArray.zero, GET, v.scopeDepth, v.slot, MON];
        } else {
          v = vars[name];
          return [GET, v.scopeDepth, v.slot];
        }
        break;
      case 'lambda':
        code = render(node[1]);
        if (node.isAdverb || node.isConjunction) {
          return [LAM, code.length + 3, LAM, code.length].concat(code, RET);
        } else {
          return [LAM, code.length].concat(code);
        }
        break;
      case 'string':
        d = node[1][0];
        s = eval(d + node[1].slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d);
        v = s.length === 1 ? new APLArray(s, []) : new APLArray(s);
        return [LDC, v];
      case 'number':
        a = (function() {
          var _j, _len1, _ref4, _results;
          _ref4 = node[1].replace(/¯/g, '-').split(/j/i);
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            x = _ref4[_j];
            if (x === '-') {
              _results.push(Infinity);
            } else if (x === '--') {
              _results.push(-Infinity);
            } else if (x.match(/^-?0x/i)) {
              _results.push(parseInt(x, 16));
            } else {
              _results.push(parseFloat(x));
            }
          }
          return _results;
        })();
        v = a[1] ? new Complex(a[0], a[1]) : a[0];
        return [LDC, new APLArray([v], [])];
      case 'embedded':
        f = eval("(function (_w, _a) {return (" + (node[1].replace(/^«|»$/g, '')) + ");})");
        return [
          EMB, function(_w, _a) {
            return aplify(f(_w, _a));
          }
        ];
      case 'index':
        v = node.scopeNode.vars._index;
        axes = (function() {
          var _j, _len1, _ref4, _results;
          _ref4 = node.slice(2);
          _results = [];
          for (i = _j = 0, _len1 = _ref4.length; _j < _len1; i = ++_j) {
            c = _ref4[i];
            if (c) {
              _results.push(i);
            }
          }
          return _results;
        })();
        return (_ref4 = []).concat.apply(_ref4, __slice.call((function() {
          var _j, _len1, _ref4, _results;
          _ref4 = node.slice(2);
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            c = _ref4[_j];
            if (c) {
              _results.push(render(c));
            }
          }
          return _results;
        })()).concat([VEC], [axes.length], [LDC], [new APLArray(axes)], [VEC], [2], [GET], [v.scopeDepth], [v.slot], [render(node[1])], [DYA]));
      case 'vector':
        fragments = (function() {
          var _j, _len1, _ref5, _results;
          _ref5 = node.slice(1);
          _results = [];
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            child = _ref5[_j];
            _results.push(render(child));
          }
          return _results;
        })();
        if (all((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = fragments.length; _j < _len1; _j++) {
            f = fragments[_j];
            _results.push(f.length === 2 && f[0] === LDC);
          }
          return _results;
        })())) {
          return [
            LDC, new APLArray((function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = fragments.length; _j < _len1; _j++) {
                f = fragments[_j];
                _results.push((x = f[1]).isSimple() ? x.unwrap() : x);
              }
              return _results;
            })())
          ];
        } else {
          return (_ref5 = []).concat.apply(_ref5, __slice.call(fragments).concat([VEC], [node.length - 1]));
        }
        break;
      case 'monadic':
        return render(node[2]).concat(render(node[1]), MON);
      case 'adverb':
        return render(node[1]).concat(render(node[2]), MON);
      case 'dyadic':
      case 'conjunction':
        return render(node[3]).concat(render(node[2]), render(node[1]), DYA);
      case 'hook':
        v = node.scopeNode.vars._hook;
        return render(node[2]).concat(GET, v.scopeDepth, v.slot, render(node[1]), DYA);
      case 'fork':
        u = node.scopeNode.vars._hook;
        v = node.scopeNode.vars._fork1;
        w = node.scopeNode.vars._fork2;
        i = node.length - 1;
        r = render(node[i--]);
        while (i >= 2) {
          r = r.concat(GET, v.scopeDepth, v.slot, render(node[i--]), DYA, GET, w.scopeDepth, w.slot, render(node[i--]), DYA);
        }
        if (i) {
          return r.concat(render(node[1]), GET, u.scopeDepth, u.slot, DYA);
        } else {
          return r;
        }
        break;
      default:
        throw Error("Unrecognized node type, '" + node[0] + "'");
    }
  };
  renderLHS = function(node) {
    var axes, c, child, i, n, name, v, _ref2, _ref3, _ref4;
    switch (node[0]) {
      case 'symbol':
        name = node[1];
        vars = node.scopeNode.vars;
        if (((_ref2 = (v = vars["set_" + name])) != null ? _ref2.type : void 0) === 'F') {
          return [GET, v.scopeDepth, v.slot, MON];
        } else {
          v = vars[name];
          return [SET, v.scopeDepth, v.slot];
        }
        break;
      case 'expr':
        n = node.length - 1;
        return (_ref3 = [SPL, n]).concat.apply(_ref3, (function() {
          var _j, _len1, _ref3, _results;
          _ref3 = node.slice(1);
          _results = [];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            _results.push(renderLHS(child).concat(POP));
          }
          return _results;
        })());
      case 'index':
        v = node.scopeNode.vars._substitute;
        axes = (function() {
          var _j, _len1, _ref4, _results;
          _ref4 = node.slice(2);
          _results = [];
          for (i = _j = 0, _len1 = _ref4.length; _j < _len1; i = ++_j) {
            c = _ref4[i];
            if (c) {
              _results.push(i);
            }
          }
          return _results;
        })();
        return (_ref4 = []).concat.apply(_ref4, __slice.call((function() {
          var _j, _len1, _ref4, _results;
          _ref4 = node.slice(2);
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            c = _ref4[_j];
            if (c) {
              _results.push(render(c));
            }
          }
          return _results;
        })()).concat([VEC], [axes.length], [render(node[1])], [LDC], [new APLArray(axes)], [VEC], [4], [GET], [v.scopeDepth], [v.slot], [MON], [renderLHS(node[1])]));
      default:
        throw Error("Unrecognized node type for assignment, '" + node[0] + "'");
    }
  };
  return render(ast);
};
prelude = execInternal("⍬←0⍴0\n⍝ ⍬     <=> 0⍴0\n⍝ ⍴⍬    <=> ,0\n⍝# ⍬←5   !!!\n⍝ ⍳0    <=> ⍬\n⍝ ⍴0    <=> ⍬\n⍝ ⍬     <=> ⍬\n⍝ ⍬⍬    <=> ⍬ ⍬\n⍝ 1⍬2⍬3 <=> 1 ⍬ 2 ⍬ 3\n\n⊢←{⍵}\n⍝ 123⊢456 <=> 456\n⍝ ⊢456 <=> 456\n\n⊣←{}⍠{⍺}\n⍝ 123⊣456 <=> 123\n⍝ ⊣456 <=> ⍬\n\n⌹←{\n  norm←{(⍵+.×+⍵)*0.5}\n\n  QR←{ ⍝ QR decomposition\n    n←(⍴⍵)[1]\n    1≥n:{t←norm,⍵ ⋄ (⍵÷t)(⍪t)}⍵\n    m←⌈n÷2\n    a0←((1↑⍴⍵),m)↑⍵\n    a1←(0,m)↓⍵\n    (q0 r0)←∇a0\n    c←(+⍉q0)+.×a1\n    (q1 r1)←∇a1-q0+.×c\n    (q0,q1)((r0,c)⍪((⌊n÷2),-n)↑r1)\n  }\n\n  Rinv←{ ⍝ Inverse of an upper triangular matrix\n    1=n←1↑⍴⍵:÷⍵\n    m←⌈n÷2\n    ai←∇(m,m)↑⍵\n    di←∇(m,m)↓⍵\n    b←(m,m-n)↑⍵\n    bx←-ai+.×b+.×di\n    (ai,bx)⍪((⌊n÷2),-n)↑di\n  }\n\n  0=⍴⍴⍵:÷⍵\n  1=⍴⍴⍵:,∇⍪⍵\n  2≠⍴⍴⍵:↗'ASSERTION ERROR'\n  0∊≥/⍴⍵:↗'ASSERTION ERROR'\n  (Q R)←QR ⍵\n  (Rinv R)+.×+⍉Q\n}⍠{\n  (⌹⍵)+.×⍺\n}\n⍝ ⌹2 <=> .5\n⍝ ⌹2 2⍴4 3 3 2 <=> 2 2⍴¯2 3 3 ¯4\n⍝ (4 4⍴12 1 4 10 ¯6 ¯5 4 7 ¯4 9 3 4 ¯2 ¯6 7 7)⌹93 81 93.5 120.5 <=>\n⍝ ... .0003898888816687221 ¯.005029566573526544 .04730651764247189 .0705568912859835\n", {
  ctx: vocabulary
});
aplify = function(x) {
  var y;
  if (typeof x === 'string') {
    if (x.length === 1) {
      return APLArray.scalar(x);
    } else {
      return new APLArray(x);
    }
  } else if (typeof x === 'number') {
    return APLArray.scalar(x);
  } else if (x instanceof Array) {
    return new APLArray((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = x.length; _i < _len; _i++) {
        y = x[_i];
        _results.push((y = aplify(y), !y.shape.length ? y.unwrap() : y));
      }
      return _results;
    })());
  } else if (x instanceof APLArray) {
    return x;
  } else {
    throw Error('Cannot aplify object ' + x);
  }
};

this.apl = apl = function(aplCode) {
  return exec(aplCode);
};

apl.approx = approx;

if (typeof module !== "undefined" && module !== null) {
  module.exports = apl;
  if (module === (typeof require !== "undefined" && require !== null ? require.main : void 0)) {
    (function() {
      var arg, b, ctx, file, k, rl, usage, _i, _len, _ref1;
      usage = 'Usage: apl.js filename.apl\n';
      file = null;
      _ref1 = process.argv.slice(2);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        arg = _ref1[_i];
        if (arg === '-h' || arg === '--help') {
          process.stderr.write(usage);
          process.exit(0);
        } else if (/^-/.test(arg)) {
          process.stderr.write("unrecognized option: " + arg + "\n" + usage);
          process.exit(1);
        } else if (file != null) {
          process.stderr.write(usage);
          process.exit(1);
        } else {
          file = arg;
        }
      }
      if (file != null) {
        exec(require('fs').readFileSync(file, 'utf8'));
      } else if (!require('tty').isatty()) {
        exec(Buffer.concat((function() {
          var _results;
          _results = [];
          while (true) {
            b = new Buffer(1024);
            if (!(k = require('fs').readSync(0, b, 0, b.length, null))) {
              break;
            }
            _results.push(b.slice(0, k));
          }
          return _results;
        })()).toString('utf8'));
      } else {
        process.stdout.write("ngn apl 2013-11-07\n");
        rl = require('readline').createInterface(process.stdin, process.stdout);
        rl.setPrompt('      ');
        ctx = Object.create(vocabulary);
        rl.on('line', function(line) {
          var e, result;
          try {
            if (!line.match(/^[\ \t\f\r\n]*$/)) {
              result = exec(line, {
                ctx: ctx
              });
              process.stdout.write(format(result).join('\n') + '\n');
            }
          } catch (_error) {
            e = _error;
            process.stdout.write(e.toString() + '\n');
          }
          rl.prompt();
        });
        rl.on('close', function() {
          process.stdout.write('\n');
          return process.exit(0);
        });
        rl.prompt();
      }
    })();
  }
}
