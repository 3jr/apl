// Generated by CoffeeScript 1.4.0
var define;

if (typeof define !== 'function') {
  define = require('amdefine')(module);
}

define(['./parser', './helpers', './builtins', './complex'], function(parser, helpers, builtinsModule, complex) {
  var assert, assignParents, builtinVarInfo, builtins, closestScope, compile, createHash, die, exec, hex4, inherit, isArray, jsName, ord, predefinedNames, printAST, repr, resolveSeqs, toJavaScript;
  if (parser == null) {
    parser = window.parser;
  }
  inherit = helpers.inherit, die = helpers.die, assert = helpers.assert;
  repr = JSON.stringify;
  createHash = function(s) {
    var h, k, kv, v, _i, _len, _ref, _ref1;
    h = {};
    _ref = s.split('\n');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      kv = _ref[_i];
      _ref1 = kv.split(/\ +/), k = _ref1[0], v = _ref1[1];
      h[k] = v;
    }
    return h;
  };
  predefinedNames = createHash('⍺  _a\n⍵  _w\n+  _add\n-  _sub\n×  _mul\n÷  _div\n!  _bang\n?  _ques\n⌷  _index\n⍴  _r\n⍳  _i\n,  _cat\n⍪  _cat1\n⎕  _q\n⍞  _qq\n∈  _e\n⍷  _eu\n∼  _tilde\n↑  _take\n↓  _drop\n⍉  _trans\n⌽  _rot\n⊖  _rot1\n⌽  _circ\n○  _circ\n⍬  _zilde\n⋆  _pow\n⌈  _max\n⌊  _min\n∘. _outer\n.  _inner\n∣  _mod\n⊤  _tee\n⊥  _bot\n∪  _cup\n∩  _cap\n⊂  _enclose\n⊃  _disclose\n⍒  _gradeUp\n⍋  _gradeDown\n⍣  _powOp\n¨  _each\n/  _slash\n⌿  _slash1\n\\ _bslash\n⍀  _bslash1\n=  _eq\n≠  _ne\n<  _lt\n>  _gt\n≤  _le\n≥  _ge');
  ord = function(s) {
    return s.charCodeAt(0);
  };
  hex4 = function(n) {
    var s;
    s = '0000' + n.toString(16);
    return s.slice(s.length - 4);
  };
  jsName = function(name) {
    return predefinedNames[name] || name.replace(/[^a-z0-9]/gi, function(x) {
      return '_' + hex4(ord(x));
    });
  };
  builtins = inherit(builtinsModule.builtins);
  builtins.Complex = complex.Complex;
  builtinVarInfo = {
    '⍺': {
      type: 'X'
    },
    '⍵': {
      type: 'X'
    },
    '∇': {
      type: 'F'
    }
  };
  (function() {
    var k, v, _ref, _ref1, _ref2, _ref3, _results;
    _results = [];
    for (k in builtins) {
      v = builtins[k];
      v = builtins[k];
      builtinVarInfo[k] = typeof v !== 'function' ? {
        type: 'X'
      } : ((_ref = v.aplMetaInfo) != null ? _ref.isNiladicFunction : void 0) ? {
        type: 'F',
        isNiladicFunction: true
      } : ((_ref1 = v.aplMetaInfo) != null ? _ref1.isPrefixOperator : void 0) ? {
        type: 'F',
        isPrefixOperator: true
      } : ((_ref2 = v.aplMetaInfo) != null ? _ref2.isPostfixOperator : void 0) ? {
        type: 'F',
        isPostfixOperator: true
      } : ((_ref3 = v.aplMetaInfo) != null ? _ref3.isInfixOperator : void 0) ? {
        type: 'F',
        isInfixOperator: true
      } : {
        type: 'F'
      };
      if (k.match(/^[gs]et_.*/)) {
        _results.push(builtinVarInfo[k.slice(4)] = {
          type: 'X'
        });
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  })();
  exec = function(source, opts) {
    var h, k, v, _ref;
    if (opts == null) {
      opts = {};
    }
    h = inherit(builtins);
    if (opts.extraContext) {
      _ref = opts.extraContext;
      for (k in _ref) {
        v = _ref[k];
        h[k] = v;
      }
    }
    return (new Function(compile(source, opts)))(h);
  };
  compile = function(source, opts) {
    var ast, output;
    if (opts == null) {
      opts = {};
    }
    if (opts.debug) {
      console.info('-----APL SOURCE-----\n' + source);
    }
    ast = parser.parse(source);
    if (opts.debug) {
      console.info('-----RAW AST-----\n');
      printAST(ast);
    }
    assignParents(ast);
    resolveSeqs(ast);
    if (opts.debug) {
      console.info('-----AST-----\n');
      printAST(ast);
    }
    output = toJavaScript(ast);
    if (opts.debug) {
      console.info('-----JS OUTPUT-----\n' + output);
    }
    return output;
  };
  assignParents = function(node) {
    var child, _i, _len, _ref;
    _ref = node.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (!(child)) {
        continue;
      }
      assignParents(child);
      child.parent = node;
    }
  };
  resolveSeqs = function(ast) {
    var node, queue, scopeNode, vars, visit, _i, _len, _ref;
    ast.vars = inherit(builtinVarInfo);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      scopeNode.varsToDeclare = [];
      visit = function(node) {
        var a, c, child, h, i, j, name, t, t1, v, _i, _j, _k, _len, _len1, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            queue.push(node);
            return null;
          case 'guard':
            visit(node[1]);
            return visit(node[2]);
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              assert(vars[name].type === h.type, "Inconsistent usage of symbol '" + name + "', it is assigned both data and functions");
            } else {
              vars[name] = h;
              scopeNode.varsToDeclare.push(jsName(name));
            }
            return h;
          case 'sym':
            name = node[1];
            if (((_ref = (v = vars["get_" + name])) != null ? _ref.type : void 0) === 'F') {
              v.used = true;
              return {
                type: 'X'
              };
            } else {
              v = vars[name];
              assert(v, "Symbol '" + name + "' referenced before assignment");
              v.used = true;
              return v;
            }
            break;
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            _ref1 = node.slice(2);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              c = _ref1[_i];
              if (!(c !== null)) {
                continue;
              }
              t = visit(c);
              assert(t.type === 'X', 'Only data can be used as an index');
            }
            return t1;
          case 'embedded':
            return {
              type: 'X'
            };
          case 'seq':
            a = node.slice(1);
            a.reverse();
            h = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
                child = a[_j];
                _results.push(visit(child));
              }
              return _results;
            })();
            h.reverse();
            a.reverse();
            for (i = _j = 0, _ref2 = a.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
              if (h[i].isNiladicFunction) {
                a[i] = ['niladic', a[i]];
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if ((h[i].type === (_ref3 = h[i + 1].type) && _ref3 === 'X')) {
                j = i + 2;
                while (j < a.length && h[j].type === 'X') {
                  j++;
                }
                [].splice.apply(a, [i, j - i].concat(_ref4 = [['vector'].concat(a.slice(i, j))])), _ref4;
                [].splice.apply(h, [i, j - i].concat(_ref5 = [
                  {
                    type: 'X'
                  }
                ])), _ref5;
              } else {
                i++;
              }
            }
            i = a.length - 2;
            while (--i >= 0) {
              if (h[i + 1].isInfixOperator && (h[i].type === 'F' || h[i + 2].type === 'F')) {
                [].splice.apply(a, [i, (i + 3) - i].concat(_ref6 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref6;
                [].splice.apply(h, [i, (i + 3) - i].concat(_ref7 = [
                  {
                    type: 'F'
                  }
                ])), _ref7;
                i--;
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref8 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref8;
                [].splice.apply(h, [i, (i + 2) - i].concat(_ref9 = [
                  {
                    type: 'F'
                  }
                ])), _ref9;
              } else {
                i++;
              }
            }
            i = a.length - 1;
            while (--i >= 0) {
              if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref10 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref10;
                [].splice.apply(h, [i, (i + 2) - i].concat(_ref11 = [
                  {
                    type: 'F'
                  }
                ])), _ref11;
              }
            }
            if (h[h.length - 1].type === 'F') {
              assert(h.length <= 1, 'Trailing function in expression');
            } else {
              while (h.length > 1) {
                if (h.length === 2 || h[h.length - 3].type === 'F') {
                  [].splice.apply(a, [(_ref12 = h.length - 2), 9e9].concat(_ref13 = [['monadic'].concat(a.slice(h.length - 2))])), _ref13;
                  [].splice.apply(h, [(_ref14 = h.length - 2), 9e9].concat(_ref15 = [
                    {
                      type: 'X'
                    }
                  ])), _ref15;
                } else {
                  [].splice.apply(a, [(_ref16 = h.length - 3), 9e9].concat(_ref17 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref17;
                  [].splice.apply(h, [(_ref18 = h.length - 3), 9e9].concat(_ref19 = [
                    {
                      type: 'X'
                    }
                  ])), _ref19;
                }
              }
            }
            [].splice.apply(node, [0, 9e9].concat(_ref20 = a[0])), _ref20;
            a[0].parent = null;
            _ref21 = node.slice(1);
            for (_k = 0, _len1 = _ref21.length; _k < _len1; _k++) {
              c = _ref21[_k];
              if (c) {
                c.parent = node;
              }
            }
            return h[0];
          default:
            return die("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref = scopeNode.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        visit(node);
      }
    }
  };
  toJavaScript = function(ast) {
    var k, s, v, visit;
    visit = function(node) {
      var a, c, child, d, getter, n, name, r, s, setter, v, x, _ref, _ref1;
      switch (node[0]) {
        case 'body':
          r = '';
          if (node.length === 1) {
            return 'return [];\n';
          } else {
            if (node.varsToDeclare.length) {
              r += 'var ' + node.varsToDeclare.join(', ') + ';\n';
            }
            a = (function() {
              var _i, _len, _ref, _results;
              _ref = node.slice(1);
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                child = _ref[_i];
                _results.push(visit(child));
              }
              return _results;
            })();
            a[a.length - 1] = 'return ' + a[a.length - 1] + ';';
            return r += a.join(';\n');
          }
          break;
        case 'guard':
          return "if (_.bool(" + (visit(node[1])) + ")) {\n  return " + (visit(node[2])) + ";\n}";
        case 'assign':
          name = node[1];
          assert(name !== '∇', 'Assignment to ∇ is not allowed.');
          if (((_ref = (v = closestScope(node).vars[setter = "set_" + name])) != null ? _ref.type : void 0) === 'F') {
            v.used = true;
            return "" + (jsName(setter)) + "(" + (visit(node[2])) + ")";
          } else {
            return "" + (jsName(name)) + " = " + (visit(node[2]));
          }
          break;
        case 'sym':
          name = node[1];
          if (name === '∇') {
            return 'arguments.callee';
          } else if (((_ref1 = (v = closestScope(node).vars[getter = "get_" + name])) != null ? _ref1.type : void 0) === 'F') {
            v.used = true;
            return "" + (jsName(getter)) + "()";
          } else {
            return "" + (jsName(name));
          }
          break;
        case 'lambda':
          return "function (_w, _a) {\n  " + (visit(node[1])) + "\n}";
        case 'str':
          s = node[1];
          d = s[0];
          return "_.aplify(" + (d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d) + ")";
        case 'num':
          s = node[1].replace(/¯/g, '-');
          a = (function() {
            var _i, _len, _ref2, _results;
            _ref2 = s.split(/j/i);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              x = _ref2[_i];
              if (x === '-') {
                _results.push('Infinity');
              } else if (x === '--') {
                _results.push('-Infinity');
              } else if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          if (a.length === 1) {
            return '' + a[0];
          } else {
            return "new _.Complex(" + a[0] + ", " + a[1] + ")";
          }
          break;
        case 'index':
          closestScope(node).vars['⌷'].used = true;
          return "_index(" + (visit(node[1])) + ", [" + (((function() {
            var _i, _len, _ref2, _results;
            _ref2 = node.slice(2);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              c = _ref2[_i];
              if (c === null) {
                _results.push('[]');
              } else {
                _results.push(visit(c));
              }
            }
            return _results;
          })()).join(', ')) + "])";
        case 'seq':
          return die('No "seq" nodes are expected at this stage.');
        case 'vector':
          n = node.length - 1;
          return "[" + (((function() {
            var _i, _len, _ref2, _results;
            _ref2 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              child = _ref2[_i];
              _results.push(visit(child));
            }
            return _results;
          })()).join(', ')) + "]";
        case 'niladic':
          return "" + (visit(node[1])) + "()";
        case 'monadic':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'dyadic':
          return "" + (visit(node[2])) + "(" + (visit(node[3])) + ", " + (visit(node[1])) + ")";
        case 'prefixOperator':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'infixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[3])) + ", " + (visit(node[1])) + ")";
        case 'postfixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ")";
        case 'embedded':
          return "_.aplify(" + (node[1].replace(/(^«|»$)/g, '')) + ")";
        default:
          return die("Unrecognised node type, '" + node[0] + "'");
      }
    };
    s = visit(ast);
    return "var " + (['_ = arguments[0]'].concat((function() {
      var _results;
      _results = [];
      for (k in builtinVarInfo) {
        v = builtinVarInfo[k];
        if (v.used) {
          _results.push("" + (jsName(k)) + " = _[" + (repr(k)) + "]");
        }
      }
      return _results;
    })()).join(',\n    ')) + ";\n" + s;
  };
  closestScope = function(node) {
    while (node[0] !== 'body') {
      node = node.parent;
    }
    return node;
  };
  isArray = function(x) {
    return ((x != null ? x.length : void 0) != null) && typeof x !== 'string';
  };
  printAST = function(x, indent) {
    var y, _i, _len, _ref;
    if (indent == null) {
      indent = '';
    }
    if (isArray(x)) {
      if (x.length === 2 && !isArray(x[1])) {
        console.info(indent + x[0] + ' ' + JSON.stringify(x[1]));
      } else {
        console.info(indent + x[0]);
        _ref = x.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          y = _ref[_i];
          printAST(y, indent + '  ');
        }
      }
    } else {
      console.info(indent + JSON.stringify(x));
    }
  };
  return {
    exec: exec
  };
});
