// Generated by CoffeeScript 1.3.3
(function() {
  var compile, firstPass, globalVarInfo, inherit, isArray, parse, printAST;

  parse = require('../lib/parser').parse;

  inherit = require('./helpers').inherit;

  globalVarInfo = {
    '+': {
      type: 'F'
    },
    '/': {
      type: 'F',
      isPostfixOperator: true
    },
    '⍣': {
      type: 'F',
      isInfixOperator: true
    }
  };

  compile = function(source) {
    var ast;
    ast = parse(source);
    firstPass(ast);
    return printAST(ast);
  };

  firstPass = function(ast) {
    var node, queue, scopeNode, vars, visit, _i, _len, _ref;
    ast.vars = inherit(globalVarInfo);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      visit = function(node) {
        var a, child, h, i, j, name, t1, t2, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            queue.push(node);
            return null;
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              if (vars[name].type !== h.type) {
                throw Error("Inconsistent usage of symbol '" + name + "'");
              }
            } else {
              vars[name] = h;
            }
            return h;
          case 'sym':
            name = node[1];
            if (!(vars[name] != null)) {
              throw Error("Symbol '" + name + "' referenced before assignment");
            }
            return vars[name];
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            t2 = visit(node[2]);
            if (t2 !== 'X') {
              throw Error('Only data can be used as an index');
            }
            return t1;
          case 'seq':
            if (node.length === 1) {
              return {
                type: 'X'
              };
            } else if (node.length === 2) {
              return visit(node.seqTree = node[1]);
            } else {
              a = node.slice(1);
              h = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = a.length; _i < _len; _i++) {
                  child = a[_i];
                  _results.push(visit(child));
                }
                return _results;
              })();
              i = 0;
              while (i < a.length - 1) {
                if ((h[i].type === (_ref = h[i + 1].type) && _ref === 'X')) {
                  j = i + 2;
                  while (j < a.length && h[j].type === 'X') {
                    j++;
                  }
                  [].splice.apply(a, [i, j - i].concat(_ref1 = [['vector'].concat(a.slice(i, j))])), _ref1;
                  [].splice.apply(h, [i, j - i].concat(_ref2 = [
                    {
                      type: 'X'
                    }
                  ])), _ref2;
                } else {
                  i++;
                }
              }
              i = a.length - 2;
              while (--i >= 0) {
                if ((h[i].type === (_ref3 = h[i + 2].type) && _ref3 === 'F') && h[i + 1].isInfixOperator && h[i + 2].type === 'F') {
                  [].splice.apply(a, [i, (i + 3) - i].concat(_ref4 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref4;
                  [].splice.apply(h, [i, (i + 3) - i].concat(_ref5 = [
                    {
                      type: 'F'
                    }
                  ])), _ref5;
                  i--;
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref6 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref6;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref7 = [
                    {
                      type: 'F'
                    }
                  ])), _ref7;
                } else {
                  i++;
                }
              }
              i = a.length - 1;
              while (--i >= 0) {
                if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref8 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref8;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref9 = [
                    {
                      type: 'F'
                    }
                  ])), _ref9;
                }
              }
              if (h[h.length - 1].type === 'F') {
                if (h.length > 1) {
                  throw Error('Trailing function in expression');
                }
              } else {
                while (h.length > 1) {
                  if (h.length === 2 || h[h.length - 3].type === 'F') {
                    [].splice.apply(a, [(_ref10 = h.length - 2), 9e9].concat(_ref11 = [['monadic'].concat(a.slice(h.length - 2))])), _ref11;
                    [].splice.apply(h, [(_ref12 = h.length - 2), 9e9].concat(_ref13 = [
                      {
                        type: 'X'
                      }
                    ])), _ref13;
                  } else {
                    [].splice.apply(a, [(_ref14 = h.length - 3), 9e9].concat(_ref15 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref15;
                    [].splice.apply(h, [(_ref16 = h.length - 3), 9e9].concat(_ref17 = [
                      {
                        type: 'X'
                      }
                    ])), _ref17;
                  }
                }
              }
              node.seqTree = a[0];
              console.info('seqTree', node.seqTree);
              return h[0];
            }
            break;
          default:
            throw Error("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref = scopeNode.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        visit(node);
      }
    }
  };

  isArray = function(x) {
    return (x.length != null) && typeof x !== 'string';
  };

  printAST = function(x, indent) {
    var y, _i, _len, _ref;
    if (indent == null) {
      indent = '';
    }
    if (isArray(x)) {
      x = x.seqTree || x;
      if (x.length === 2 && !isArray(x[1])) {
        console.info(indent + x[0] + ' ' + JSON.stringify(x[1]));
      } else {
        console.info(indent + x[0]);
        _ref = x.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          y = _ref[_i];
          printAST(y, indent + '  ');
        }
      }
    } else {
      console.info(indent + JSON.stringify(x));
    }
  };

  compile('f ← g ← h ← {}\nx ← y ← z ← 0\nf x y g h z');

}).call(this);
