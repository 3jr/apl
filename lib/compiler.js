// Generated by CoffeeScript 1.3.3
(function() {
  var assert, assignParents, builtinVarInfo, builtins, closestScope, compile, createHash, die, exec, helpers, hex4, inherit, isArray, jsName, ord, parse, predefinedNames, printAST, repr, resolveSeqs, toJavaScript, _ref;

  parse = require('../lib/parser').parse;

  _ref = helpers = require('./helpers'), inherit = _ref.inherit, die = _ref.die, assert = _ref.assert;

  repr = JSON.stringify;

  createHash = function(s) {
    var h, k, kv, v, _i, _len, _ref1, _ref2;
    h = {};
    _ref1 = s.split('\n');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      kv = _ref1[_i];
      _ref2 = kv.split(/\ +/), k = _ref2[0], v = _ref2[1];
      h[k] = v;
    }
    return h;
  };

  predefinedNames = createHash('⍺  _a\n⍵  _w\n+  _add\n-  _sub\n×  _mul\n÷  _div\n!  _bang\n?  _ques\n⌷  _index\n⍴  _r\n⍳  _i\n,  _cat\n⍪  _cat1\n⎕  _q\n⍞  _qq\n∈  _e\n⍷  _eu\n∼  _tilde\n↑  _take\n↓  _drop\n⍉  _trans\n⌽  _rot\n⊖  _rot1\n⌽  _circ\n○  _circ\n⍬  _zilde\n⋆  _pow\n⌈  _max\n⌊  _min\n∘. _outer\n.  _inner\n∣  _mod\n⊤  _tee\n⊥  _bot\n∪  _cup\n∩  _cap\n⊂  _enclose\n⊃  _disclose\n⍒  _gradeUp\n⍋  _gradeDown\n⍣  _powOp\n¨  _each\n/  _slash\n⌿  _slash1\n\\ _bslash\n⍀  _bslash1\n=  _eq\n≠  _ne\n<  _lt\n>  _gt\n≤  _le\n≥  _ge');

  ord = function(s) {
    return s.charCodeAt(0);
  };

  hex4 = function(n) {
    var s;
    s = '0000' + n.toString(16);
    return s.slice(s.length - 4);
  };

  jsName = function(name) {
    return predefinedNames[name] || name.replace(/[^a-z0-9]/gi, function(x) {
      return '_' + hex4(ord(x));
    });
  };

  builtins = inherit(require('./builtins').builtins);

  builtinVarInfo = {
    '⍺': {
      type: 'X'
    },
    '⍵': {
      type: 'X'
    }
  };

  (function() {
    var k, v;
    for (k in builtins) {
      v = builtins[k];
      v = builtins[k];
      builtinVarInfo[k] = typeof v !== 'function' ? {
        type: 'X'
      } : v.isNiladicFunction ? {
        type: 'F',
        isNiladicFunction: true
      } : v.isPrefixOperator ? {
        type: 'F',
        isPrefixOperator: true
      } : v.isPostfixOperator ? {
        type: 'F',
        isPostfixOperator: true
      } : v.isInfixOperator ? {
        type: 'F',
        isInfixOperator: true
      } : {
        type: 'F'
      };
      if (k.match(/^[gs]et_.*/)) {
        builtinVarInfo[k.slice(4)] = {
          type: 'X'
        };
      }
    }
    return builtinVarInfo['set_⎕'].blah = 'qer';
  })();

  exports.exec = exec = function(source, opts) {
    var h, k, v, _ref1;
    if (opts == null) {
      opts = {};
    }
    h = inherit(builtins);
    if (opts.extraContext) {
      _ref1 = opts.extraContext;
      for (k in _ref1) {
        v = _ref1[k];
        h[k] = v;
      }
    }
    return (new Function(compile(source, opts)))(h);
  };

  compile = function(source, opts) {
    var ast, output;
    if (opts == null) {
      opts = {};
    }
    if (opts.debug) {
      console.info('-----APL SOURCE-----\n' + source);
    }
    ast = parse(source);
    if (opts.debug) {
      console.info('-----RAW AST-----\n');
      printAST(ast);
    }
    assignParents(ast);
    resolveSeqs(ast);
    if (opts.debug) {
      console.info('-----AST-----\n');
      printAST(ast);
    }
    output = toJavaScript(ast);
    if (opts.debug) {
      console.info('-----JS OUTPUT-----\n' + output);
    }
    return output;
  };

  assignParents = function(node) {
    var child, _i, _len, _ref1;
    _ref1 = node.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      assignParents(child);
      child.parent = node;
    }
  };

  resolveSeqs = function(ast) {
    var node, queue, scopeNode, vars, visit, _i, _len, _ref1;
    ast.vars = inherit(builtinVarInfo);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      scopeNode.varsToDeclare = [];
      visit = function(node) {
        var a, child, h, i, j, name, t1, t2, _i, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            queue.push(node);
            return null;
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              assert(vars[name].type === h.type, "Inconsistent usage of symbol '" + name + "', it is assigned both data and functions");
            } else {
              vars[name] = h;
              scopeNode.varsToDeclare.push(jsName(name));
            }
            return h;
          case 'sym':
            name = node[1];
            assert(vars[name] != null, "Symbol '" + name + "' referenced before assignment");
            vars[name].used = true;
            return vars[name];
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            t2 = visit(node[2]);
            assert(t2.type === 'X', 'Only data can be used as an index');
            return t1;
          case 'embedded':
            return {
              type: 'X'
            };
          case 'seq':
            a = node.slice(1);
            a.reverse();
            h = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = a.length; _i < _len; _i++) {
                child = a[_i];
                _results.push(visit(child));
              }
              return _results;
            })();
            h.reverse();
            a.reverse();
            for (i = _i = 0, _ref1 = a.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
              if (h[i].isNiladicFunction) {
                a[i] = ['niladic', a[i]];
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if ((h[i].type === (_ref2 = h[i + 1].type) && _ref2 === 'X')) {
                j = i + 2;
                while (j < a.length && h[j].type === 'X') {
                  j++;
                }
                [].splice.apply(a, [i, j - i].concat(_ref3 = [['vector'].concat(a.slice(i, j))])), _ref3;
                [].splice.apply(h, [i, j - i].concat(_ref4 = [
                  {
                    type: 'X'
                  }
                ])), _ref4;
              } else {
                i++;
              }
            }
            i = a.length - 2;
            while (--i >= 0) {
              if (h[i + 1].isInfixOperator && (h[i].type === 'F' || h[i + 2].type === 'F')) {
                [].splice.apply(a, [i, (i + 3) - i].concat(_ref5 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref5;
                [].splice.apply(h, [i, (i + 3) - i].concat(_ref6 = [
                  {
                    type: 'F'
                  }
                ])), _ref6;
                i--;
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref7 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref7;
                [].splice.apply(h, [i, (i + 2) - i].concat(_ref8 = [
                  {
                    type: 'F'
                  }
                ])), _ref8;
              } else {
                i++;
              }
            }
            i = a.length - 1;
            while (--i >= 0) {
              if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref9 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref9;
                [].splice.apply(h, [i, (i + 2) - i].concat(_ref10 = [
                  {
                    type: 'F'
                  }
                ])), _ref10;
              }
            }
            if (h[h.length - 1].type === 'F') {
              assert(h.length <= 1, 'Trailing function in expression');
            } else {
              while (h.length > 1) {
                if (h.length === 2 || h[h.length - 3].type === 'F') {
                  [].splice.apply(a, [(_ref11 = h.length - 2), 9e9].concat(_ref12 = [['monadic'].concat(a.slice(h.length - 2))])), _ref12;
                  [].splice.apply(h, [(_ref13 = h.length - 2), 9e9].concat(_ref14 = [
                    {
                      type: 'X'
                    }
                  ])), _ref14;
                } else {
                  [].splice.apply(a, [(_ref15 = h.length - 3), 9e9].concat(_ref16 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref16;
                  [].splice.apply(h, [(_ref17 = h.length - 3), 9e9].concat(_ref18 = [
                    {
                      type: 'X'
                    }
                  ])), _ref18;
                }
              }
            }
            [].splice.apply(node, [0, 9e9].concat(_ref19 = a[0])), _ref19;
            a[0][0] = 'IDIOT';
            a[0].parent = null;
            return h[0];
          default:
            return die("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref1 = scopeNode.slice(1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        visit(node);
      }
    }
  };

  toJavaScript = function(ast) {
    var k, s, v, visit;
    visit = function(node) {
      var a, child, d, n, name, r, s, setter, v, x, _ref1;
      switch (node[0]) {
        case 'body':
          r = '';
          if (node.varsToDeclare.length) {
            r += 'var ' + node.varsToDeclare.join(', ') + ';\n';
          }
          a = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              child = _ref1[_i];
              _results.push(visit(child));
            }
            return _results;
          })();
          a[a.length - 1] = 'return ' + a[a.length - 1] + ';';
          return r += a.join(';\n');
        case 'assign':
          name = node[1];
          if (((_ref1 = (v = closestScope(node).vars[setter = "set_" + name])) != null ? _ref1.type : void 0) === 'F') {
            v.used = true;
            return "" + (jsName(setter)) + "(" + (visit(node[2])) + ")";
          } else {
            return "" + (jsName(name)) + " = " + (visit(node[2]));
          }
          break;
        case 'sym':
          return "" + (jsName(node[1]));
        case 'lambda':
          return "function (_w, _a) {\n  " + (visit(node[1])) + "\n}";
        case 'str':
          s = node[1];
          d = s[0];
          return d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d + '.split("")';
        case 'num':
          s = node[1].replace(/¯/g, '-');
          a = (function() {
            var _i, _len, _ref2, _results;
            _ref2 = s.split(/j/i);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              x = _ref2[_i];
              if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          if (a.length === 1) {
            return '' + a[0];
          } else {
            return "new Complex(" + a[0] + ", " + a[1] + ")";
          }
          break;
        case 'index':
          closestScope(node).vars['⌷'].used = true;
          return "_index(" + (visit(node[1])) + ", " + (visit(node[2])) + ")";
        case 'seq':
          return die('No "seq" nodes are expected at this stage.');
        case 'vector':
          n = node.length - 1;
          return "[" + (((function() {
            var _i, _len, _ref2, _results;
            _ref2 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              child = _ref2[_i];
              _results.push(visit(child));
            }
            return _results;
          })()).join(', ')) + "]";
        case 'niladic':
          return "" + (visit(node[1])) + "()";
        case 'monadic':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'dyadic':
          return "" + (visit(node[2])) + "(" + (visit(node[3])) + ", " + (visit(node[1])) + ")";
        case 'prefixOperator':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'infixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[3])) + ", " + (visit(node[1])) + ")";
        case 'postfixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ")";
        case 'embedded':
          return "(" + (node[1].replace(/(^«|»$)/g, '')) + ")";
        default:
          return die("Unrecognised node type, '" + node[0] + "'");
      }
    };
    s = visit(ast);
    return "var " + (['_ = arguments[0]'].concat((function() {
      var _results;
      _results = [];
      for (k in builtinVarInfo) {
        v = builtinVarInfo[k];
        if (v.used) {
          _results.push("" + (jsName(k)) + " = _[" + (repr(k)) + "]");
        }
      }
      return _results;
    })()).join(',\n    ')) + ";\n" + s;
  };

  closestScope = function(node) {
    while (node[0] !== 'body') {
      node = node.parent;
    }
    return node;
  };

  isArray = function(x) {
    return (x.length != null) && typeof x !== 'string';
  };

  printAST = function(x, indent) {
    var y, _i, _len, _ref1;
    if (indent == null) {
      indent = '';
    }
    if (isArray(x)) {
      if (x.length === 2 && !isArray(x[1])) {
        console.info(indent + x[0] + ' ' + JSON.stringify(x[1]));
      } else {
        console.info(indent + x[0]);
        _ref1 = x.slice(1);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          y = _ref1[_i];
          printAST(y, indent + '  ');
        }
      }
    } else {
      console.info(indent + JSON.stringify(x));
    }
  };

  if (module === require.main) {
    (function() {
      var r;
      r = exec('"asdf" = "asdg"', {
        debug: true
      });
      return console.info('-----RESULT-----\n' + r);
    })();
  }

}).call(this);
