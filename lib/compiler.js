// Generated by CoffeeScript 1.3.3
(function() {
  var assert, assignParents, builtinVarInfo, closestScope, compile, die, helpers, inherit, isArray, jsProp, parse, printAST, repr, resolveSeqs, toJavaScript, _ref;

  parse = require('../lib/parser').parse;

  _ref = helpers = require('./helpers'), inherit = _ref.inherit, die = _ref.die, assert = _ref.assert;

  repr = JSON.stringify;

  builtinVarInfo = {
    '+': {
      type: 'F'
    },
    '−': {
      type: 'F'
    },
    '×': {
      type: 'F'
    },
    '÷': {
      type: 'F'
    },
    '/': {
      type: 'F',
      isPostfixOperator: true
    },
    '⍣': {
      type: 'F',
      isInfixOperator: true
    },
    '⍺': {
      type: 'X'
    },
    '⍵': {
      type: 'X'
    },
    '⍬': {
      type: 'X',
      isNiladicFunction: true
    },
    '⎕': {
      type: 'X',
      isNiladicFunction: true
    },
    'set_⎕': {
      type: 'F'
    },
    '⎕sleep': {
      type: 'F',
      cps: true
    }
  };

  compile = function(source) {
    var ast;
    ast = parse(source);
    assignParents(ast);
    resolveSeqs(ast);
    return toJavaScript(ast);
  };

  assignParents = function(node) {
    var child, _i, _len, _ref1;
    _ref1 = node.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      assignParents(child);
      child.parent = node;
    }
  };

  resolveSeqs = function(ast) {
    var node, queue, scopeNode, vars, visit, _i, _len, _ref1;
    ast.vars = inherit(builtinVarInfo);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      visit = function(node) {
        var a, child, h, i, j, name, t1, t2, x, _i, _j, _len, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            queue.push(node);
            return null;
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              assert(vars[name].type === h.type, "Inconsistent usage of symbol '" + name + "'");
            } else {
              vars[name] = h;
            }
            return h;
          case 'sym':
            name = node[1];
            assert(vars[name] != null, "Symbol '" + name + "' referenced before assignment");
            return vars[name];
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            t2 = visit(node[2]);
            assert(t2.type === 'X', 'Only data can be used as an index');
            return t1;
          case 'seq':
            if (node.length === 1) {
              return {
                type: 'X'
              };
            } else {
              a = node.slice(1);
              h = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = a.length; _i < _len; _i++) {
                  child = a[_i];
                  _results.push(visit(child));
                }
                return _results;
              })();
              for (i = _i = 0, _ref1 = a.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                if (h[i].isNiladicFunction) {
                  a[i] = ['niladic', a[i]];
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if ((h[i].type === (_ref2 = h[i + 1].type) && _ref2 === 'X')) {
                  j = i + 2;
                  while (j < a.length && h[j].type === 'X') {
                    j++;
                  }
                  [].splice.apply(a, [i, j - i].concat(_ref3 = [['vector'].concat(a.slice(i, j))])), _ref3;
                  [].splice.apply(h, [i, j - i].concat(_ref4 = [
                    {
                      type: 'X'
                    }
                  ])), _ref4;
                } else {
                  i++;
                }
              }
              i = a.length - 2;
              while (--i >= 0) {
                if ((h[i].type === (_ref5 = h[i + 2].type) && _ref5 === 'F') && h[i + 1].isInfixOperator && h[i + 2].type === 'F') {
                  [].splice.apply(a, [i, (i + 3) - i].concat(_ref6 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref6;
                  [].splice.apply(h, [i, (i + 3) - i].concat(_ref7 = [
                    {
                      type: 'F'
                    }
                  ])), _ref7;
                  i--;
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref8 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref8;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref9 = [
                    {
                      type: 'F'
                    }
                  ])), _ref9;
                } else {
                  i++;
                }
              }
              i = a.length - 1;
              while (--i >= 0) {
                if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref10 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref10;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref11 = [
                    {
                      type: 'F'
                    }
                  ])), _ref11;
                }
              }
              if (h[h.length - 1].type === 'F') {
                assert(h.length <= 1, 'Trailing function in expression');
              } else {
                while (h.length > 1) {
                  if (h.length === 2 || h[h.length - 3].type === 'F') {
                    [].splice.apply(a, [(_ref12 = h.length - 2), 9e9].concat(_ref13 = [['monadic'].concat(a.slice(h.length - 2))])), _ref13;
                    [].splice.apply(h, [(_ref14 = h.length - 2), 9e9].concat(_ref15 = [
                      {
                        type: 'X'
                      }
                    ])), _ref15;
                  } else {
                    [].splice.apply(a, [(_ref16 = h.length - 3), 9e9].concat(_ref17 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref17;
                    [].splice.apply(h, [(_ref18 = h.length - 3), 9e9].concat(_ref19 = [
                      {
                        type: 'X'
                      }
                    ])), _ref19;
                  }
                }
              }
              _ref20 = node.parent;
              for (i = _j = 0, _len = _ref20.length; _j < _len; i = ++_j) {
                x = _ref20[i];
                if (x === node) {
                  node.parent[i] = a[0];
                }
              }
              a[0].parent = node.parent;
              node.parent = null;
              return h[0];
            }
            break;
          default:
            return die("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref1 = scopeNode.slice(1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        visit(node);
      }
    }
  };

  toJavaScript = function(ast) {
    var depth, visit;
    depth = 0;
    visit = function(node) {
      var a, child, d, n, name, r, s, setter, x, _ref1;
      switch (node[0]) {
        case 'body':
          a = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              child = _ref1[_i];
              _results.push(visit(child));
            }
            return _results;
          })();
          a[a.length - 1] = 'return ' + a[a.length - 1] + ';';
          return a.join(';\n');
        case 'assign':
          name = node[1];
          setter = "set_" + name;
          if (((_ref1 = closestScope(node).vars[setter]) != null ? _ref1.type : void 0) === 'F') {
            return "ctx" + (jsProp(setter)) + "(" + (visit(node[2])) + ")";
          } else {
            return "ctx" + (jsProp(name)) + " = " + (visit(node[2]));
          }
          break;
        case 'sym':
          return "ctx" + (jsProp(node[1]));
        case 'lambda':
          depth++;
          r = "function (alpha, omega) {\n  var ctx, ctx" + depth + ";\n  ctx = ctx" + depth + " = inherit(ctx" + (depth - 1) + ");\n  ctx['⍺'] = alpha;\n  ctx['⍵'] = omega;\n  " + (visit(node[1])) + "\n}";
          depth--;
          return r;
        case 'str':
          s = node[1];
          d = s[0];
          return d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d;
        case 'num':
          s = node[1].replace(/¯/g, '-');
          a = (function() {
            var _i, _len, _ref2, _results;
            _ref2 = s.split(/j/i);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              x = _ref2[_i];
              if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          if (a.length === 1) {
            return '' + a[0];
          } else {
            return "new Complex(" + a[0] + ", " + a[1] + ")";
          }
          break;
        case 'index':
          return "ctx['⌷'](" + (visit(node[2])) + ", " + (visit(node[1])) + ")";
        case 'seq':
          return die('No "seq" nodes are expected at this stage.');
        case 'vector':
          n = node.length - 1;
          return "[" + (((function() {
            var _i, _len, _ref2, _results;
            _ref2 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              child = _ref2[_i];
              _results.push(visit(child));
            }
            return _results;
          })()).join(', ')) + "]";
        case 'niladic':
          return "" + (visit(node[1])) + "()";
        case 'monadic':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'dyadic':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ", " + (visit(node[3])) + ")";
        case 'prefixOperator':
          return 0;
        case 'infixOperator':
          return 0;
        case 'postfixOperator':
          return 0;
        default:
          return die("Unrecognised node type, '" + node[0] + "'");
      }
    };
    return "var inherit = arguments[1].inherit,\n    ctx, ctx0 = ctx = inherit(arguments[0]);\n" + (visit(ast));
  };

  closestScope = function(node) {
    while (node[0] !== 'body') {
      node = node.parent;
    }
    return node;
  };

  jsProp = function(name) {
    if (name.match(/^[a-z_][0-9a-z_]*$/i)) {
      return "." + name;
    } else {
      return "[" + (repr(name)) + "]";
    }
  };

  isArray = function(x) {
    return (x.length != null) && typeof x !== 'string';
  };

  printAST = function(x, indent) {
    var y, _i, _len, _ref1;
    if (indent == null) {
      indent = '';
    }
    if (isArray(x)) {
      if (x.length === 2 && !isArray(x[1])) {
        console.info(indent + x[0] + ' ' + JSON.stringify(x[1]));
      } else {
        console.info(indent + x[0]);
        _ref1 = x.slice(1);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          y = _ref1[_i];
          printAST(y, indent + '  ');
        }
      }
    } else {
      console.info(indent + JSON.stringify(x));
    }
  };

  (function() {
    var builtins, js, s;
    s = 'a ← 1 2 3\nb ← 4 5 6\n#⎕sleep 1000\na + b';
    console.info('-----APL SOURCE-----');
    console.info(s);
    console.info('-----AST-----');
    printAST(parse(s));
    console.info('-----COMPILED-----');
    console.info(js = compile(s));
    console.info('-----OUTPUT-----');
    builtins = require('./builtins').builtins;
    builtins['set_⎕'] = function(s) {
      return console.info(s);
    };
    builtins['⎕sleep'] = function(x, y, axis, callback) {
      setTimeout((function() {
        return callback(0);
      }), x);
    };
    return console.info((new Function(js))(builtins, helpers));
  })();

}).call(this);
