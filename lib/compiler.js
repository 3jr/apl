// Generated by CoffeeScript 1.4.0
var define,
  __slice = [].slice;

if (typeof define !== 'function') {
  define = require('amdefine')(module);
}

define(function(require) {
  var Complex, assert, assignParents, builtins, closestScope, compile, die, exec, execJS, inherit, lexer, next, parser, repr, resolveSeqs, setInput, toJavaScript, _ref, _ref1, _ref2, _ref3;
  parser = (_ref = require('./parser')) != null ? _ref : window.parser;
  builtins = require('./builtins').builtins;
  Complex = require('./complex').Complex;
  _ref1 = require('./helpers'), inherit = _ref1.inherit, die = _ref1.die, assert = _ref1.assert;
  repr = JSON.stringify;
  _ref3 = lexer = (_ref2 = parser.lexer) != null ? _ref2 : parser.parser.lexer, setInput = _ref3.setInput, next = _ref3.next;
  lexer.setInput = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.bracketStack = [];
    return setInput.call.apply(setInput, [this].concat(__slice.call(args)));
  };
  lexer.next = function() {
    var args, token;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    while (true) {
      token = next.call.apply(next, [this].concat(__slice.call(args)));
      if (token === '(' || token === '[' || token === '{') {
        this.bracketStack.push(token);
      } else if (token === ')' || token === ']' || token === '}') {
        this.bracketStack.pop();
      }
      if (token !== 'NEWLINE' || this.bracketStack.length === 0 || this.bracketStack[this.bracketStack.length - 1] === '{') {
        return token;
      }
    }
  };
  assignParents = function(node) {
    var child, _i, _len, _ref4;
    _ref4 = node.slice(1);
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      child = _ref4[_i];
      if (!(child)) {
        continue;
      }
      assignParents(child);
      child.parent = node;
    }
  };
  resolveSeqs = function(ast) {
    var h, k, m, node, queue, scopeCounter, scopeNode, v, vars, visit, _i, _len, _ref4;
    ast.vars = {
      '⍺': {
        type: 'X',
        code: '_a'
      },
      '⍵': {
        type: 'X',
        code: '_w'
      },
      '∇': {
        type: 'F',
        code: 'arguments.callee'
      }
    };
    for (k in builtins) {
      v = builtins[k];
      ast.vars[k] = h = {
        type: 'X',
        code: "_[" + (JSON.stringify(k)) + "]"
      };
      if (typeof v === 'function') {
        h.type = 'F';
        if ((m = v.aplMetaInfo) != null) {
          if (m.isPrefixOperator) {
            h.isPrefixOperator = true;
          }
          if (m.isPostfixOperator) {
            h.isPostfixOperator = true;
          }
          if (m.isInfixOperator) {
            h.isInfixOperator = true;
          }
        }
        if (/^[gs]et_.*/.test(k)) {
          ast.vars[k.slice(4)] = {
            type: 'X'
          };
        }
      }
    }
    scopeCounter = 0;
    ast.scopeId = scopeCounter++;
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      visit = function(node) {
        var a, c, child, i, j, name, t, t1, _i, _j, _len, _len1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            node.scopeId = scopeCounter++;
            queue.push(node);
            return null;
          case 'guard':
            visit(node[1]);
            return visit(node[2]);
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              assert(vars[name].type === h.type, ("Inconsistent usage of symbol '" + name + "', it is ") + "assigned both data and functions");
            } else {
              vars[name] = {
                type: h.type,
                code: "_" + scopeNode.scopeId + "[" + (JSON.stringify(name)) + "]"
              };
            }
            return h;
          case 'sym':
            name = node[1];
            if (((_ref4 = (v = vars["get_" + name])) != null ? _ref4.type : void 0) === 'F') {
              v.used = true;
              return {
                type: 'X'
              };
            } else {
              v = vars[name];
              assert(v, "Symbol '" + name + "' referenced before assignment");
              v.used = true;
              return v;
            }
            break;
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            _ref5 = node.slice(2);
            for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
              c = _ref5[_i];
              if (!(c !== null)) {
                continue;
              }
              t = visit(c);
              assert(t.type === 'X', 'Only data can be used as an index');
            }
            return t1;
          case 'seq':
            a = node.slice(1);
            a.reverse();
            h = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
                child = a[_j];
                _results.push(visit(child));
              }
              return _results;
            })();
            h.reverse();
            a.reverse();
            i = 0;
            while (i < a.length - 1) {
              if ((h[i].type === (_ref6 = h[i + 1].type) && _ref6 === 'X')) {
                j = i + 2;
                while (j < a.length && h[j].type === 'X') {
                  j++;
                }
                [].splice.apply(a, [i, j - i].concat(_ref7 = [['vector'].concat(a.slice(i, j))])), _ref7;
                [].splice.apply(h, [i, j - i].concat(_ref8 = [
                  {
                    type: 'X'
                  }
                ])), _ref8;
              } else {
                i++;
              }
            }
            i = a.length - 2;
            while (--i >= 0) {
              if (h[i + 1].isInfixOperator && (h[i].type === 'F' || h[i + 2].type === 'F')) {
                [].splice.apply(a, [i, (i + 3) - i].concat(_ref9 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref9;
                [].splice.apply(h, [i, (i + 3) - i].concat(_ref10 = [
                  {
                    type: 'F'
                  }
                ])), _ref10;
                i--;
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref11 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref11;
                [].splice.apply(h, [i, (i + 2) - i].concat(_ref12 = [
                  {
                    type: 'F'
                  }
                ])), _ref12;
              } else {
                i++;
              }
            }
            i = a.length - 1;
            while (--i >= 0) {
              if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref13 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref13;
                [].splice.apply(h, [i, (i + 2) - i].concat(_ref14 = [
                  {
                    type: 'F'
                  }
                ])), _ref14;
              }
            }
            if (h.length === 2 && (h[0].type === (_ref15 = h[1].type) && _ref15 === 'F')) {
              a = [['hook'].concat(a)];
              h = [
                {
                  type: 'F'
                }
              ];
            }
            if (h.length === 3 && ((h[0].type === (_ref17 = h[1].type) && _ref17 === (_ref16 = h[2].type)) && _ref16 === 'F')) {
              a = [['fork'].concat(a)];
              h = [
                {
                  type: 'F'
                }
              ];
            }
            if (h[h.length - 1].type === 'F') {
              assert(h.length <= 1, 'Trailing function in expression');
            } else {
              while (h.length > 1) {
                if (h.length === 2 || h[h.length - 3].type === 'F') {
                  [].splice.apply(a, [(_ref18 = h.length - 2), 9e9].concat(_ref19 = [['monadic'].concat(a.slice(h.length - 2))])), _ref19;
                  [].splice.apply(h, [(_ref20 = h.length - 2), 9e9].concat(_ref21 = [
                    {
                      type: 'X'
                    }
                  ])), _ref21;
                } else {
                  [].splice.apply(a, [(_ref22 = h.length - 3), 9e9].concat(_ref23 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref23;
                  [].splice.apply(h, [(_ref24 = h.length - 3), 9e9].concat(_ref25 = [
                    {
                      type: 'X'
                    }
                  ])), _ref25;
                }
              }
            }
            [].splice.apply(node, [0, 9e9].concat(_ref26 = a[0])), _ref26;
            a[0].parent = null;
            _ref27 = node.slice(1);
            for (_j = 0, _len1 = _ref27.length; _j < _len1; _j++) {
              c = _ref27[_j];
              if (c) {
                c.parent = node;
              }
            }
            return h[0];
          default:
            return die("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref4 = scopeNode.slice(1);
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        node = _ref4[_i];
        visit(node);
      }
    }
  };
  toJavaScript = function(ast) {
    var visit;
    visit = function(node) {
      var a, c, child, d, i, n, name, s, v, vars, x, _i, _len, _ref4, _ref5, _ref6;
      switch (node[0]) {
        case 'body':
          if (node.length === 1) {
            return 'return [];\n';
          } else {
            a = ["var _" + node.scopeId + " = {};\n"];
            _ref4 = node.slice(1);
            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
              child = _ref4[_i];
              a.push(visit(child));
            }
            a[a.length - 1] = "return " + a[a.length - 1] + ";\n";
            return a.join(';\n');
          }
          break;
        case 'guard':
          return "if (_.bool(" + (visit(node[1])) + ")) {\n  return " + (visit(node[2])) + ";\n}";
        case 'assign':
          name = node[1];
          assert(name !== '∇', 'Assignment to ∇ is not allowed.');
          vars = closestScope(node).vars;
          if (((_ref5 = (v = vars["set_" + name])) != null ? _ref5.type : void 0) === 'F') {
            v.used = true;
            return "" + v.code + "(" + (visit(node[2])) + ")";
          } else {
            return "" + vars[name].code + " = " + (visit(node[2]));
          }
          break;
        case 'sym':
          name = node[1];
          vars = closestScope(node).vars;
          if (((_ref6 = (v = vars["get_" + name])) != null ? _ref6.type : void 0) === 'F') {
            v.used = true;
            return "" + v.code + "()";
          } else {
            v = vars[name];
            v.used = true;
            return v.code;
          }
          break;
        case 'lambda':
          return "function (_w, _a) {\n  " + (visit(node[1])) + "\n}";
        case 'str':
          s = node[1];
          d = s[0];
          return "_.aplify(" + (d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d) + ")";
        case 'num':
          s = node[1].replace(/¯/g, '-');
          a = (function() {
            var _j, _len1, _ref7, _results;
            _ref7 = s.split(/j/i);
            _results = [];
            for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
              x = _ref7[_j];
              if (x === '-') {
                _results.push('Infinity');
              } else if (x === '--') {
                _results.push('-Infinity');
              } else if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          if (a.length === 1 || a[1] === 0) {
            return '' + a[0];
          } else {
            return "new _.Complex(" + a[0] + ", " + a[1] + ")";
          }
          break;
        case 'index':
          return "_['⌷'](" + (visit(node[1])) + ", [" + (((function() {
            var _j, _len1, _ref7, _results;
            _ref7 = node.slice(2);
            _results = [];
            for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
              c = _ref7[_j];
              if (c !== null) {
                _results.push(visit(c));
              }
            }
            return _results;
          })()).join(', ')) + "], [" + ((function() {
            var _j, _len1, _ref7, _results;
            _ref7 = node.slice(2);
            _results = [];
            for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
              c = _ref7[i];
              if (c !== null) {
                _results.push(i);
              }
            }
            return _results;
          })()) + "])";
        case 'seq':
          return die('No "seq" nodes are expected at this stage.');
        case 'vector':
          n = node.length - 1;
          return "[" + (((function() {
            var _j, _len1, _ref7, _results;
            _ref7 = node.slice(1);
            _results = [];
            for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
              child = _ref7[_j];
              _results.push(visit(child));
            }
            return _results;
          })()).join(', ')) + "]";
        case 'monadic':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'dyadic':
          return "" + (visit(node[2])) + "(" + (visit(node[3])) + ", " + (visit(node[1])) + ")";
        case 'prefixOperator':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'infixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[3])) + ", " + (visit(node[1])) + ")";
        case 'postfixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ")";
        case 'hook':
          return "_.hook(" + (visit(node[2])) + ", " + (visit(node[1])) + ")";
        case 'fork':
          return "_.fork(" + (visit(node[3])) + ", " + (visit(node[2])) + ", " + (visit(node[1])) + ")";
        case 'embedded':
          return "_.aplify(" + (node[1].replace(/(^«|»$)/g, '')) + ")";
        default:
          return die("Unrecognised node type, '" + node[0] + "'");
      }
    };
    return "var _ = arguments[0];\n" + (visit(ast));
  };
  closestScope = function(node) {
    while (node[0] !== 'body') {
      node = node.parent;
    }
    return node;
  };
  exec = function(aplSource, opts) {
    if (opts == null) {
      opts = {};
    }
    return execJS(compile(aplSource, opts).jsOutput, opts);
  };
  execJS = function(jsSource, opts) {
    var h, k, v, _ref4;
    if (opts == null) {
      opts = {};
    }
    h = inherit(builtins, {
      Complex: Complex
    });
    if (opts.extraContext) {
      _ref4 = opts.extraContext;
      for (k in _ref4) {
        v = _ref4[k];
        h[k] = v;
      }
    }
    return (new Function(jsSource))(h);
  };
  compile = function(aplSource, opts) {
    var ast, jsOutput;
    if (opts == null) {
      opts = {};
    }
    ast = parser.parse(aplSource);
    assignParents(ast);
    resolveSeqs(ast);
    jsOutput = toJavaScript(ast);
    return {
      ast: ast,
      jsOutput: jsOutput
    };
  };
  return {
    exec: exec,
    execJS: execJS,
    compile: compile
  };
});
