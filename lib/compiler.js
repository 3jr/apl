// Generated by CoffeeScript 1.3.3
(function() {
  var assert, assignParents, builtinVarInfo, builtins, closestScope, compile, die, helpers, hex4, inherit, isArray, jsName, ord, parse, predefinedNames, printAST, repr, resolveSeqs, toJavaScript, _ref;

  parse = require('../lib/parser').parse;

  _ref = helpers = require('./helpers'), inherit = _ref.inherit, die = _ref.die, assert = _ref.assert;

  repr = JSON.stringify;

  predefinedNames = {
    '⍺': '_a',
    '⍵': '_w',
    '+': '_add',
    '-': '_sub',
    '×': '_mul',
    '÷': '_div',
    '!': '_bang',
    '?': '_ques',
    '⌷': '_idx',
    '⍴': '_r',
    '⍳': '_i',
    ',': '_cat',
    '⍪': '_cat1',
    '⎕': '_q',
    '⍞': '_qq',
    '∈': '_e',
    '⍷': '_eu',
    '∼': '_tilde',
    '↑': '_take',
    '↓': '_drop',
    '⍉': '_trans',
    '⊖': '_rot1',
    '⌽': '_rot',
    '○': '_circ',
    '⍬': '_zilde',
    '⋆': '_pow',
    '⌈': '_max',
    '⌊': '_min',
    '∘.': '_outer',
    '.': '_inner',
    '∣': '_mod',
    '⊤': '_tee',
    '⊥': '_bot',
    '∪': '_cup',
    '∩': '_cap',
    '⊂': '_enclose',
    '⊃': '_disclose',
    '⍒': '_gradeUp',
    '⍋': '_gradeDown',
    '⍣': '_powOp',
    '¨': '_each',
    '\\': '_bslash',
    '/': '_slash'
  };

  ord = function(s) {
    return s.charCodeAt(0);
  };

  hex4 = function(n) {
    var s;
    s = '0000' + n.toString(16);
    return s.slice(s.length - 4);
  };

  jsName = function(name) {
    return predefinedNames[name] || name.replace(/[^a-z0-9]/gi, function(x) {
      return '_' + hex4(ord(x));
    });
  };

  builtins = inherit(require('./builtins').builtins);

  builtins['set_⎕'] = function(s) {
    return console.info(s);
  };

  builtinVarInfo = {
    '+': {
      type: 'F'
    },
    '−': {
      type: 'F'
    },
    '×': {
      type: 'F'
    },
    '÷': {
      type: 'F'
    },
    ',': {
      type: 'F'
    },
    '⍪': {
      type: 'F'
    },
    '⍴': {
      type: 'F'
    },
    '/': {
      type: 'F',
      isPostfixOperator: true
    },
    '⍣': {
      type: 'F',
      isInfixOperator: true
    },
    '⍺': {
      type: 'X'
    },
    '⍵': {
      type: 'X'
    },
    '⍬': {
      type: 'X',
      isNiladicFunction: true
    },
    '⎕': {
      type: 'X',
      isNiladicFunction: true
    },
    'set_⎕': {
      type: 'F'
    }
  };

  compile = function(source, opts) {
    var ast, output;
    if (opts == null) {
      opts = {};
    }
    console.info('DEBUG: ' + opts.debug);
    if (opts.debug) {
      console.info('-----APL SOURCE-----\n' + source);
    }
    ast = parse(source);
    if (opts.debug) {
      console.info('-----RAW AST-----\n');
      printAST(ast);
    }
    assignParents(ast);
    resolveSeqs(ast);
    if (opts.debug) {
      console.info('-----AST-----\n');
      printAST(ast);
    }
    output = toJavaScript(ast);
    if (opts.debug) {
      console.info('-----JS OUTPUT-----\n' + output);
    }
    return output;
  };

  assignParents = function(node) {
    var child, _i, _len, _ref1;
    _ref1 = node.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      assignParents(child);
      child.parent = node;
    }
  };

  resolveSeqs = function(ast) {
    var node, queue, scopeNode, vars, visit, _i, _len, _ref1;
    ast.vars = inherit(builtinVarInfo);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      scopeNode.varsToDeclare = [];
      visit = function(node) {
        var a, child, h, i, j, name, t1, t2, _i, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            queue.push(node);
            return null;
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              assert(vars[name].type === h.type, "Inconsistent usage of symbol '" + name + "', it is assigned both data and functions");
            } else {
              vars[name] = h;
              scopeNode.varsToDeclare.push(name);
            }
            return h;
          case 'sym':
            name = node[1];
            assert(vars[name] != null, "Symbol '" + name + "' referenced before assignment");
            return vars[name];
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            t2 = visit(node[2]);
            assert(t2.type === 'X', 'Only data can be used as an index');
            return t1;
          case 'seq':
            if (node.length === 1) {
              return {
                type: 'X'
              };
            } else {
              a = node.slice(1);
              h = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = a.length; _i < _len; _i++) {
                  child = a[_i];
                  _results.push(visit(child));
                }
                return _results;
              })();
              for (i = _i = 0, _ref1 = a.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                if (h[i].isNiladicFunction) {
                  a[i] = ['niladic', a[i]];
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if ((h[i].type === (_ref2 = h[i + 1].type) && _ref2 === 'X')) {
                  j = i + 2;
                  while (j < a.length && h[j].type === 'X') {
                    j++;
                  }
                  [].splice.apply(a, [i, j - i].concat(_ref3 = [['vector'].concat(a.slice(i, j))])), _ref3;
                  [].splice.apply(h, [i, j - i].concat(_ref4 = [
                    {
                      type: 'X'
                    }
                  ])), _ref4;
                } else {
                  i++;
                }
              }
              i = a.length - 2;
              while (--i >= 0) {
                if ((h[i].type === (_ref5 = h[i + 2].type) && _ref5 === 'F') && h[i + 1].isInfixOperator && h[i + 2].type === 'F') {
                  [].splice.apply(a, [i, (i + 3) - i].concat(_ref6 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref6;
                  [].splice.apply(h, [i, (i + 3) - i].concat(_ref7 = [
                    {
                      type: 'F'
                    }
                  ])), _ref7;
                  i--;
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref8 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref8;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref9 = [
                    {
                      type: 'F'
                    }
                  ])), _ref9;
                } else {
                  i++;
                }
              }
              i = a.length - 1;
              while (--i >= 0) {
                if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref10 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref10;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref11 = [
                    {
                      type: 'F'
                    }
                  ])), _ref11;
                }
              }
              if (h[h.length - 1].type === 'F') {
                assert(h.length <= 1, 'Trailing function in expression');
              } else {
                while (h.length > 1) {
                  if (h.length === 2 || h[h.length - 3].type === 'F') {
                    [].splice.apply(a, [(_ref12 = h.length - 2), 9e9].concat(_ref13 = [['monadic'].concat(a.slice(h.length - 2))])), _ref13;
                    [].splice.apply(h, [(_ref14 = h.length - 2), 9e9].concat(_ref15 = [
                      {
                        type: 'X'
                      }
                    ])), _ref15;
                  } else {
                    [].splice.apply(a, [(_ref16 = h.length - 3), 9e9].concat(_ref17 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref17;
                    [].splice.apply(h, [(_ref18 = h.length - 3), 9e9].concat(_ref19 = [
                      {
                        type: 'X'
                      }
                    ])), _ref19;
                  }
                }
              }
              [].splice.apply(node, [0, 9e9].concat(_ref20 = a[0])), _ref20;
              a[0][0] = 'IDIOT';
              a[0].parent = null;
              return h[0];
            }
            break;
          default:
            return die("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref1 = scopeNode.slice(1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        visit(node);
      }
    }
  };

  toJavaScript = function(ast) {
    var k, visit;
    visit = function(node) {
      var a, child, d, n, name, r, s, setter, x, _ref1;
      switch (node[0]) {
        case 'body':
          r = '';
          if (node.varsToDeclare.length) {
            r += 'var ' + node.varsToDeclare.join(', ') + ';\n';
          }
          a = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              child = _ref1[_i];
              _results.push(visit(child));
            }
            return _results;
          })();
          a[a.length - 1] = 'return ' + a[a.length - 1] + ';';
          return r += a.join(';\n');
        case 'assign':
          name = node[1];
          setter = "set_" + name;
          if (((_ref1 = closestScope(node).vars[setter]) != null ? _ref1.type : void 0) === 'F') {
            return "" + (jsName(setter)) + "(" + (visit(node[2])) + ")";
          } else {
            return "" + (jsName(name)) + " = " + (visit(node[2]));
          }
          break;
        case 'sym':
          return "" + (jsName(node[1]));
        case 'lambda':
          return "function (_a, _w) {\n  " + (visit(node[1])) + "\n}";
        case 'str':
          s = node[1];
          d = s[0];
          return d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d;
        case 'num':
          s = node[1].replace(/¯/g, '-');
          a = (function() {
            var _i, _len, _ref2, _results;
            _ref2 = s.split(/j/i);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              x = _ref2[_i];
              if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          if (a.length === 1) {
            return '' + a[0];
          } else {
            return "new Complex(" + a[0] + ", " + a[1] + ")";
          }
          break;
        case 'index':
          return "_index(" + (visit(node[2])) + ", " + (visit(node[1])) + ")";
        case 'seq':
          return die('No "seq" nodes are expected at this stage.');
        case 'vector':
          n = node.length - 1;
          return "[" + (((function() {
            var _i, _len, _ref2, _results;
            _ref2 = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              child = _ref2[_i];
              _results.push(visit(child));
            }
            return _results;
          })()).join(', ')) + "]";
        case 'niladic':
          return "" + (visit(node[1])) + "()";
        case 'monadic':
          return "" + (visit(node[1])) + "(undefined, " + (visit(node[2])) + ")";
        case 'dyadic':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ", " + (visit(node[3])) + ")";
        case 'prefixOperator':
          return "" + (visit(node[1])) + "(undefined, " + (visit(node[2])) + ")";
        case 'infixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ", " + (visit(node[3])) + ")";
        case 'postfixOperator':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ")";
        default:
          return die("Unrecognised node type, '" + node[0] + "'");
      }
    };
    return "var _apl = arguments[0],\n" + (((function() {
      var _results;
      _results = [];
      for (k in builtins) {
        _results.push("" + (jsName(k)) + " = _apl[" + (repr(k)) + "]");
      }
      return _results;
    })()).join(',\n    ')) + ";\n" + (visit(ast));
  };

  closestScope = function(node) {
    while (node[0] !== 'body') {
      node = node.parent;
    }
    return node;
  };

  isArray = function(x) {
    return (x.length != null) && typeof x !== 'string';
  };

  printAST = function(x, indent) {
    var y, _i, _len, _ref1;
    if (indent == null) {
      indent = '';
    }
    if (isArray(x)) {
      if (x.length === 2 && !isArray(x[1])) {
        console.info(indent + x[0] + ' ' + JSON.stringify(x[1]));
      } else {
        console.info(indent + x[0]);
        _ref1 = x.slice(1);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          y = _ref1[_i];
          printAST(y, indent + '  ');
        }
      }
    } else {
      console.info(indent + JSON.stringify(x));
    }
  };

  console.info('hello');

  (function() {
    var js, s;
    console.info('hallo');
    s = 'f ← {(⍵,(⍴⍵)⍴0)⍪⍵,⍵}\nS ← {\' #\'[(f⍣⍵) 1 1 ⍴ 1]}\n⎕ ← f f 1 1 ⍴ 1';
    js = compile(s, {
      debug: true
    });
    return (new Function(js))(builtins);
  })();

}).call(this);
