// Generated by CoffeeScript 1.3.3
(function() {
  var compile, firstPass, globalVarInfo, inherit, isArray, jsProp, parse, printAST, repr, secondPass;

  parse = require('../lib/parser').parse;

  inherit = require('./helpers').inherit;

  repr = JSON.stringify;

  globalVarInfo = {
    '+': {
      type: 'F'
    },
    '/': {
      type: 'F',
      isPostfixOperator: true
    },
    '⍣': {
      type: 'F',
      isInfixOperator: true
    },
    '⍺': {
      type: 'X'
    },
    '⍵': {
      type: 'X'
    },
    '⍬': {
      type: 'X',
      isNiladicFunction: true
    },
    '⎕': {
      type: 'X',
      isNiladicFunction: true
    }
  };

  compile = function(source) {
    var ast;
    ast = parse(source);
    firstPass(ast);
    printAST(ast);
    return secondPass(ast);
  };

  firstPass = function(ast) {
    var node, queue, scopeNode, vars, visit, _i, _len, _ref;
    ast.vars = inherit(globalVarInfo);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      visit = function(node) {
        var a, child, h, i, j, name, t1, t2, _i, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        switch (node[0]) {
          case 'body':
            node.vars = inherit(vars);
            queue.push(node);
            return null;
          case 'assign':
            name = node[1];
            h = visit(node[2]);
            if (vars[name]) {
              if (vars[name].type !== h.type) {
                throw Error("Inconsistent usage of symbol '" + name + "'");
              }
            } else {
              vars[name] = h;
            }
            return h;
          case 'sym':
            name = node[1];
            if (!(vars[name] != null)) {
              throw Error("Symbol '" + name + "' referenced before assignment");
            }
            return vars[name];
          case 'lambda':
            visit(node[1]);
            return {
              type: 'F'
            };
          case 'str':
          case 'num':
          case 'embedded':
            return {
              type: 'X'
            };
          case 'index':
            t1 = visit(node[1]);
            t2 = visit(node[2]);
            if (t2.type !== 'X') {
              throw Error('Only data can be used as an index');
            }
            return t1;
          case 'seq':
            if (node.length === 1) {
              return {
                type: 'X'
              };
            } else {
              a = node.slice(1);
              h = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = a.length; _i < _len; _i++) {
                  child = a[_i];
                  _results.push(visit(child));
                }
                return _results;
              })();
              for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (h[i].isNiladicFunction) {
                  a[i] = ['niladic', a[i]];
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if ((h[i].type === (_ref1 = h[i + 1].type) && _ref1 === 'X')) {
                  j = i + 2;
                  while (j < a.length && h[j].type === 'X') {
                    j++;
                  }
                  [].splice.apply(a, [i, j - i].concat(_ref2 = [['vector'].concat(a.slice(i, j))])), _ref2;
                  [].splice.apply(h, [i, j - i].concat(_ref3 = [
                    {
                      type: 'X'
                    }
                  ])), _ref3;
                } else {
                  i++;
                }
              }
              i = a.length - 2;
              while (--i >= 0) {
                if ((h[i].type === (_ref4 = h[i + 2].type) && _ref4 === 'F') && h[i + 1].isInfixOperator && h[i + 2].type === 'F') {
                  [].splice.apply(a, [i, (i + 3) - i].concat(_ref5 = [['infixOperator'].concat(a.slice(i, i + 3))])), _ref5;
                  [].splice.apply(h, [i, (i + 3) - i].concat(_ref6 = [
                    {
                      type: 'F'
                    }
                  ])), _ref6;
                  i--;
                }
              }
              i = 0;
              while (i < a.length - 1) {
                if (h[i].type === 'F' && h[i + 1].isPostfixOperator) {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref7 = [['postfixOperator'].concat(a.slice(i, i + 2))])), _ref7;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref8 = [
                    {
                      type: 'F'
                    }
                  ])), _ref8;
                } else {
                  i++;
                }
              }
              i = a.length - 1;
              while (--i >= 0) {
                if (h[i].isPrefixOperator && h[i + 1].type === 'F') {
                  [].splice.apply(a, [i, (i + 2) - i].concat(_ref9 = [['prefixOperator'].concat(a.slice(i, i + 2))])), _ref9;
                  [].splice.apply(h, [i, (i + 2) - i].concat(_ref10 = [
                    {
                      type: 'F'
                    }
                  ])), _ref10;
                }
              }
              if (h[h.length - 1].type === 'F') {
                if (h.length > 1) {
                  throw Error('Trailing function in expression');
                }
              } else {
                while (h.length > 1) {
                  if (h.length === 2 || h[h.length - 3].type === 'F') {
                    [].splice.apply(a, [(_ref11 = h.length - 2), 9e9].concat(_ref12 = [['monadic'].concat(a.slice(h.length - 2))])), _ref12;
                    [].splice.apply(h, [(_ref13 = h.length - 2), 9e9].concat(_ref14 = [
                      {
                        type: 'X'
                      }
                    ])), _ref14;
                  } else {
                    [].splice.apply(a, [(_ref15 = h.length - 3), 9e9].concat(_ref16 = [['dyadic'].concat(a.slice(h.length - 3))])), _ref16;
                    [].splice.apply(h, [(_ref17 = h.length - 3), 9e9].concat(_ref18 = [
                      {
                        type: 'X'
                      }
                    ])), _ref18;
                  }
                }
              }
              node.seqTree = a[0];
              return h[0];
            }
            break;
          default:
            throw Error("Unrecognised node type, '" + node[0] + "'");
        }
      };
      _ref = scopeNode.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        visit(node);
      }
    }
  };

  secondPass = function(ast) {
    var visit;
    visit = function(node) {
      var a, child, d, n, s, x;
      switch (node[0]) {
        case 'body':
          a = (function() {
            var _i, _len, _ref, _results;
            _ref = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              _results.push(visit(child));
            }
            return _results;
          })();
          a[a.length - 1] = 'return ' + a[a.length - 1];
          return a.join(';\n');
        case 'assign':
          return "ctx" + (jsProp(node[1])) + " = " + (visit(node[2]));
        case 'sym':
          return "ctx" + (jsProp(node[1]));
        case 'lambda':
          return "function (alpha, omega) {\n  var ctx = inherit(ctx);\n  ctx['⍺'] = alpha;\n  ctx['⍵'] = omega;\n  " + (visit(node[1])) + "\n}";
        case 'str':
          s = node[1];
          d = s[0];
          return d + s.slice(1, -1).replace(RegExp("" + (d + d), "g"), '\\' + d) + d;
        case 'num':
          s = node[1].replace(/¯/g, '-');
          a = (function() {
            var _i, _len, _ref, _results;
            _ref = s.split(/j/i);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              x = _ref[_i];
              if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          if (a.length === 1) {
            return '' + a[0];
          } else {
            return "new Complex(" + a[0] + ", " + a[1] + ")";
          }
          break;
        case 'index':
          return "ctx['⌷'](" + (visit(node[2])) + ", " + (visit(node[1])) + ")";
        case 'seq':
          return visit(node.seqTree);
        case 'vector':
          n = node.length - 1;
          return "[" + (((function() {
            var _i, _len, _ref, _results;
            _ref = node.slice(1);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              _results.push(visit(child));
            }
            return _results;
          })()).join(', ')) + "]";
        case 'niladic':
          return "" + (visit(node[1])) + "()";
        case 'monadic':
          return "" + (visit(node[1])) + "(" + (visit(node[2])) + ")";
        case 'dyadic':
          return "" + (visit(node[2])) + "(" + (visit(node[1])) + ", " + (visit(node[3])) + ")";
        case 'prefixOperator':
          return 0;
        case 'infixOperator':
          return 0;
        case 'postfixOperator':
          return 0;
        default:
          throw Error("Unrecognised node type, '" + node[0] + "'");
      }
    };
    return "(function () {\n  var ctx = inherit(builtInContext);\n  " + (visit(ast)) + "\n})();";
  };

  jsProp = function(name) {
    if (name.match(/^[a-z_][0-9a-z_]*$/i)) {
      return "." + name;
    } else {
      return "[" + (repr(name)) + "]";
    }
  };

  isArray = function(x) {
    return (x.length != null) && typeof x !== 'string';
  };

  printAST = function(x, indent) {
    var y, _i, _len, _ref;
    if (indent == null) {
      indent = '';
    }
    if (isArray(x)) {
      x = x.seqTree || x;
      if (x.length === 2 && !isArray(x[1])) {
        console.info(indent + x[0] + ' ' + JSON.stringify(x[1]));
      } else {
        console.info(indent + x[0]);
        _ref = x.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          y = _ref[_i];
          printAST(y, indent + '  ');
        }
      }
    } else {
      console.info(indent + JSON.stringify(x));
    }
  };

  console.info(compile('a ← ⎕\n⎕ ← a'));

}).call(this);
