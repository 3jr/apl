// Generated by CoffeeScript 1.3.3
var define,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

if (typeof define !== 'function') {
  define = require('amdefine')(module);
}

define(['./helpers'], function(helpers) {
  var Gamma, PI, abs, acos, ambivalent, array, asin, assert, atan, bool, builtins, catenate, ceil, compressOrReplicate, contains, cos, def, depthOf, die, dyadic, endOfBuiltins, exp, expand, floor, grade, infixOperator, inherit, isSimple, log, match, max, maybeMakePervasive, min, monadic, num, outerProduct, overloadable, pervasive, postfixOperator, pow, prefixOperator, prod, prototypeOf, random, reduce, reverse, round, scan, shapeOf, sin, sqrt, tan, tmp, withMetaInfoFrom, withPrototype, withPrototypeCopiedFrom, withShape;
  assert = helpers.assert, die = helpers.die, inherit = helpers.inherit, isSimple = helpers.isSimple, shapeOf = helpers.shapeOf, withShape = helpers.withShape, prod = helpers.prod, prototypeOf = helpers.prototypeOf, withPrototype = helpers.withPrototype, withPrototypeCopiedFrom = helpers.withPrototypeCopiedFrom;
  min = Math.min, max = Math.max, floor = Math.floor, ceil = Math.ceil, round = Math.round, abs = Math.abs, random = Math.random, exp = Math.exp, pow = Math.pow, log = Math.log, PI = Math.PI, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, acos = Math.acos, atan = Math.atan;
  array = function(x) {
    if (isSimple(x)) {
      return [x];
    } else {
      return x;
    }
  };
  num = function(x) {
    if (x.length != null) {
      assert(x.length === 1, 'Numeric scalar or singleton expected');
      x = x[0];
    }
    assert(typeof x === 'number', 'Numeric scalar or singleton expected');
    return x;
  };
  bool = function(x) {
    x = num(x);
    assert(x === 0 || x === 1, 'Boolean values must be either 0 or 1');
    return x;
  };
  builtins = {};
  tmp = {
    monadic: {},
    dyadic: {}
  };
  def = function(h, name, description, f) {
    assert(typeof name === 'string');
    assert(typeof description === 'string');
    if (f == null) {
      f = function() {
        return die("Function " + name + " " + description + " is not implemented.");
      };
    }
    assert(typeof f === 'function');
    assert(!(h[name] != null), "Redefinition of function " + name + " " + description);
    return h[name] = f;
  };
  monadic = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return def.apply(null, [tmp.monadic].concat(__slice.call(a)));
  };
  dyadic = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return def.apply(null, [tmp.dyadic].concat(__slice.call(a)));
  };
  prefixOperator = function() {
    var a, _base, _ref;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ((_ref = (_base = def.apply(null, [tmp.monadic].concat(__slice.call(a)))).aplMetaInfo) != null ? _ref : _base.aplMetaInfo = {}).isPrefixOperator = true;
  };
  postfixOperator = function() {
    var a, _base, _ref;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ((_ref = (_base = def.apply(null, [tmp.monadic].concat(__slice.call(a)))).aplMetaInfo) != null ? _ref : _base.aplMetaInfo = {}).isPostfixOperator = true;
  };
  infixOperator = function() {
    var a, _base, _ref;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ((_ref = (_base = def.apply(null, [tmp.dyadic].concat(__slice.call(a)))).aplMetaInfo) != null ? _ref : _base.aplMetaInfo = {}).isInfixOperator = true;
  };
  withMetaInfoFrom = function(f, g) {
    assert(typeof f === 'function');
    assert(typeof g === 'function');
    g.aplMetaInfo = f.aplMetaInfo ? inherit(f.aplMetaInfo) : {};
    return g;
  };
  overloadable = function(symbol, f) {
    assert(typeof symbol === 'string');
    assert(typeof f === 'function');
    return withMetaInfoFrom(f, function() {
      var a, args, b;
      b = arguments[0], a = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (typeof (b != null ? b[symbol] : void 0) === 'function') {
        return b[symbol].apply(b, [a].concat(__slice.call(args)));
      } else if (typeof (a != null ? a[symbol] : void 0) === 'function') {
        return a[symbol].apply(a, [b].concat(__slice.call(args)));
      } else {
        return f.apply(null, [b, a].concat(__slice.call(args)));
      }
    });
  };
  ambivalent = function(symbol, f1, f2) {
    var F;
    assert(typeof symbol === 'string');
    if (!(f1 && f2)) {
      return f1 || f2;
    }
    assert(typeof f1 === 'function');
    assert(typeof f2 === 'function');
    return F = function() {
      var a, args, b;
      b = arguments[0], a = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (a != null) {
        return f2.apply(null, [b, a].concat(__slice.call(args)));
      } else {
        return f1.apply(null, [b, a].concat(__slice.call(args)));
      }
    };
  };
  endOfBuiltins = function() {
    var f1, f2, k, ks, _i, _len;
    ks = ((function() {
      var _results;
      _results = [];
      for (k in tmp.monadic) {
        _results.push(k);
      }
      return _results;
    })()).concat((function() {
      var _results;
      _results = [];
      for (k in tmp.dyadic) {
        if (!(tmp.monadic[k] != null)) {
          _results.push(k);
        }
      }
      return _results;
    })());
    for (_i = 0, _len = ks.length; _i < _len; _i++) {
      k = ks[_i];
      f1 = tmp.monadic[k];
      if (f1 != null) {
        f1 = overloadable(k, f1);
        f1 = maybeMakePervasive(f1);
      }
      f2 = tmp.dyadic[k];
      if (f2 != null) {
        f2 = overloadable(k, f2);
        f2 = maybeMakePervasive(f2);
      }
      builtins[k] = ambivalent(k, f1, f2);
    }
    return tmp = null;
  };
  pervasive = function(f) {
    var _ref;
    assert(typeof f === 'function');
    ((_ref = f.aplMetaInfo) != null ? _ref : f.aplMetaInfo = {}).isPervasive = true;
    return f;
  };
  maybeMakePervasive = function(f) {
    var F, _ref;
    assert(typeof f === 'function');
    if (!((_ref = f.aplMetaInfo) != null ? _ref.isPervasive : void 0)) {
      return f;
    } else {
      return withMetaInfoFrom(f, (F = function(b, a) {
        var i, k, sa, sb, x, _i, _ref1;
        if (a != null) {
          if (isSimple(b) && isSimple(a)) {
            return f(b, a);
          } else if (isSimple(a)) {
            return withShape(b.shape, (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = b.length; _i < _len; _i++) {
                x = b[_i];
                _results.push(F(x, a));
              }
              return _results;
            })());
          } else if (isSimple(b)) {
            return withShape(a.shape, (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = a.length; _i < _len; _i++) {
                x = a[_i];
                _results.push(F(b, x));
              }
              return _results;
            })());
          } else {
            sa = shapeOf(a);
            sb = shapeOf(b);
            for (i = _i = 0, _ref1 = min(sa.length, sb.length); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
              assert(sa[i] === sb[i], 'Length error');
            }
            if (sa.length > sb.length) {
              k = prod(sa.slice(sb.length));
              return withShape(sa, (function() {
                var _j, _ref2, _results;
                _results = [];
                for (i = _j = 0, _ref2 = a.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  _results.push(F(b[floor(i / k)], a[i]));
                }
                return _results;
              })());
            } else if (sa.length < sb.length) {
              k = prod(sb.slice(sa.length));
              return withShape(sb, (function() {
                var _j, _ref2, _results;
                _results = [];
                for (i = _j = 0, _ref2 = b.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  _results.push(F(b[i], a[floor(i / k)]));
                }
                return _results;
              })());
            } else {
              return withShape(sa, (function() {
                var _j, _ref2, _results;
                _results = [];
                for (i = _j = 0, _ref2 = a.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  _results.push(F(b[i], a[i]));
                }
                return _results;
              })());
            }
          }
        } else {
          if (isSimple(b)) {
            return f(b);
          } else {
            return withShape(b.shape, (function() {
              var _j, _len, _results;
              _results = [];
              for (_j = 0, _len = b.length; _j < _len; _j++) {
                x = b[_j];
                _results.push(F(x));
              }
              return _results;
            })());
          }
        }
      }));
    }
  };
  monadic('+', 'Conjugate', pervasive(function(x) {
    return x;
  }));
  dyadic('+', 'Add', pervasive(function(y, x) {
    return x + y;
  }));
  monadic('−', 'Negate', pervasive(function(x) {
    return -x;
  }));
  dyadic('−', 'Subtract', pervasive(function(y, x) {
    return x - y;
  }));
  monadic('×', 'Sign of', pervasive(function(x) {
    return (x > 0) - (x < 0);
  }));
  dyadic('×', 'Multiply', pervasive(function(y, x) {
    return x * y;
  }));
  monadic('÷', 'Reciprocal', pervasive(function(x) {
    return 1 / x;
  }));
  dyadic('÷', 'Divide', pervasive(function(y, x) {
    return x / y;
  }));
  monadic('⌈', 'Ceiling', pervasive(function(x) {
    return ceil(x);
  }));
  dyadic('⌈', 'Greater of', pervasive(function(y, x) {
    return max(x, y);
  }));
  monadic('⌊', 'Floor', pervasive(function(x) {
    return floor(x);
  }));
  dyadic('⌊', 'Lesser of', pervasive(function(y, x) {
    return min(x, y);
  }));
  monadic('∣', 'Absolute value', pervasive(function(x) {
    return abs(x);
  }));
  dyadic('∣', 'Residue', pervasive(function(y, x) {
    return y % x;
  }));
  monadic('⍳', 'Index generate', function(a) {
    var r, rec, x, _i, _j, _k, _len, _ref, _results, _results1;
    if (typeof a === 'number') {
      return (function() {
        _results = [];
        for (var _i = 0; 0 <= a ? _i < a : _i > a; 0 <= a ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    } else {
      for (_j = 0, _len = a.length; _j < _len; _j++) {
        x = a[_j];
        assert(typeof x === 'number');
      }
    }
    if (a.length === 1) {
      return (function() {
        _results1 = [];
        for (var _k = 0, _ref = a[0]; 0 <= _ref ? _k < _ref : _k > _ref; 0 <= _ref ? _k++ : _k--){ _results1.push(_k); }
        return _results1;
      }).apply(this);
    }
    r = [];
    rec = function(d, indices) {
      var i, _l, _ref1, _results2;
      if (d >= a.length) {
        return r.push(indices);
      } else {
        _results2 = [];
        for (i = _l = 0, _ref1 = a[d]; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
          _results2.push(rec(d + 1, indices.concat([i])));
        }
        return _results2;
      }
    };
    rec(0, []);
    return r;
  });
  dyadic('⍳', 'Index of', function(b, a) {
    var i, pos, x, y, _i, _j, _len, _len1, _results;
    if (isSimple(a)) {
      a = [a];
    } else {
      assert(shapeOf(a).length <= 1, 'Left argument to ⍳ must be of rank no more than 1.');
    }
    if (isSimple(b)) {
      b = [b];
    }
    _results = [];
    for (_i = 0, _len = b.length; _i < _len; _i++) {
      y = b[_i];
      pos = a.length;
      for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
        x = a[i];
        if (!(match(x, y))) {
          continue;
        }
        pos = i;
        break;
      }
      _results.push(pos);
    }
    return _results;
  });
  monadic('?', 'Roll', pervasive(function(x) {
    return floor(random() * max(0, floor(num(x))));
  }));
  dyadic('?', 'Deal', function(y, x) {
    var available, _i, _j, _results, _results1;
    x = max(0, floor(num(x)));
    y = max(0, floor(num(y)));
    assert(x <= y, 'Domain error: left argument of ? must not be greater than its right argument.');
    available = (function() {
      _results = [];
      for (var _i = 0; 0 <= y ? _i < y : _i > y; 0 <= y ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    _results1 = [];
    for (_j = 0; 0 <= x ? _j < x : _j > x; 0 <= x ? _j++ : _j--) {
      _results1.push(available.splice(floor(available.length * random()), 1)[0]);
    }
    return _results1;
  });
  monadic('⋆', 'Exponentiate', pervasive(function(x) {
    return exp(num(x));
  }));
  dyadic('⋆', 'To the power of', pervasive(function(y, x) {
    return pow(num(x), num(y));
  }));
  monadic('⍟', 'Natural logarithm', pervasive(function(x) {
    return log(x);
  }));
  dyadic('⍟', 'Logarithm to the base', pervasive(function(y, x) {
    return log(y) / log(x);
  }));
  monadic('○', 'Pi times', pervasive(function(x) {
    return PI * x;
  }));
  dyadic('○', 'Circular and hyperbolic functions', pervasive(function(x, i) {
    var ex;
    switch (i) {
      case 0:
        return sqrt(1 - x * x);
      case 1:
        return sin(x);
      case 2:
        return cos(x);
      case 3:
        return tan(x);
      case 4:
        return sqrt(1 + x * x);
      case 5:
        return (exp(2 * x) - 1) / 2;
      case 6:
        return (exp(2 * x) + 1) / 2;
      case 7:
        ex = exp(2 * x);
        return (ex - 1) / (ex + 1);
      case -1:
        return asin(x);
      case -2:
        return acos(x);
      case -3:
        return atan(x);
      case -4:
        return sqrt(x * x - 1);
      case -5:
        return log(x + sqrt(x * x + 1));
      case -6:
        return log(x + sqrt(x * x - 1));
      case -7:
        return log((1 + x) / (1 - x)) / 2;
      default:
        return die('Unknown circular or hyperbolic function ' + i);
    }
  }));
  Gamma = function(x) {
    var a, i, p, t, _i, _ref;
    p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    if (x < 0.5) {
      return PI / (sin(PI * x) * Gamma(1 - x));
    }
    x--;
    a = p[0];
    t = x + 7.5;
    for (i = _i = 1, _ref = p.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
      a += p[i] / (x + i);
    }
    return sqrt(2 * PI) * pow(t, x + 0.5) * exp(-t) * a;
  };
  monadic('!', 'Factorial', pervasive(function(x) {
    var i, r;
    if ((0 <= x && x < 25) && x === floor(x)) {
      r = 1;
      i = 2;
      while (i <= x) {
        r *= i++;
      }
      return r;
    } else if (x < -150) {
      return 0;
    } else if (x > 150) {
      return 1 / 0;
    } else {
      return Gamma(x + 1);
    }
  }));
  dyadic('!', 'Binomial', pervasive(function(b, a) {
    var i, k, n, r, _i;
    k = floor(num(a));
    n = floor(num(b));
    if (!((0 <= k && k <= n))) {
      return 0;
    }
    if (2 * k > n) {
      k = n - k;
    }
    r = 1;
    if (k > 0) {
      for (i = _i = 1; 1 <= k ? _i <= k : _i >= k; i = 1 <= k ? ++_i : --_i) {
        r = r * (n - k + i) / i;
      }
    }
    return r;
  }));
  monadic('⌹', 'Matrix inverse');
  dyadic('⌹', 'Matrix divide');
  dyadic('<', 'Less than', pervasive(function(y, x) {
    return +(x < y);
  }));
  dyadic('≤', 'Less than or equal', pervasive(function(y, x) {
    return +(x <= y);
  }));
  dyadic('=', 'Equal', pervasive(function(y, x) {
    return +(x === y);
  }));
  dyadic('>', 'Greater than', pervasive(function(y, x) {
    return +(x > y);
  }));
  dyadic('≥', 'Greater than or equal', pervasive(function(y, x) {
    return +(x >= y);
  }));
  dyadic('≠', 'Not equal', pervasive(function(y, x) {
    return +(x !== y);
  }));
  monadic('≡', 'Depth', depthOf = function(a) {
    var r, x, _i, _len;
    if (isSimple(a)) {
      return 0;
    }
    r = 0;
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      r = max(r, depthOf(x));
    }
    return r + 1;
  });
  dyadic('≡', 'Match', match = function(b, a) {
    var i, sa, sb, _i, _j, _ref, _ref1;
    if (isSimple(a) && isSimple(b)) {
      return +(a === b);
    }
    if (isSimple(a) !== isSimple(b)) {
      return 0;
    }
    sa = shapeOf(a);
    sb = shapeOf(b);
    if (sa.length !== sb.length) {
      return 0;
    }
    for (i = _i = 0, _ref = sa.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (sa[i] !== sb[i]) {
        return 0;
      }
    }
    if (a.length !== b.length) {
      return 0;
    }
    for (i = _j = 0, _ref1 = a.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      if (!match(a[i], b[i])) {
        return 0;
      }
    }
    if (a.length) {
      return 1;
    }
    if (!((a.aplPrototype != null) || (b.aplPrototype != null))) {
      return 1;
    }
    return match(prototypeOf(a), prototypeOf(b));
  });
  dyadic('≢', 'Not match', function(b, a) {
    return +(!match(b, a));
  });
  monadic('∈', 'Enlist', function(a) {
    var r, rec;
    r = [];
    rec = function(x) {
      var y, _i, _len;
      if (isSimple(x)) {
        r.push(x);
      } else {
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          y = x[_i];
          rec(y);
        }
      }
      return r;
    };
    return rec(a);
  });
  dyadic('∈', 'Membership', function(b, a) {
    var x;
    a = array(a);
    b = array(b);
    return withShape(a.shape, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        _results.push(+(__indexOf.call(b, x) >= 0));
      }
      return _results;
    })());
  });
  dyadic('⍷', 'Find', function(b, a) {
    var i, indices, r, rec, rec2, sa, sb, _i, _ref;
    sa = shapeOf(a);
    sb = shapeOf(b);
    if (isSimple(b)) {
      return isSimple(a) && match(b, a);
    }
    if (isSimple(a)) {
      a = [a];
    }
    r = withShape(sb, (function() {
      var _i, _ref, _results;
      _results = [];
      for (_i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
        _results.push(0);
      }
      return _results;
    })());
    if (sa.length > sb.length) {
      return r;
    }
    while (sa.length < sb.length) {
      sa.unshift(1);
    }
    for (i = _i = 0, _ref = sb.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (sa[i] > sb[i]) {
        return r;
      }
    }
    indices = Array(sb.length);
    rec = function(d, ir) {
      var _j, _ref1, _results;
      if (d < sb.length) {
        _results = [];
        for (i = _j = 0, _ref1 = sb[d] - sa[d] + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          indices[d] = i;
          _results.push(rec(d + 1, ir * sb[d] + i));
        }
        return _results;
      } else {
        return r[ir] = rec2(0, 0, 0);
      }
    };
    rec2 = function(d, ia, ib) {
      var _j, _ref1;
      if (d < sb.length) {
        for (i = _j = 0, _ref1 = sa[d]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          if (!rec2(d + 1, ia * sa[d] + i, ib * sb[d] + indices[d] + i)) {
            return 0;
          }
        }
        return 1;
      } else {
        return match(a[ia], b[ib]);
      }
    };
    rec(0, 0);
    return r;
  });
  monadic('∪', 'Unique', function(a) {
    var r, x, _i, _len, _ref;
    r = [];
    _ref = array(a);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      if (!contains(r, x)) {
        r.push(x);
      }
    }
    return r;
  });
  contains = function(a, x) {
    var y, _i, _len;
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      y = a[_i];
      if (match(x, y)) {
        return true;
      }
    }
    return false;
  };
  dyadic('∪', 'Union', function(b, a) {
    var x;
    a = array(a);
    b = array(b);
    return a.concat((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = b.length; _i < _len; _i++) {
        x = b[_i];
        if (!contains(a, x)) {
          _results.push(x);
        }
      }
      return _results;
    })());
  });
  dyadic('∩', 'Intersection', function(b, a) {
    var x, _i, _len, _results;
    a = array(a);
    b = array(b);
    _results = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      if (contains(b, x)) {
        _results.push(x);
      }
    }
    return _results;
  });
  monadic('∼', 'Not', pervasive(function(x) {
    return +(!bool(x));
  }));
  dyadic('∼', 'Without', function(b, a) {
    var excluded, r, x, y, _i, _j, _len, _len1;
    if (isSimple(a)) {
      a = [a];
    } else {
      assert(shapeOf(a).length <= 1, 'Left argument to ∼ must be of rank no more than 1.');
    }
    if (isSimple(b)) {
      b = [b];
    }
    r = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      excluded = false;
      for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
        y = b[_j];
        if (match(x, y)) {
          excluded = true;
          break;
        }
      }
      if (!excluded) {
        r.push(x);
      }
    }
    return r;
  });
  dyadic('∨', 'Or', pervasive(function(y, x) {
    var _ref, _ref1;
    x = abs(num(x));
    y = abs(num(y));
    assert(x === floor(x) && y === floor(y), '∨ is defined only for integers');
    if (x === 0 && y === 0) {
      return 0;
    }
    if (x < y) {
      _ref = [y, x], x = _ref[0], y = _ref[1];
    }
    while (y) {
      _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];
    }
    return x;
  }));
  dyadic('∧', 'And', pervasive(function(y, x) {
    var p, _ref, _ref1;
    x = abs(num(x));
    y = abs(num(y));
    assert(x === floor(x) && y === floor(y), '∧ is defined only for integers');
    if (x === 0 || y === 0) {
      return 0;
    }
    p = x * y;
    if (x < y) {
      _ref = [y, x], x = _ref[0], y = _ref[1];
    }
    while (y) {
      _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];
    }
    return p / x;
  }));
  dyadic('⍱', 'Nor', pervasive(function(y, x) {
    return +(!(bool(x) || bool(y)));
  }));
  dyadic('⍲', 'Nand', pervasive(function(y, x) {
    return +(!(bool(x) && bool(y)));
  }));
  monadic('⍴', 'Shape of', shapeOf);
  dyadic('⍴', 'Reshape', function(b, a) {
    var i, x;
    if (isSimple(a)) {
      a = [a];
    }
    if (isSimple(b)) {
      b = [b];
    }
    a = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        assert(typeof x === 'number', 'Domain error: Left argument to ⍴ must be a numeric scalar or vector.');
        _results.push(max(0, floor(x)));
      }
      return _results;
    })();
    return withShape(a, withPrototypeCopiedFrom(b, (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = prod(a); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(b[i % b.length]);
      }
      return _results;
    })()));
  });
  catenate = function(b, a, axis) {
    var i, j, k, ni, nja, njb, nk, r, sa, sb, sr, x, _i, _j, _k, _l, _m, _n, _ref;
    if (axis == null) {
      axis = -1;
    }
    sa = shapeOf(a);
    if (sa.length === 0) {
      sa = [1];
      a = [a];
    }
    sb = shapeOf(b);
    if (sb.length === 0) {
      sb = [1];
      b = [b];
    }
    assert(sa.length === sb.length, 'Length error: Cannot catenate arrays of different ranks');
    if (axis < 0) {
      axis += sa.length;
    }
    for (i = _i = 0, _ref = sa.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (sa[i] !== sb[i] && i !== axis) {
        die('Length error: Catenated arrays must match at all axes except the one to catenate on');
      }
    }
    ni = prod(sa.slice(0, axis));
    nja = sa[axis];
    njb = sb[axis];
    nk = prod(sa.slice(axis + 1));
    r = [];
    for (i = _j = 0; 0 <= ni ? _j < ni : _j > ni; i = 0 <= ni ? ++_j : --_j) {
      for (j = _k = 0; 0 <= nja ? _k < nja : _k > nja; j = 0 <= nja ? ++_k : --_k) {
        for (k = _l = 0; 0 <= nk ? _l < nk : _l > nk; k = 0 <= nk ? ++_l : --_l) {
          r.push(a[k + nk * (j + nja * i)]);
        }
      }
      for (j = _m = 0; 0 <= njb ? _m < njb : _m > njb; j = 0 <= njb ? ++_m : --_m) {
        for (k = _n = 0; 0 <= nk ? _n < nk : _n > nk; k = 0 <= nk ? ++_n : --_n) {
          r.push(b[k + nk * (j + njb * i)]);
        }
      }
    }
    sr = (function() {
      var _len, _o, _results;
      _results = [];
      for (_o = 0, _len = sa.length; _o < _len; _o++) {
        x = sa[_o];
        _results.push(x);
      }
      return _results;
    })();
    sr[axis] += sb[axis];
    return withShape(sr, r);
  };
  monadic(',', 'Ravel', function(a) {
    return array(a).slice(0);
  });
  dyadic(',', 'Catenate', catenate);
  dyadic('⍪', '1st axis catenate', function(b, a) {
    return catenate(b, a, 0);
  });
  monadic('⌽', 'Reverse', reverse = function(b, _1, axis) {
    var i, j, k, ni, nj, nk, r, sb, _i, _j, _k, _ref;
    if (axis == null) {
      axis = -1;
    }
    sb = shapeOf(b);
    if (sb.length === 0) {
      return b;
    }
    if (axis < 0) {
      axis += sb.length;
    }
    assert((0 <= axis && axis < sb.length), 'Axis out of bounds');
    ni = prod(sb.slice(0, axis));
    nj = sb[axis];
    nk = prod(sb.slice(axis + 1));
    r = [];
    for (i = _i = 0; 0 <= ni ? _i < ni : _i > ni; i = 0 <= ni ? ++_i : --_i) {
      for (j = _j = _ref = nj - 1; _j >= 0; j = _j += -1) {
        for (k = _k = 0; 0 <= nk ? _k < nk : _k > nk; k = 0 <= nk ? ++_k : --_k) {
          r.push(b[k + nk * (j + nj * i)]);
        }
      }
    }
    return withShape(sb, r);
  });
  dyadic('⌽', 'Rotate', function(b, a) {
    var i, n, sb;
    a = num(a);
    if (a === 0 || isSimple(b) || (b.length <= 1)) {
      return b;
    }
    sb = shapeOf(b);
    n = sb[sb.length - 1];
    a %= n;
    if (a < 0) {
      a += n;
    }
    return withShape(sb, (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(b[i - (i % n) + ((i % n) + a) % n]);
      }
      return _results;
    })());
  });
  monadic('⊖', '1st axis reverse', function(b, _1, axis) {
    if (axis == null) {
      axis = 0;
    }
    return reverse(b, void 0, axis);
  });
  dyadic('⊖', '1st axis rotate', function(b, a) {
    var i, k, n, sb;
    a = num(a);
    if (a === 0 || isSimple(b) || (b.length <= 1)) {
      return b;
    }
    sb = shapeOf(b);
    n = sb[0];
    k = b.length / n;
    a %= n;
    if (a < 0) {
      a += n;
    }
    return withShape(sb, (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(b[((floor(i / k) + a) % n) * k + (i % k)]);
      }
      return _results;
    })());
  });
  monadic('⍉', 'Transpose', function(a) {
    var i, psr, r, rec, sa, sr, _i, _ref;
    sa = shapeOf(a);
    if (sa.length <= 1) {
      return a;
    }
    sr = sa.slice(0).reverse();
    psr = [1];
    for (i = _i = 0, _ref = sa.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      psr.push(psr[i] * sr[i]);
    }
    r = [];
    rec = function(d, i) {
      var j, _j, _ref1;
      if (d >= sa.length) {
        r.push(a[i]);
      } else {
        for (j = _j = 0, _ref1 = sr[d]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          rec(d + 1, i + j * psr[d]);
        }
      }
      return 0;
    };
    rec(0, 0);
    return withShape(sr, r);
  });
  monadic('↑', 'First', function(a) {
    a = array(a);
    if (a.length) {
      return a[0];
    } else {
      return prototypeOf(a);
    }
  });
  dyadic('↑', 'Take', function(b, a) {
    var filler, i, pa, r, rec, sb, x, _i, _len;
    if (isSimple(a)) {
      a = [a];
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      assert(typeof x === 'number', 'Domain error: Left argument to ↑ must be a numeric scalar or vector.');
    }
    if (isSimple(b) && a.length === 1) {
      b = [b];
    }
    sb = shapeOf(b);
    assert(a.length === sb.length, 'Length error: Left argument to ↑ must have as many elements as is the rank of its right argument.');
    r = [];
    pa = (function() {
      var _j, _ref, _results;
      _results = [];
      for (_j = 0, _ref = a.length; 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
        _results.push(0);
      }
      return _results;
    })();
    pa[a.length - 1] = 1;
    i = a.length - 2;
    while (i >= 0) {
      pa[i] = pa[i + 1] * a[i + 1];
      i--;
    }
    filler = prototypeOf(b);
    rec = function(d, i, k) {
      var j, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      if (d >= sb.length) {
        r.push(b[i]);
      } else {
        k /= sb[d];
        if (a[d] >= 0) {
          for (j = _j = 0, _ref = min(a[d], sb[d]); 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
            rec(d + 1, i + j * k, k);
          }
          if (sb[d] < a[d]) {
            for (_k = 0, _ref1 = (a[d] - sb[d]) * pa[d]; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; 0 <= _ref1 ? _k++ : _k--) {
              r.push(filler);
            }
          }
        } else {
          if (sb[d] + a[d] < 0) {
            for (_l = 0, _ref2 = -(sb[d] + a[d]) * pa[d]; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; 0 <= _ref2 ? _l++ : _l--) {
              r.push(filler);
            }
          }
          for (j = _m = _ref3 = max(0, sb[d] + a[d]), _ref4 = sb[d]; _ref3 <= _ref4 ? _m < _ref4 : _m > _ref4; j = _ref3 <= _ref4 ? ++_m : --_m) {
            rec(d + 1, i + j * k, k);
          }
        }
      }
      return 0;
    };
    rec(0, 0, b.length);
    return withShape(a, withPrototype(filler, r));
  });
  dyadic('↓', 'Drop', function(b, a) {
    var hi, i, lims, lo, r, rec, sb, sr, x, _i, _j, _len, _ref, _ref1;
    if (isSimple(a)) {
      a = [a];
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      if (typeof x !== 'number' || x !== floor(x)) {
        die('Left argument to ↓ must be an integer or a vector of integers.');
      }
    }
    if (isSimple(b)) {
      b = withShape((function() {
        var _j, _ref, _results;
        _results = [];
        for (_j = 0, _ref = a.length; 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
          _results.push(1);
        }
        return _results;
      })(), b);
    }
    sb = shapeOf(b);
    if (a.length > sb.length) {
      die('The left argument to ↓ must have length less than or equal to the rank of its right argument.');
    }
    for (_j = _ref = a.length, _ref1 = sb.length; _ref <= _ref1 ? _j < _ref1 : _j > _ref1; _ref <= _ref1 ? _j++ : _j--) {
      a.push(0);
    }
    lims = (function() {
      var _k, _ref2, _results;
      _results = [];
      for (i = _k = 0, _ref2 = a.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        if (a[i] >= 0) {
          _results.push([min(a[i], sb[i]), sb[i]]);
        } else {
          _results.push([0, max(0, sb[i] + a[i])]);
        }
      }
      return _results;
    })();
    r = [];
    rec = function(d, i, n) {
      var j, _k, _ref2, _ref3;
      if (d >= sb.length) {
        r.push(b[i]);
      } else {
        n /= sb[d];
        for (j = _k = _ref2 = lims[d][0], _ref3 = lims[d][1]; _ref2 <= _ref3 ? _k < _ref3 : _k > _ref3; j = _ref2 <= _ref3 ? ++_k : --_k) {
          rec(d + 1, i + j * n, n);
        }
      }
      return 0;
    };
    rec(0, 0, b.length);
    sr = (function() {
      var _k, _len1, _ref2, _results;
      _results = [];
      for (_k = 0, _len1 = lims.length; _k < _len1; _k++) {
        _ref2 = lims[_k], lo = _ref2[0], hi = _ref2[1];
        _results.push(hi - lo);
      }
      return _results;
    })();
    return withShape(sr, r);
  });
  monadic('⊂', 'Enclose', function(a) {
    if (isSimple(a)) {
      return a;
    } else {
      return withShape([], [a]);
    }
  });
  dyadic('⊂', 'Partition (with axis)');
  monadic('⊃', 'Disclose', function(a) {
    var i, r, rec, sa, sr, sr1, sx, x, _i, _j, _k, _len, _len1, _ref, _ref1;
    if (isSimple(a)) {
      return a;
    }
    sa = shapeOf(a);
    if (sa.length === 0) {
      return a[0];
    }
    sr1 = shapeOf(a[0]).slice(0);
    _ref = a.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      sx = shapeOf(x);
      if (sx.length !== sr1.length) {
        die('The argument of ⊃ must contain elements of the same rank.');
      }
      for (i = _j = 0, _ref1 = sr1.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        sr1[i] = max(sr1[i], sx[i]);
      }
    }
    sr = shapeOf(a).concat(sr1);
    r = [];
    for (_k = 0, _len1 = a.length; _k < _len1; _k++) {
      x = a[_k];
      sx = shapeOf(x);
      rec = function(d, i, n, N) {
        var filler, j, _l, _m, _ref2, _ref3, _results;
        if (d >= sr1.length) {
          return r.push(x[i]);
        } else {
          n /= sx[d];
          N /= sr1[d];
          for (j = _l = 0, _ref2 = sx[d]; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; j = 0 <= _ref2 ? ++_l : --_l) {
            rec(d + 1, i + j * n, n, N);
          }
          if (sr1[d] > sx[d]) {
            filler = prototypeOf(x);
            _results = [];
            for (_m = 0, _ref3 = N * (sr1[d] - sx[d]); 0 <= _ref3 ? _m < _ref3 : _m > _ref3; 0 <= _ref3 ? _m++ : _m--) {
              _results.push(r.push(filler));
            }
            return _results;
          }
        }
      };
      rec(0, 0, x.length, prod(sr1));
    }
    return withShape(sr, r);
  });
  dyadic('⊃', 'Pick');
  dyadic('⌷', 'Index', function(b, a) {
    var d, i, r, rec, sb, sr, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
    if (isSimple(a)) {
      a = [a];
    }
    assert((!a.shape) || a.shape.length <= 1, 'Indices must be a scalar or a vector, not a higher-dimensional array.');
    sb = shapeOf(b);
    if (typeof b === 'function') {
      return function(y, x) {
        return b(y, x, a);
      };
    }
    assert(a.length === sb.length, 'The number of indices must be equal to the rank of the indexable.');
    a = (function() {
      var _i, _j, _len, _ref, _results, _results1;
      _results = [];
      for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
        x = a[i];
        if (isSimple(x)) {
          _results.push(withShape([], [x]));
        } else if (!x.length) {
          _results.push((function() {
            _results1 = [];
            for (var _j = 0, _ref = sb[i]; 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
            return _results1;
          }).apply(this));
        } else {
          _results.push(x);
        }
      }
      return _results;
    })();
    for (d = _i = 0, _len = a.length; _i < _len; d = ++_i) {
      x = a[d];
      for (_j = 0, _len1 = x.length; _j < _len1; _j++) {
        y = x[_j];
        if (!(typeof y === 'number' && y === floor(y))) {
          die('Indices must be integers');
        }
      }
    }
    for (d = _k = 0, _len2 = a.length; _k < _len2; d = ++_k) {
      x = a[d];
      for (_l = 0, _len3 = x.length; _l < _len3; _l++) {
        y = x[_l];
        if (!((0 <= y && y < sb[d]))) {
          die('Index out of bounds');
        }
      }
    }
    sr = [];
    for (_m = 0, _len4 = a.length; _m < _len4; _m++) {
      x = a[_m];
      sr = sr.concat(shapeOf(x));
    }
    r = [];
    rec = function(d, i, n) {
      var _len5, _n, _ref;
      if (d >= a.length) {
        r.push(b[i]);
      } else {
        _ref = a[d];
        for (_n = 0, _len5 = _ref.length; _n < _len5; _n++) {
          x = _ref[_n];
          rec(d + 1, i + (x * n / sb[d]), n / sb[d]);
        }
      }
      return 0;
    };
    rec(0, 0, b.length);
    if (sr.length === 0) {
      return r[0];
    } else {
      return withShape(sr, r);
    }
  });
  grade = function(b, a, direction) {
    var h, i, m, n, r, sa, sb, _i, _j, _ref, _ref1, _results;
    if (!(a != null)) {
      a = [];
    }
    sa = shapeOf(a);
    sb = shapeOf(b);
    assert(sa.length, 'Left argument to ⍋ or ⍒ must be non-scalar.');
    if (sb.length === 0) {
      return b;
    }
    n = sa[sa.length - 1];
    h = {};
    for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      h[a[i]] = i % n;
    }
    m = b.length / sb[0];
    r = (function() {
      _results = [];
      for (var _j = 0, _ref1 = sb[0]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this);
    r.sort(function(i, j) {
      var k, tx, ty, x, y, _k;
      for (k = _k = 0; 0 <= m ? _k < m : _k > m; k = 0 <= m ? ++_k : --_k) {
        x = b[m * i + k];
        y = b[m * j + k];
        tx = typeof x;
        ty = typeof y;
        if (tx < ty) {
          return -direction;
        }
        if (tx > ty) {
          return direction;
        }
        if (h[x] != null) {
          x = h[x];
        }
        if (h[y] != null) {
          y = h[y];
        }
        if (x < y) {
          return -direction;
        }
        if (x > y) {
          return direction;
        }
      }
      return 0;
    });
    return r;
  };
  monadic('⍋', 'Grade up', function(b, a) {
    return grade(b, a, 1);
  });
  monadic('⍒', 'Grade down', function(b, a) {
    return grade(b, a, -1);
  });
  monadic('⊤', 'Encode', function(b, a) {
    var i, isNeg, j, k, m, n, r, sa, sb, x, y, _i, _j, _k, _len, _ref;
    sa = shapeOf(a);
    sb = shapeOf(b);
    if (isSimple(a)) {
      a = [a];
    }
    if (isSimple(b)) {
      b = [b];
    }
    r = Array(a.length * b.length);
    n = sa.length ? sa[0] : 1;
    m = a.length / n;
    for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
      for (j = _j = 0, _len = b.length; _j < _len; j = ++_j) {
        y = b[j];
        if (isNeg = y < 0) {
          y = -y;
        }
        for (k = _k = _ref = n - 1; _k >= 0; k = _k += -1) {
          x = a[k * m + i];
          if (x === 0) {
            r[(k * m + i) * b.length + j] = y;
            y = 0;
          } else {
            r[(k * m + i) * b.length + j] = y % x;
            y = round((y - (y % x)) / x);
          }
        }
      }
    }
    return withShape(sa.concat(sb), r);
  });
  monadic('⊥', 'Decode', function(b, a) {
    var firstDimB, i, j, k, lastDimA, r, sa, sb, x, y, z, _i, _j, _k, _ref, _ref1, _ref2;
    sa = shapeOf(a);
    sb = shapeOf(b);
    lastDimA = sa.length ? sa[sa.length - 1] : 1;
    firstDimB = sb.length ? sb[0] : 1;
    assert(lastDimA === 1 || firstDimB === 1 || lastDimA === firstDimB, 'Incompatible shapes for ⊥ ("Decode")');
    if (isSimple(a)) {
      a = [a];
    }
    if (isSimple(b)) {
      b = [b];
    }
    r = [];
    for (i = _i = 0, _ref = a.length / lastDimA; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = b.length / firstDimB; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        x = a.slice(i * lastDimA, (i + 1) * lastDimA);
        y = (function() {
          var _k, _results;
          _results = [];
          for (k = _k = 0; 0 <= firstDimB ? _k < firstDimB : _k > firstDimB; k = 0 <= firstDimB ? ++_k : --_k) {
            _results.push(b[j + k * (b.length / firstDimB)]);
          }
          return _results;
        })();
        if (x.length === 1) {
          x = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (_k = 0, _ref2 = y.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
              _results.push(x[0]);
            }
            return _results;
          })();
        }
        if (y.length === 1) {
          y = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (_k = 0, _ref2 = x.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; 0 <= _ref2 ? _k++ : _k--) {
              _results.push(y[0]);
            }
            return _results;
          })();
        }
        z = y[0];
        for (k = _k = 1, _ref2 = y.length; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 1 <= _ref2 ? ++_k : --_k) {
          z = z * x[k] + y[k];
        }
        r.push(z);
      }
    }
    if (sa.length <= 1 && sb.length <= 1) {
      return r[0];
    } else {
      return withShape(sa.slice(0, -1).concat(sb.slice(1)), r);
    }
  });
  monadic('⍕', 'Format');
  dyadic('⍕', 'Format by example or specification');
  monadic('⍎', 'Execute');
  monadic('⊣', 'Stop');
  dyadic('⊣', 'Left');
  monadic('⊢', 'Pass');
  dyadic('⊢', 'Right');
  builtins['⍬'] = [];
  reduce = function(f, _, axis) {
    if (axis == null) {
      axis = -1;
    }
    return function(b, a) {
      var i, invokedAsMonadic, isBackwards, items, j, k, n, r, sItem, sb, x, _i, _ref;
      invokedAsMonadic = !(a != null);
      if (invokedAsMonadic) {
        a = 0;
      }
      a = floor(num(a));
      isBackwards = a < 0;
      if (isBackwards) {
        a = -a;
      }
      b = array(b);
      sb = shapeOf(b);
      if (axis < 0) {
        axis += sb.length;
      }
      n = sb[axis];
      if (a === 0) {
        a = n;
      }
      if (sb.length === 1) {
        items = b;
      } else {
        sItem = sb.slice(0, axis).concat(sb.slice(axis + 1));
        k = prod(sb.slice(axis + 1));
        items = (function() {
          var _i, _results;
          _results = [];
          for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
            _results.push(withShape(sItem, []));
          }
          return _results;
        })();
        for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          items[floor(i / k) % n].push(b[i]);
        }
      }
      r = (function() {
        var _j, _k, _l, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results, _results1;
        if (isBackwards) {
          _results = [];
          for (i = _j = 0, _ref1 = n - a + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            x = items[i + a - 1];
            for (j = _k = _ref2 = i + a - 2, _ref3 = i - 1; _k > _ref3; j = _k += -1) {
              x = f(items[j], x);
            }
            _results.push(x);
          }
          return _results;
        } else {
          _results1 = [];
          for (i = _l = 0, _ref4 = n - a + 1; 0 <= _ref4 ? _l < _ref4 : _l > _ref4; i = 0 <= _ref4 ? ++_l : --_l) {
            x = items[i];
            for (j = _m = _ref5 = i + 1, _ref6 = i + a; _m < _ref6; j = _m += 1) {
              x = f(items[j], x);
            }
            _results1.push(x);
          }
          return _results1;
        }
      })();
      if (invokedAsMonadic) {
        return r[0];
      } else {
        return r;
      }
    };
  };
  compressOrReplicate = function(b, a, axis) {
    var filler, i, isExpansive, isExtensive, isHyperexpansive, j, k, nNonNegative, ni, nj, nk, r, sb, sr, x, _i, _j, _k, _l, _len, _len1, _m, _n, _ref;
    if (axis == null) {
      axis = -1;
    }
    sb = shapeOf(b);
    if (axis < 0) {
      axis += sb.length;
    }
    assert((0 <= axis && axis < sb.length), 'Axis out of bounds');
    sr = sb.slice(0);
    sr[axis] = 0;
    assert(shapeOf(a).length <= 1, 'Left argument to / must be an integer or a vector of integers');
    if (!a.length) {
      a = (function() {
        var _i, _ref, _results;
        _results = [];
        for (_i = 0, _ref = sb[axis]; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
          _results.push(a);
        }
        return _results;
      })();
    }
    nNonNegative = 0;
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      assert(typeof x === 'number' && x === floor(x, 'Left argument to / must be an integer or a vector of integers'));
      sr[axis] += abs(x);
      nNonNegative += x >= 0;
    }
    isExtensive = true;
    isExpansive = isHyperexpansive = false;
    if (sb[axis] !== 1) {
      isExtensive = false;
      isExpansive = a.length === sb[axis];
      isHyperexpansive = !isExpansive;
      assert((!isHyperexpansive) || nNonNegative === sb[axis], 'For A/B, the length of B along the selected axis ' + 'must be equal either to one, ' + 'or the length of A, ' + 'or to the number of non-negative elements in A.');
    }
    r = [];
    ni = prod(sb.slice(0, axis));
    nj = sb[axis];
    nk = prod(sb.slice(axis + 1));
    for (i = _j = 0; 0 <= ni ? _j < ni : _j > ni; i = 0 <= ni ? ++_j : --_j) {
      j = 0;
      for (_k = 0, _len1 = a.length; _k < _len1; _k++) {
        x = a[_k];
        if (x > 0) {
          for (_l = 0; 0 <= x ? _l < x : _l > x; 0 <= x ? _l++ : _l--) {
            for (k = _m = 0; 0 <= nk ? _m < nk : _m > nk; k = 0 <= nk ? ++_m : --_m) {
              r.push(b[k + nk * (j + nj * i)]);
            }
          }
          j += isExpansive || isHyperexpansive;
        } else {
          filler = prototypeOf(isExpansive ? [b[nk * (j + nj * i)]] : [b[nk * nj * i]]);
          for (_n = 0, _ref = -x * nk; 0 <= _ref ? _n < _ref : _n > _ref; 0 <= _ref ? _n++ : _n--) {
            r.push(filler);
          }
          j += isExpansive;
        }
      }
    }
    return withShape(sr, r);
  };
  postfixOperator('/', 'Reduce, compress, or replicate', function(b, a, axis) {
    if (axis == null) {
      axis = -1;
    }
    if (typeof b === 'function') {
      return reduce(b, void 0, axis);
    } else {
      return compressOrReplicate(b, a, axis);
    }
  });
  postfixOperator('⌿', '1st axis reduce, compress, or replicate', function(b, a, axis) {
    if (axis == null) {
      axis = 0;
    }
    if (typeof b === 'function') {
      return reduce(b, void 0, axis);
    } else {
      return compressOrReplicate(b, a, axis);
    }
  });
  scan = function(f, _, axis) {
    if (axis == null) {
      axis = -1;
    }
    return function(a, _1) {
      var i, ijk, j, k, ni, nj, nk, r, sa, x, _i, _j, _k;
      assert(!(_1 != null), 'Scan can only be applied monadically.');
      sa = shapeOf(a);
      if (sa.length === 0) {
        return a;
      }
      if (axis < 0) {
        axis += sa.length;
      }
      r = Array(a.length);
      ni = prod(sa.slice(0, axis));
      nj = sa[axis];
      nk = prod(sa.slice(axis + 1));
      for (i = _i = 0; 0 <= ni ? _i < ni : _i > ni; i = 0 <= ni ? ++_i : --_i) {
        for (k = _j = 0; 0 <= nk ? _j < nk : _j > nk; k = 0 <= nk ? ++_j : --_j) {
          x = r[k + nk * nj * i] = a[k + nk * nj * i];
          for (j = _k = 1; 1 <= nj ? _k < nj : _k > nj; j = 1 <= nj ? ++_k : --_k) {
            ijk = k + nk * (j + nj * i);
            x = r[ijk] = f(a[ijk], x);
          }
        }
      }
      return withShape(shapeOf(a), r);
    };
  };
  expand = function() {};
  postfixOperator('\\', 'Scan or expand', function(b, a, axis) {
    if (axis == null) {
      axis = -1;
    }
    if (typeof b === 'function') {
      return scan(b, void 0, axis);
    } else {
      return expand(b, a, axis);
    }
  });
  postfixOperator('⍀', '1st axis scan or expand', function(b, a, axis) {
    if (axis == null) {
      axis = 0;
    }
    if (typeof b === 'function') {
      return scan(b, void 0, axis);
    } else {
      return expand(b, a, axis);
    }
  });
  postfixOperator('¨', 'Each', function(f) {
    return function(b, a) {
      var i, x;
      if (!(a != null)) {
        return (function() {
          var _i, _len, _ref, _results;
          _ref = array(b);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            _results.push(f(x));
          }
          return _results;
        })();
      }
      if (isSimple(a)) {
        return (function() {
          var _i, _len, _ref, _results;
          _ref = array(b);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            _results.push(f(x, a));
          }
          return _results;
        })();
      }
      if (a.length === b.length) {
        return (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(f(b[i], a[i]));
          }
          return _results;
        })();
      }
      if (a.length === 1) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = b.length; _i < _len; _i++) {
            x = b[_i];
            _results.push(f(x, a[0]));
          }
          return _results;
        })();
      }
      if (b.length === 1) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            x = a[_i];
            _results.push(f(b[0], x));
          }
          return _results;
        })();
      }
      return die('Length error');
    };
  });
  prefixOperator('∘.', 'Outer product', outerProduct = function(f) {
    assert(typeof f === 'function');
    return function(b, a) {
      var r, x, y, _i, _j, _len, _len1;
      assert(a != null, 'Operator ∘. (Outer product) works only with dyadic functions');
      a = array(a);
      b = array(b);
      r = [];
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
          y = b[_j];
          r.push(f(y, x));
        }
      }
      return withShape((shapeOf(a)).concat(shapeOf(b)), r);
    };
  });
  infixOperator('.', 'Inner product', function(g, f) {
    var F;
    F = reduce(f);
    return function(b, a) {
      assert(shapeOf(a).length <= 1 && shapeOf(b).length <= 1, 'Inner product operator (.) is implemented only for arrays of rank no more than 1.');
      return F(g(b, a));
    };
  });
  infixOperator('⍣', 'Power operator', function(f, n) {
    var _ref;
    if (typeof f === 'number' && typeof n === 'function') {
      _ref = [n, f], f = _ref[0], n = _ref[1];
    } else {
      assert(typeof f === 'function' && typeof n === 'number');
    }
    return function(y, x) {
      var _i;
      for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
        y = f(y, x);
      }
      return y;
    };
  });
  builtins['set_⎕'] = function(x) {
    console.info(x);
    return x;
  };
  builtins.aplify = function(x) {
    assert(x !== null);
    assert(typeof x !== 'undefined');
    if (typeof x === 'string') {
      x = withPrototype(' ', x.split(''));
    }
    return x;
  };
  endOfBuiltins();
  return {
    builtins: builtins
  };
});
